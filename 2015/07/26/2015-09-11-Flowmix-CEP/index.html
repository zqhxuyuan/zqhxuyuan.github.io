<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Storm的CEP框架 flowmix | zqhxuyuan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Flowmix - A Flexible Event Processing Engine for Apache Storm: http://github.com/zqhxuyuan/bigdata/tree/master/storm/storm-flowmix">
<meta name="keywords" content="storm">
<meta property="og:type" content="article">
<meta property="og:title" content="Storm的CEP框架 flowmix">
<meta property="og:url" content="http://github.com/zqhxuyuan/2015/07/26/2015-09-11-Flowmix-CEP/index.html">
<meta property="og:site_name" content="zqhxuyuan">
<meta property="og:description" content="Flowmix - A Flexible Event Processing Engine for Apache Storm: http://github.com/zqhxuyuan/bigdata/tree/master/storm/storm-flowmix">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708092402373">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708093105550">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708093116711">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708093130878">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709081303848">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708113729249">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709081336225">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709095638536">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709135059685">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155902538">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155918256">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155928663">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155939147">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155949616">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155959413">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160132603">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160144803">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160154912">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160204697">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160215494">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160854993">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160712170412780">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713073820989">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713073839872">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713073927302">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713073940811">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713080136719">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713080148140">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713080202171">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713080213890">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713162734311">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713084423487">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713111804601">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713171704132">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713150515435">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180829872">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180841077">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180851154">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180902561">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180914358">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180924514">
<meta property="og:updated_time" content="2019-02-14T13:42:29.187Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Storm的CEP框架 flowmix">
<meta name="twitter:description" content="Flowmix - A Flexible Event Processing Engine for Apache Storm: http://github.com/zqhxuyuan/bigdata/tree/master/storm/storm-flowmix">
<meta name="twitter:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708092402373">
  
    <link rel="alternative" href="/atom.xml" title="zqhxuyuan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars1.githubusercontent.com/u/1088525?v=3&amp;s=180" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任何忧伤,都抵不过世界的美丽</a></h1>
		</hgroup>

		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">归档</a></li>
				        
							<li><a href="/tags/">标签</a></li>
				        
							<li><a href="/about/">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/xuyuantree" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="http://github.com/zqhxuyuan" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/apex/" style="font-size: 10px;">apex</a> <a href="/tags/bigdata/" style="font-size: 10px;">bigdata</a> <a href="/tags/book/" style="font-size: 10px;">book</a> <a href="/tags/cassandra/" style="font-size: 18.89px;">cassandra</a> <a href="/tags/clojure/" style="font-size: 10px;">clojure</a> <a href="/tags/drill/" style="font-size: 16.67px;">drill</a> <a href="/tags/druid/" style="font-size: 13.33px;">druid</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/etl/" style="font-size: 10px;">etl</a> <a href="/tags/geode/" style="font-size: 10px;">geode</a> <a href="/tags/graph/" style="font-size: 12.22px;">graph</a> <a href="/tags/hadoop/" style="font-size: 11.11px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 15.56px;">hbase</a> <a href="/tags/ignite/" style="font-size: 10px;">ignite</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/kafka/" style="font-size: 20px;">kafka</a> <a href="/tags/midd/" style="font-size: 10px;">midd</a> <a href="/tags/ops/" style="font-size: 12.22px;">ops</a> <a href="/tags/redis/" style="font-size: 11.11px;">redis</a> <a href="/tags/rocketmq/" style="font-size: 10px;">rocketmq</a> <a href="/tags/scala/" style="font-size: 13.33px;">scala</a> <a href="/tags/spark/" style="font-size: 17.78px;">spark</a> <a href="/tags/storm/" style="font-size: 17.78px;">storm</a> <a href="/tags/tcc/" style="font-size: 10px;">tcc</a> <a href="/tags/timeseries/" style="font-size: 12.22px;">timeseries</a> <a href="/tags/work/" style="font-size: 14.44px;">work</a> <a href="/tags/流处理/" style="font-size: 11.11px;">流处理</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">BIG(DATA)</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">任何忧伤,都抵不过世界的美丽</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="https://avatars1.githubusercontent.com/u/1088525?v=3&amp;s=180" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">任何忧伤,都抵不过世界的美丽</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">归档</a></li>
		        
					<li><a href="/tags/">标签</a></li>
		        
					<li><a href="/about/">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/xuyuantree" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="http://github.com/zqhxuyuan" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-2015-09-11-Flowmix-CEP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/26/2015-09-11-Flowmix-CEP/" class="article-date">
  	<time datetime="2015-07-25T16:00:00.000Z" itemprop="datePublished">2015-07-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Storm的CEP框架 flowmix
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/bigdata/">bigdata</a>
	</div>


        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/storm/">storm</a></li></ul>
	</div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>Flowmix - A Flexible Event Processing Engine for Apache Storm: <a href="http://github.com/zqhxuyuan/bigdata/tree/master/storm/storm-flowmix">http://github.com/zqhxuyuan/bigdata/tree/master/storm/storm-flowmix</a></p>
<a id="more"></a>
<h2 id="Introduce">Introduce</h2><p>One of the solutions Flowmix offers to the resource and sliding window orchestration problem is having a single topology<br>deployed with a generic “stream” of domain-agnostic objects that can be routed around in different ways,<br>applying different operations to the events on their way through the bolts of the topology.<br>The streams can be split and joined together, bridged to other streams, and passed through a standard pluggable output bolt.<br>Events can be passed through relational operations like partitioning, aggregating, collecting, sorting, filtering, selection, and joining.</p>
<p>Other non-relational operations like switches and governors can also be applied to orchestrate the flow of a stream of data.<br>Generic functions can be applied to each event as it passes through a stream.</p>
<h2 id="示例">示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregatorExample</span> <span class="keyword">implements</span> <span class="title">FlowProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Flow&gt; <span class="title">getFlows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Flow flow = <span class="keyword">new</span> FlowBuilder()</span><br><span class="line">            .id(<span class="string">"flow1"</span>)</span><br><span class="line">            .flowDefs()</span><br><span class="line">                .stream(<span class="string">"stream1"</span>)</span><br><span class="line">                    .select().fields(<span class="string">"key3"</span>).end()</span><br><span class="line">                    .aggregate().aggregator(CountAggregator.class)</span><br><span class="line">                        .config(<span class="string">"operatedField"</span>, <span class="string">"key3"</span>)</span><br><span class="line">                        .evict(Policy.COUNT, <span class="number">50000</span>)</span><br><span class="line">                        .trigger(Policy.TIME, <span class="number">5</span>)</span><br><span class="line">                        .windowEvictMillis(<span class="number">3600000</span>) <span class="comment">//60min window</span></span><br><span class="line">                        .clearOnTrigger().end()</span><br><span class="line">                .endStream()</span><br><span class="line">            .endDefs()</span><br><span class="line">            .createFlow();</span><br><span class="line">        <span class="keyword">return</span> asList(<span class="keyword">new</span> Flow[]&#123;flow&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ExampleRunner(<span class="keyword">new</span> AggregatorExample()).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRunner</span> </span>&#123;</span><br><span class="line">    FlowProvider provider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleRunner</span><span class="params">(FlowProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.provider = provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StormTopology topology = <span class="keyword">new</span> FlowmixBuilder()</span><br><span class="line">                .setFlowLoader(<span class="keyword">new</span> SimpleFlowLoaderSpout(provider.getFlows(), <span class="number">60000</span>))</span><br><span class="line">                .setEventsLoader(<span class="keyword">new</span> MockOneEventGeneratorSpout(<span class="number">5000</span>))</span><br><span class="line">                .setOutputBolt(<span class="keyword">new</span> PrinterBolt())</span><br><span class="line">                .setParallelismHint(<span class="number">6</span>)</span><br><span class="line">                .create()</span><br><span class="line">                .createTopology();</span><br><span class="line">        LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line">        cluster.submitTopology(<span class="string">"example-topology"</span>, <span class="keyword">new</span> Config(), topology);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRunner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Flow&gt; <span class="title">getFlows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Flow flow = <span class="keyword">new</span> FlowBuilder()</span><br><span class="line">                .id(<span class="string">"flow1"</span>)</span><br><span class="line">                .flowDefs()             <span class="comment">//调用者：FlowBuilder，返回值：FlowDefsBuilder</span></span><br><span class="line">                    .stream(<span class="string">"stream1"</span>)  <span class="comment">//调用者：FlowDefsBuilder，返回值：StreamBuilder</span></span><br><span class="line">                        .select().fields(<span class="string">"key3"</span>).end()</span><br><span class="line">                        .aggregate().aggregator(CountAggregator.class)</span><br><span class="line">                            .config(<span class="string">"operatedField"</span>, <span class="string">"key3"</span>)</span><br><span class="line">                            .evict(Policy.COUNT, <span class="number">50000</span>)</span><br><span class="line">                            .trigger(Policy.TIME, <span class="number">5</span>)</span><br><span class="line">                            .windowEvictMillis(<span class="number">3600000</span>)</span><br><span class="line">                            .clearOnTrigger().end()</span><br><span class="line">                    .endStream()        <span class="comment">//调用者：StreamBuilder，返回值：FlowDefsBuilder </span></span><br><span class="line">                .endDefs()              <span class="comment">//调用者：FlowDefsBuilder，返回值：FlowBuilder</span></span><br><span class="line">                .createFlow();          <span class="comment">//调用者：FlowBuilder，返回值：Flow</span></span><br><span class="line">        <span class="keyword">return</span> asList(<span class="keyword">new</span> Flow[]&#123;flow&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        StormTopology topology = <span class="keyword">new</span> FlowmixBuilder()</span><br><span class="line">                .setFlowLoader(<span class="keyword">new</span> SimpleFlowLoaderSpout(getFlows(), <span class="number">60000</span>))</span><br><span class="line">                .setEventsLoader(<span class="keyword">new</span> MockOneEventGeneratorSpout(<span class="number">5000</span>))</span><br><span class="line">                .setOutputBolt(<span class="keyword">new</span> PrinterBolt())</span><br><span class="line">                .setParallelismHint(<span class="number">6</span>)</span><br><span class="line">                .create()</span><br><span class="line">                .createTopology();</span><br><span class="line">        LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line">        cluster.submitTopology(<span class="string">"example-topology"</span>, <span class="keyword">new</span> Config(), topology);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过FlowBuilder构造的Flow作为Spout构造函数的参数，允许Spout接收多个Flow。</p>
<h2 id="Topology组件">Topology组件</h2><p>Flowmix在构建Topology时，各个组件的关系：</p>
<ol>
<li>一个Topology可以有多个Flow</li>
<li>一个Flow只能有一个FlowBuilder，Flow通过FlowBuilder生成</li>
<li>一个FlowBuilder只有一个FlowDefsBuilder</li>
<li>一个FlowDefsBuilder调用一次stream，就会生成一个StreamBuilder</li>
<li>因此一个FlowDefsBuilder可以有多个StreamBuilder</li>
<li>在每个StreamBuilder上，调用不同的算子方法（比如select,aggregate），都会在StreamBuilder上添加一个对应的FlowOp（比如select生成SelectOp，aggregate生成AggregateOp） </li>
<li>最终在StreamBuilder上调用endStream时，会将上一步所有算子产生的FlowOp列表，封装成StreamDef</li>
<li>因此一个StreamBuilder只有一个StreamDef</li>
<li>由于一个FlowDefsBuilder可以有多个StreamBuilder，而每个StreamBuilder都有一个StreamDef，所以一个FlowDefsBuilder可以有多个StreamDef</li>
<li>一个Flow对应一个FlowDefsBuilder，所以FlowDefsBuilder的StreamDef列表会被设置到Flow中，作为Flow的成员变量</li>
</ol>
<p>步骤4中：在一个FlowDefsBuilder上可以调用多次stream方法，从而构建多个Stream，示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Flow flow = <span class="keyword">new</span> FlowBuilder()</span><br><span class="line">    .id(<span class="string">"flow1"</span>)</span><br><span class="line">    .flowDefs()             <span class="comment">//FlowDefsBuilder      </span></span><br><span class="line">        .stream(<span class="string">"stream1"</span>)  <span class="comment">//StreamBuilder 1</span></span><br><span class="line">            .select().fields(<span class="string">"key1"</span>).end()  <span class="comment">//FlowOp 1</span></span><br><span class="line">            .aggregate().....end()          <span class="comment">//FlowOp 2</span></span><br><span class="line">        .endStream()                        <span class="comment">//StreamDef 1        </span></span><br><span class="line">        .stream(<span class="string">"stream2"</span>)  <span class="comment">//StreamBuilder 2</span></span><br><span class="line">            .select().fields(<span class="string">"key1"</span>).end()  <span class="comment">//FlowOp 1</span></span><br><span class="line">            .aggregate().....end()          <span class="comment">//FlowOp 2</span></span><br><span class="line">        .endStream()                        <span class="comment">//StreamDef 2</span></span><br><span class="line">    .endDefs()              </span><br><span class="line">    .createFlow();          </span><br><span class="line"><span class="keyword">return</span> asList(<span class="keyword">new</span> Flow[]&#123;flow&#125;);</span><br></pre></td></tr></table></figure>
<p>下图上面左图都定义了一个Flow，不同的是左边只有一个Stream，右边定义了两个Stream。</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708092402373" alt="flowmix1"></p>
<p>Flow实际上需要的是FlowOp（集合，每种算子都是一个FlowOp），通过Builder构建。</p>
<h2 id="Builder">Builder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowBuilder</span> </span>&#123;</span><br><span class="line">    Flow flow = <span class="keyword">new</span> Flow();</span><br><span class="line">    FlowDefsBuilder flowOpsBuilder=<span class="keyword">new</span> FlowDefsBuilder(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FlowDefsBuilder <span class="title">flowDefs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flowOpsBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flow <span class="title">createFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flow.setStreams(flowOpsBuilder.getStreamList());</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowDefsBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FlowBuilder flowBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlowDefsBuilder</span><span class="params">(FlowBuilder flowBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flowBuilder = flowBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FlowBuilder <span class="title">endDefs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> flowBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamBuilder <span class="title">stream</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StreamBuilder(<span class="keyword">this</span>, name, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;StreamDef&gt; streamList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;StreamDef&gt; <span class="title">getStreamList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> streamList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addStream</span><span class="params">(StreamDef stream)</span> </span>&#123;</span><br><span class="line">        streamList.add(stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FlowOp&gt; flowOpList = <span class="keyword">new</span> ArrayList&lt;FlowOp&gt;();</span><br><span class="line">    <span class="keyword">private</span> FlowDefsBuilder flowOpsBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamBuilder</span><span class="params">(FlowDefsBuilder flowOpsBuilder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.flowOpsBuilder = flowOpsBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectBuilder <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SelectBuilder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AggregateBuilder <span class="title">aggregate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AggregateBuilder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FlowDefsBuilder <span class="title">endStream</span><span class="params">(String... outputs)</span> </span>&#123;</span><br><span class="line">      StreamDef def=<span class="keyword">new</span> StreamDef(name,flowOpList,stdInput,stdOutput,outputs);</span><br><span class="line">      flowOpsBuilder.addStream(def);</span><br><span class="line">      <span class="keyword">return</span> flowOpsBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addFlowOp</span><span class="params">(FlowOp flowOp)</span> </span>&#123;</span><br><span class="line">        flowOpList.add(flowOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StreamBuilder streamBuilder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelectBuilder</span><span class="params">(StreamBuilder streamBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.streamBuilder = streamBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamBuilder <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        streamBuilder.addFlowOp(<span class="keyword">new</span> SelectOp(...));</span><br><span class="line">        <span class="keyword">return</span> streamBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregateBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractOpBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StreamBuilder streamBuilder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AggregateBuilder</span><span class="params">(StreamBuilder streamBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.streamBuilder = streamBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamBuilder <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      streamBuilder.addFlowOp(<span class="keyword">new</span> AggregateOp(...));</span><br><span class="line">      <span class="keyword">return</span> streamBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是各个Builder之间的关系图，绿色部分是Builder需要保存的数据</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708093105550" alt="flowmix2"></p>
<p>下图从最后的FlowOp到StreamDef，最后传递给Flow</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708093116711" alt="flowmix3"></p>
<p>下图是各个Builder的调用顺序</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708093130878" alt="flowmix4"></p>
<h3 id="算子Builder">算子Builder</h3><p>各种不同算子的Builder和算子的关系是：以链式方式调用Builder的各种set/with方法，同时每个set方法都有对应的成员变量，<br>最后在结束build的时候，把每个set方法产生的变量，创建出算子：  </p>
<p>伪代码(scala)如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> flowOp: <span class="type">MyFlowOp</span> = <span class="type">MyBuilder</span>.withMethod1(<span class="string">"value1"</span>)</span><br><span class="line">                            .withMethod2(<span class="string">"value2"</span>)</span><br><span class="line">                            .withMethod3(<span class="string">"value3"</span>)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlowOP</span>(<span class="params">param1, param2, param3</span>)</span></span><br></pre></td></tr></table></figure>
<p>以AggregateBuilder为例(其他类型的Builder类似)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregateBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractOpBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends Aggregator&gt; aggregatorClass;</span><br><span class="line">    <span class="keyword">private</span> Policy triggerPolicy;   <span class="comment">//触发策略.比如每隔10分钟,或每隔100条数据,统计一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> triggerThreshold = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Policy evictionPolicy;  <span class="comment">//失效策略.当事件进来10分钟后,或者事件总数到达1000条后,移除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> evictionThreshold = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> clearOnTrigger = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> windowEvictMillis = <span class="number">3600000</span>;   <span class="comment">// 60 minutes by default</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; config = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AggregateBuilder <span class="title">aggregator</span><span class="params">(Class&lt;? extends Aggregator&gt; aggregatorClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aggregatorClass = aggregatorClass;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AggregateBuilder <span class="title">trigger</span><span class="params">(Policy policy, <span class="keyword">long</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.triggerPolicy = policy;</span><br><span class="line">        <span class="keyword">this</span>.triggerThreshold = threshold;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法类似，都set方式，设置成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamBuilder <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="comment">//实际上是build方法，一定要到最后才能执行</span></span><br><span class="line">      AggregateOp flowOp = <span class="keyword">new</span> AggregateOp(aggregatorClass, </span><br><span class="line">                triggerPolicy, triggerThreshold, evictionPolicy,</span><br><span class="line">                evictionThreshold, config, clearOnTrigger, windowEvictMillis));</span><br><span class="line">      getStreamBuilder().addFlowOp(flowOp);          </span><br><span class="line">      <span class="keyword">return</span> getStreamBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FlowOpBuilder用来构建FlowOp，FlowOp算子可以理解为Storm中Spout/Bolt组件的元数据，<br>比如SelectOp选择算子需要知道要select哪些字段，<br>FilterOp过滤算子需要知道过滤方式，AggregateOp聚合算子需要知道聚合的方式（聚合算法，比如Count/Sum等）。</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709081303848" alt="flowmix5"></p>
<p>在Storm中，Topology由Spout/Bolt组件组成一个DAG，Spout/Bolt会从数据源/上游接收Tuple，然后处理Tuple，最后向下游Bolt发送Tuple。<br>Tuple即数据是流动的，而Spout/Bolt组件是不动的，它们只负责接收数据、处理数据、发送数据。下图中DAG的边是Tuple数据，顶点则是Spout/Bolt计算组件。 </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160708113729249" alt="storm-topo1"></p>
<p>而这里的算子可以认为是Spout/Bolt组件的元数据，但它们本身不是Spout/Bolt，因为它们并没有处理数据。<br>比如AggregeOp算子只是一个Bean Object，定义了聚合算子的元数据！</p>
<p>正如FlowOp算子是Spout/Bolt组件的元数据，Flow也可以看做是Topology的元数据。<br>元数据不负责接收数据，不负责计算数据，不负责产生数据。  </p>
<table>
<thead>
<tr>
<th>管理者</th>
<th>组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>Topology</td>
<td>Spout、Bolt</td>
</tr>
<tr>
<td>Flow</td>
<td>FlowOp</td>
</tr>
</tbody>
</table>
<p>目前为止，我们看到在StreamBuilder上依次调用select(),aggregate(),filter()等产生的算子组成的flowOpList是一个ArrayList，数组链表是有序的！<br>这也确保了Flow的各个算子是有序的。比如调用.select().filter().aggregate()或者.filter().aggregate().select()都是不一样的！</p>
<table>
<thead>
<tr>
<th>StreamBuilder invoke flow</th>
<th>List<flowop></flowop></th>
</tr>
</thead>
<tbody>
<tr>
<td>select().aggregate().filter()</td>
<td>ArrayList<flowop>(SelectOp,AggregateOp,FilterOp)</flowop></td>
</tr>
<tr>
<td>select().filter().aggregate()</td>
<td>ArrayList<flowop>(SelectOp,FilterOp,AggregateOp)</flowop></td>
</tr>
<tr>
<td>filter().aggregate().select()</td>
<td>ArrayList<flowop>(FilterOp,AggregateOp,SelectOp)</flowop></td>
</tr>
</tbody>
</table>
<p>在StreamBuilder中，创建StreamDef时，有几个比较重要的变量：stdInput, stdOutput, outputs。<br>这里主要是用来在不同Stream之间进行数据的交互。我们上面看到的示例定义的Stream都是单独的一个Stream，或者即使定义了多个Stream，也没有关联关系。<br>但是如果想要关联两个Stream，比如进行Join操作，就需要在这里做文章。这部分比较复杂，后面再分析。</p>
<h2 id="FlowmixBuilder">FlowmixBuilder</h2><p>下面是客户端应用程序创建StormTopology的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StormTopology topology = <span class="keyword">new</span> FlowmixBuilder()</span><br><span class="line">        .setFlowLoader(<span class="keyword">new</span> SimpleFlowLoaderSpout(provider.getFlows(), <span class="number">60000</span>)) <span class="comment">//Flow Loader</span></span><br><span class="line">        .setEventsLoader(<span class="keyword">new</span> MockOneEventGeneratorSpout(<span class="number">5000</span>)) <span class="comment">//Event Loader</span></span><br><span class="line">        .setOutputBolt(<span class="keyword">new</span> PrinterBolt()) <span class="comment">//Final Output</span></span><br><span class="line">        .setParallelismHint(<span class="number">6</span>)</span><br><span class="line">        .create()</span><br><span class="line">        .createTopology();</span><br></pre></td></tr></table></figure>
<p>Storm的Topology只由Spout/Bolt组成，那么上面Flow定义的算子怎么和Topology的组件结合上呢？<br>其实我们的目的是希望算子能和对应的Bolt对应上来，比如SelectOp对应SelectBolt，FilterOp对应FilterBolt，<br>由于客户端应用程序并没有builder.setBolt这样的代码，而只是定义了FlowOp组成的Flow，<br>那么<strong>Flow中的FlowOp必须要能够转换为Bolt才可以形成Storm所需的Topology</strong>。<br>并且FlowOp组成的Flow是一个DAG（有序的），所以FlowOp对应的Bolt也是一个DAG（同样的顺序）。  </p>
<p>在一般的Topology中，Spout负责读取输入源数据，Spout后的第一个Bolt读取Spout发送的数据，<br>然后发送给后续的Bolt，后续的Bolt会读取上一个Bolt发射的数据，经过计算后发送新数据给下一个Bolt。  </p>
<p>这里除了负责读取输入源/事件数据的EventSpout外，还有另外两个Spout：  </p>
<ol>
<li>Event事件流：EventSpout，负责读取事件数据</li>
<li>Flow算子流：FlowLoaderSpout，负责加载应用程序配置的Flow</li>
<li>Tick时钟流：TickSpout，实现窗口计算的关键组件</li>
</ol>
<p>这三个Spout对应发射的stream-id，发射字段和发射数据如下表：  </p>
<table>
<thead>
<tr>
<th>Component</th>
<th>emit stream-id</th>
<th>emit fields</th>
<th>emit values</th>
</tr>
</thead>
<tbody>
<tr>
<td>MockOneEventGeneratorSpout</td>
<td>default</td>
<td>event</td>
<td>Event</td>
</tr>
<tr>
<td>SimpleFlowLoaderSpout</td>
<td>FLOW_LOADER_STREAM</td>
<td>flows</td>
<td>List<flow></flow></td>
</tr>
<tr>
<td>TickSpout</td>
<td>tick</td>
<td>null</td>
<td>null</td>
</tr>
</tbody>
</table>
<p>紧接着几个Spout后的第一个Bolt是FlowInitializerBolt，它的职责除了接收事件数据外，还要接收客户端定义的List<flow>。<br>并且FlowInitBolt接收上游EventSpout和FlowLoaderSpout的分组策略是不同的：  </flow></p>
<ol>
<li>EventSpout分组方式：shuffleGrouping</li>
<li>FlowLoaderSpout分组方式：allGrouping</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TopologyBuilder <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">    builder.setSpout(EVENT, (IRichSpout) eventsComponent, eventLoaderParallelism);</span><br><span class="line">    builder.setSpout(FLOW_LOADER_STREAM, (IRichSpout) flowLoaderSpout, <span class="number">1</span>);</span><br><span class="line">    builder.setSpout(<span class="string">"tick"</span>, <span class="keyword">new</span> TickSpout(<span class="number">1000</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    builder.setBolt(INITIALIZER, <span class="keyword">new</span> FlowInitializerBolt(), parallelismHint)  <span class="comment">// kicks off a flow determining where to start</span></span><br><span class="line">              .localOrShuffleGrouping(EVENT)  <span class="comment">//事件流可以通过shuffle负载到Bolt的Tasks上</span></span><br><span class="line">              .allGrouping(FLOW_LOADER_STREAM, FLOW_LOADER_STREAM); <span class="comment">//Flow流通过All Grouping策略发射给Bolt的每个Task</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面假设FloInitBolt设置的并行度为3，即存在3个Task，其中FlowLoaderSpout发射出来的数据会发送到每个Task，<br>而EventSpout发射的事件则是shuffle方式（类似于RoundRobin，假设有三个事件，则每个Task只会收到一个事件）。  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709081336225" alt="flowmix-init bolt"></p>
<blockquote>
<p>Flow流是静态的，必须每个Task都要有这份数据，而且每个Task收到的这份数据(即flows)都是一致的。<br>事件流是动态的，EventSpout发送出去的事件，经过shuffle落到各个FlowInitBolt的Task上是不同的。</p>
</blockquote>
<h3 id="Event_Spout">Event Spout</h3><p>EventSpout在发射时没有指定stream-id。所以上面设置FlowInitBolt的localOrShuffleGrouping只有一个参数EVENT，而没有stream-id第二个参数。<br>EventSpout虽然没有指定stream-id，但是它下游接收的Bolt只可能是FlowInitBolt，不可能是其他Bolt（比如我们自定义的SelectBolt等）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockOneEventGeneratorSpout</span> <span class="keyword">extends</span> <span class="title">EventsLoaderBaseSpout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sleepBetweenEvents = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> SpoutOutputCollector collector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockOneEventGeneratorSpout</span><span class="params">(<span class="keyword">int</span> sleepBetweenEvents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sleepBetweenEvents = sleepBetweenEvents;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collector = spoutOutputCollector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Event event = MockEvent.mockOneEvent();</span><br><span class="line">        collector.emit(<span class="keyword">new</span> Values(singleton(event)));</span><br><span class="line">        Thread.sleep(sleepBetweenEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"event"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Spout没有定义输出的stream-id，下游接收该Spout的Bolt（比如这里是FlowInitBolt）在grouping策略中也不需要定义stream-id，默认没有指定时为default。</p>
</blockquote>
<h3 id="FlowLoader_Spout">FlowLoader Spout</h3><p>FlowLoaderSpout构造函数接收List<flow>参数，Flow集合是在应用程序中创建的（比如ExampleRunner的getFlows方法）。<br>通常Storm的Spout负责读取一些外部数据源，比如KafkaSpout会读取Kafka的消息流，或者RandomWordSpout会随机产生一些单词。<br>Spout的职责是将从Kafka读取的消息流，或者随机产生的单词发送出去。至于要发送到下游哪个Bolt，则有下游Bolt自己在Group中指定。  </flow></p>
<blockquote>
<p>并不是在Spout中指定要发送到下游具体的Bolt，而是由下游自己指定要读取哪个上游的Spout/Bolt。<br>有点像消息系统中push和pull的区别，push是主动将消息推给消费者，push是消费者主动拉取消息。<br>这种方式的好处是：下游消费者可以动态增加，动态订阅任意的消息输入源。如果用push方式，Broker必须要<br>指定推送消息给哪些消费者，如果要增加新的消费者，Broker代码需要变更才能重新使用。<br>同样的Spout并不指定下游组件，而是由下游组件自己定义要读取哪些数据源。如果由Spout推送消息给下游组件，<br>但是下游组件失败了怎么办，或者某个Bolt后来不需要Spout的消息，或者有新的Bolt需要让Spout推送给它，都不容易实现。<br><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709095638536" alt="flowmix6"></p>
</blockquote>
<blockquote>
<p>举个现实的例子：老家的房子都是有屋檐的，下雨的时候，屋顶下形成的一排排的水柱看起来非常壮观，<br>当然水柱的数量和屋顶上瓦片形成的缝隙一样（假设有10个），两个瓦片之间形成一道水柱（自行脑补下雨的场景）。<br>但是雨水形成的每个水柱的水量是不同的，我们会在水量比较大的底下放上水盆盛水，水量小的就不放水盆了。<br>这里假设Spout的输入源是天上下的雨，Spout可以并行处理多个任务，屋顶每两排瓦片之间形成的水流都是一个Task，<br>所以每个Task读取的输入源数据都是不一样的（同一滴雨只会流入一个水流，不会同时出现在两个水流里）。<br>正常来说每个Task输出的stream-id可以都是默认一样的（default），不过这里到下游组件时，我们假设Spout的水流形成<br>的水柱的stream-id是不一样的，也就是瓦片1-瓦片2之间的水柱的stream-id=”stream-id-1”，<br>瓦片2和瓦片3之间水柱的stream-id=”stream-id2”，其他水柱都是类似的，最后Spout一共发射了10个不同的stream-id。<br>如果在某个水柱下面没有放水盆，那么这条水柱的水不会被收集，也就是会被丢弃掉。对应Spout，如果发射的某个stream，<br>但是下游的Bolt组件中没有一个人订阅了这个stream，那么那条stream上的Tuple消息全部被丢弃。</p>
</blockquote>
<p>FlowLoaderSpout发送flows数据给下游组件时，指定了stream-id=FLOW_LOADER_STREAM。<br>那么下游组件只有订阅了当前这个SimpleFlowLoaderSpout（Grouping的第一个参数），<br>而且第二个参数stream-id=FLOW_LOADER_STREAM时，才会接收到SimpleFlowLoaderSpout发射的flows数据。<br>比如上面的FlowInitBolt就满足了这个特点：<code>allGrouping(FLOW_LOADER_STREAM, FLOW_LOADER_STREAM);</code>。  </p>
<blockquote>
<p>这里虽然两个参数都是FLOW_LOADER_STREAM，但是含义是不同的：第一个参数是component-id，第二个是stream-id。<br>这句话的意思是当前Bolt（即FlowInitBolt），会读取Topology中<strong>component-id=FLOW_LOADER_STREAM</strong>的组件<br>（比如这里SimpleFlowLoaderSpout的component-id就是FLOW_LOADER_STREAM：<br>builder.setSpout(FLOW_LOADER_STREAM, (IRichSpout) flowLoaderSpout, 1)），<br>而且只会读取这个组件发射出stream-id=FLOW_LOADER_STREAM。<br>恰好下面SimpleFlowLoaderSpout发射的stream-id就是FLOW_LOADER_STREAM。  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFlowLoaderSpout</span> <span class="keyword">extends</span> <span class="title">BaseRichSpout</span> </span>&#123;</span><br><span class="line">    Collection&lt;Flow&gt; flows;  <span class="comment">//Flow的Spout可以有多个,比如两个Flow进行join</span></span><br><span class="line">    <span class="keyword">long</span> pauseBetweenLoads = <span class="number">1000</span>; <span class="comment">//1秒</span></span><br><span class="line">    SpoutOutputCollector collector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数由Application调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleFlowLoaderSpout</span><span class="params">(Collection&lt;Flow&gt; flows, <span class="keyword">long</span> pauseBetweenLoads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flows = flows;</span><br><span class="line">        <span class="keyword">this</span>.pauseBetweenLoads = pauseBetweenLoads;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//open方法的初始化由Storm框架调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collector = spoutOutputCollector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据源每当收到一条数据,就往Topology中发射</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        collector.emit(FLOW_LOADER_STREAM, <span class="keyword">new</span> Values(flows)); <span class="comment">//flow是传给Spout的流程定义对象.Flow中定义了FlowOp操作符.</span></span><br><span class="line">        Thread.sleep(pauseBetweenLoads);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//outputFieldsDeclarer.declare(new Fields("flows"));</span></span><br><span class="line">        <span class="comment">//指定stream-id,好让topology中当前spout的下一个bolt得到这个stream-id</span></span><br><span class="line">        outputFieldsDeclarer.declareStream(FLOW_LOADER_STREAM, <span class="keyword">new</span> Fields(<span class="string">"flows"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>spout/bolt可以使用emit(streamId, tuple)把元组分发到多个流，参数streamId是一个用来标识流的字符串。<br>然后，你可以在TopologyBuilder决定由哪个流订阅它emit的3个参数:<br>发送到的streamid, anchors(来源tuples), tuple(values list)</p>
</blockquote>
<h3 id="Tick_Spout">Tick Spout</h3><p>FlowInitBolt似乎只关心EventSpout和FlowLoaderSpout，并不会读取TickSpout的数据（虽然TickSpout没有发射任何消息）。<br>TickSpout和EventLoaderSpout类似，都定义了stream-id。既然FlowInitBolt不会读取TickSpout，那么谁会扛起这个重任呢？  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TickSpout</span> <span class="keyword">extends</span> <span class="title">BaseRichSpout</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sleepMillis; <span class="comment">//tick时钟的时间间隔</span></span><br><span class="line">    <span class="keyword">private</span> SpoutOutputCollector collector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TickSpout</span><span class="params">(<span class="keyword">long</span> sleepMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sleepMillis = sleepMillis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declareStream(<span class="string">"tick"</span>, <span class="keyword">new</span> Fields());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collector = spoutOutputCollector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        collector.emit(<span class="string">"tick"</span>, <span class="keyword">new</span> Values());</span><br><span class="line">        Thread.sleep(sleepMillis); <span class="comment">//这里用来模拟定时发送tick</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FlowInitializerBolt">FlowInitializerBolt</h3><p>前面我们知道FlowInitBolt会接收EventSpout和FlowLoaderSpout发射的数据，前者是动态的事件流，后者是静态的Flow流。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.setBolt(INITIALIZER, <span class="keyword">new</span> FlowInitializerBolt(), parallelismHint)</span><br><span class="line">          .localOrShuffleGrouping(EVENT) <span class="comment">//FlowInitBolt订阅了EVENT这个component-id，即EventSpout</span></span><br><span class="line">          .allGrouping(FLOW_LOADER_STREAM, FLOW_LOADER_STREAM); <span class="comment">//FlowInitBolt订阅了FLOW_LOADER_STREAM，即FlowLoaderSpout</span></span><br></pre></td></tr></table></figure>
<p>FlowInitBolt如果收到FlowLoaderSpout，只需要存储flows，实际上FlowInitBolt只是初始化工作，并没有能力处理Flow！<br>如果收到的是EventSpout发射的事件，必须确保flows是存在的，如果没有存在flows，而先收到了Event，这些Event是会被丢弃的。<br>因为Event需要通过Flow处理才能真正起作用，如果没有Flow，即使来了事件也是白搭。好比我都没准备好要处理，有事件来了也没办法处理。  </p>
<p>在有flows的前提下处理EventSpout发射的Event比较关键（Tuple的sourceStream不等于tick，因为FlowInit并不会接收TickSpout）：<br>下面有三个For循环，第一个For循环是事件，因为EventSpout可能会一次发射多条事件（这里实际上只有一条事件包装成single元素的Collection），<br>第二层for循环是Flow，前面的应用程序中我们知道getFlows返回的是List<flow>，不过大部分例子都只有一个Flow。<br>最后一层for循环是StreamDef，针对每个Flow，如果应用程序定义了多个stream，则每个Stream（第一个算子）都会接收到Tuple中的每一条事件！  </flow></p>
<p>虽然会循环每个Stream，而Stream是由FlowOp组成的，那么FlowOp应该能够和Bolt对应上来，这样Event通过FlowOp就能发送到指定的Bolt。<br>StreamDef.getFlowOps()返回的是StreamBuilder中的List<flowop>，即应用程序中每个stream后调用的各个算子组成的数组链表。<br>以前面的<code>.select().aggregate().filter()</code>为例，数组链表第一个元素是SelectOp，对应的stream-id=select，<br>如果stream的调用链是<code>.filter().select.aggregate()</code>，则第一个元素FilterOp对应的stream-id=filter，其他都是类似的。  </flowop></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Flow flow = <span class="keyword">new</span> FlowBuilder()</span><br><span class="line">    .id(<span class="string">"flow1"</span>)</span><br><span class="line">    .flowDefs()             <span class="comment">//FlowDefsBuilder      </span></span><br><span class="line">        .stream(<span class="string">"stream1"</span>)  <span class="comment">//StreamBuilder 1</span></span><br><span class="line">            .select().fields(<span class="string">"key1"</span>).end()  <span class="comment">//FlowOp 1</span></span><br><span class="line">            .aggregate().....end()          <span class="comment">//FlowOp 2</span></span><br><span class="line">            .filter()....end                <span class="comment">//FlowOp 3</span></span><br><span class="line">        .endStream()                        <span class="comment">//StreamDef 1        </span></span><br><span class="line">        .stream(<span class="string">"stream2"</span>)  <span class="comment">//StreamBuilder 2</span></span><br><span class="line">            .filter().....end()             <span class="comment">//FlowOp 1</span></span><br><span class="line">            .select().....end               <span class="comment">//FlowOp 2</span></span><br><span class="line">            .aggregate().....end()          <span class="comment">//FlowOp 3</span></span><br><span class="line">        .endStream()                        <span class="comment">//StreamDef 2</span></span><br><span class="line">    .endDefs()              </span><br><span class="line">    .createFlow();          </span><br><span class="line"><span class="keyword">return</span> asList(<span class="keyword">new</span> Flow[]&#123;flow&#125;);</span><br></pre></td></tr></table></figure>
<p>上面一个Flow定义了两个Stream，每个Stream的第一个FlowOp（第一个Stream的SelectOp，第二个Stream的FilterOp）都会收到EventSpout发射的事件。<br>等等，这么说有点问题！前面我们说过不管是Spout或者Bolt都只是负责发送Tuple而已，并不会指定Tuple会发送给下游哪些Bolt！<br>所以对于每个Stream的第一个FlowOp对应的Bolt要想订阅FlowInitBolt发射的消息，<br>它们的分组策略第一个参数必须是FlowInitializerBolt对应的component-id（这里是INITIALIZER），<br>关键是<strong>下游Bolt分组策略的第二个参数stream-id需要和这里FlowInitBolt发射出去的stream-id一致</strong>。  </p>
<blockquote>
<p>注：下面代码中的注释是第一次读代码时写的，现在重新理解，有些地方还不是很严谨，这里保留的目的是看下当初自己是怎么读的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowInitializerBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Flow&gt; flows;  <span class="comment">//flow-id -&gt; Flow</span></span><br><span class="line">    OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collector = outputCollector;</span><br><span class="line">        flows = <span class="keyword">new</span> HashMap&lt;String, Flow&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Spout的emit方法的stream-id=FLOW_LOADER_STREAM,tuple=flows</span></span><br><span class="line">        <span class="keyword">if</span>(FLOW_LOADER_STREAM.equals(tuple.getSourceStreamId())) &#123;</span><br><span class="line">            <span class="comment">//因为只有一个字段:new Values(flows),所以bolt通过getValue(0)可以获取到flows</span></span><br><span class="line">            <span class="keyword">for</span>(Flow flow : (Collection&lt;Flow&gt;)tuple.getValue(<span class="number">0</span>))</span><br><span class="line">                flows.put(flow.getId(), flow);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="string">"tick"</span>.equals(tuple.getSourceStreamId()))&#123;</span><br><span class="line">            <span class="comment">//因为有flows和events两个Spout发送tuple(实际上还有一个tick spout).下面是接收到事件tuple的处理</span></span><br><span class="line">            <span class="keyword">if</span>(flows.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//一个flowLoaderSpout会有多个flows</span></span><br><span class="line">                <span class="keyword">for</span>(Flow flow : flows.values()) &#123;</span><br><span class="line">                    Collection&lt;Event&gt; events = (Collection&lt;Event&gt;) tuple.getValue(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">for</span>(Event event : events) &#123;</span><br><span class="line">                        <span class="comment">//一个Flow会有多个Stream.初始Bolt是发射给一个Flow中所有Stream的第一个FlowOp.注意这些Stream是平等的(非标准输入的Stream除外).</span></span><br><span class="line">                        <span class="comment">//即初始Bolt发射的Tuple会往所有Stream发射. 而不是说Stream之间是链接的,只发给第一个Stream,第一个Stream完成后将发给第二个Stream.</span></span><br><span class="line">                        <span class="comment">//这实际上是AllGrouping的策略.即相同的数据发给所有其他的Bolt.</span></span><br><span class="line">                        <span class="keyword">for</span>(StreamDef stream : flow.getStreams()) &#123;</span><br><span class="line">                            <span class="comment">//取Flow的stream的第一个component(FlowOp).因为这是初始化Bolt.</span></span><br><span class="line">                            String streamid = stream.getFlowOps().get(<span class="number">0</span>).getComponentName();</span><br><span class="line">                            String streamName = stream.getName();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//JoinExample中stream3:.stream("stream3", false).因为它不是从源数据过来的,而是从其他Stream发射数据给它使用.所以不是标准的输入.</span></span><br><span class="line">                            <span class="comment">//标准的输入即InitBolt发射的Tuple不会发射给非标准输入的Stream.因为非标准输入的Stream不是来自于InitBolt,而是来自其他Stream.</span></span><br><span class="line">                            <span class="keyword">if</span>(stream.isStdInput())</span><br><span class="line">                              <span class="comment">//tuple还是events,不会发生变化. 第二个参数tuple是anchor锚点.在最后进行ack.</span></span><br><span class="line">                              <span class="comment">//FLOW_OP_IDX=-1,接收到的Bolt会根据这些字段构造FlowInfo,并且idx+1.所以下一个Bolt的FlowInfo实际IDX=0</span></span><br><span class="line">                              collector.emit(streamid, tuple, <span class="keyword">new</span> Values(flow.getId(), event, -<span class="number">1</span>, streamName, streamName));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            collector.ack(tuple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        FlowmixBuilder.declareOutputStreams(outputFieldsDeclarer, fields);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Storm中GeneralTopologyContext的componentToStreamToFields表示: component包含哪些streams, 每个stream包含哪些fields<br>上游组件通过declareStream定义了stream-id -&gt; Fields，下游组件通过分组策略定义了component-id -&gt; stream-id</p>
</blockquote>
<p>由于每个Stream的List<flowop>的第一个FlowOp不是固定的，所以需要在declareOutputFields定义所有可能用到的算子。<br>即使有些算子用不到，也都要全部定义，毕竟你不知道你的应用程序具体的第一个FlowOp是什么，那么全部定义也不会怀孕的。  </flowop></p>
<blockquote>
<p>假设Bolt的declareOutputFields定义了10个输出stream，而实际emit时可能只会选择其中的一个stream-id，也不会有问题。</p>
</blockquote>
<p>在Bolt中发射的Fileds和Values的字段数量必须一致，下面的Values中如果是在一个Flow的一个Stream中，第一个参数和最后两个参数都不会变化。<br>当然同一个Flow不同的Stream，不同的是最后两个参数，以前面定义的两个Stream为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">collector.emit(streamid, tuple, new Values(flow.getId(), event, -1, streamName, streamName));</span><br><span class="line"></span><br><span class="line">collector.emit(&quot;select&quot;, tuple, new Values(&quot;flow1&quot;, event, -1, &quot;stream1&quot;, &quot;stream1&quot;)); //第一个Stream第一个FlowOp是SelectOp</span><br><span class="line">collector.emit(&quot;filter&quot;, tuple, new Values(&quot;flow1&quot;, event, -1, &quot;stream2&quot;, &quot;stream2&quot;)); //第二个Stream第一个FlowOp是FilterOp</span><br></pre></td></tr></table></figure>
<p>下表是目前为止所有FlowOp实现类对应的component-name，注意这些名称实际上会作为对应聚合Bolt的component-name。</p>
<table>
<thead>
<tr>
<th>FlowOp</th>
<th>component-name</th>
<th>对应的Bolt</th>
</tr>
</thead>
<tbody>
<tr>
<td>SelectOp</td>
<td>select</td>
<td>SelectBolt</td>
</tr>
<tr>
<td>FilterOp</td>
<td>filter</td>
<td>FilterBolt</td>
</tr>
<tr>
<td>AggregateOp</td>
<td>aggregate</td>
<td>AggregateBolt</td>
</tr>
<tr>
<td>EachOp</td>
<td>each</td>
<td>EachBolt</td>
</tr>
<tr>
<td>JoinOp</td>
<td>join</td>
<td>JoinBolt</td>
</tr>
<tr>
<td>PartitionOp</td>
<td>partition</td>
<td>PartitionBolt</td>
</tr>
<tr>
<td>SortOp</td>
<td>sort</td>
<td>SortBolt</td>
</tr>
<tr>
<td>SplitOp</td>
<td>split</td>
<td>SplitBolt</td>
</tr>
<tr>
<td>Switch</td>
<td>stopGate</td>
<td>SwitchBolt</td>
</tr>
</tbody>
</table>
<blockquote>
<p>虽然Topology由Spout和Bolt组成，而且这里有三个Spout（实际上EventSpout其实没有定义stream-id），<br>不过下面的declareOutputStreams并不需要定义Spout的steam-id，因为stream-id的作用是指向下游Bolt，<br>而Spout不可能会去接收Bolt的数据！Spout只可能发送数据给下游Bolt，不要强人所难！人家只发不接的！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Fields fields = <span class="keyword">new</span> Fields(FLOW_ID, EVENT, FLOW_OP_IDX, STREAM_NAME, LAST_STREAM);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Fields partitionFields = <span class="keyword">new</span> Fields(FLOW_ID, EVENT, FLOW_OP_IDX, STREAM_NAME, PARTITION, LAST_STREAM);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">declareOutputStreams</span><span class="params">(OutputFieldsDeclarer declarer, Fields fields)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于设置Grouping策略时使用了component-id,stream-id. 所以声明输出字段时,也要加上stream-id</span></span><br><span class="line">    declarer.declareStream(PARTITION, fields);</span><br><span class="line">    declarer.declareStream(FILTER, fields);</span><br><span class="line">    declarer.declareStream(SELECT, fields);</span><br><span class="line">    declarer.declareStream(AGGREGATE, fields);</span><br><span class="line">    declarer.declareStream(SWITCH, fields);</span><br><span class="line">    declarer.declareStream(SORT, fields);</span><br><span class="line">    declarer.declareStream(JOIN, fields);</span><br><span class="line">    declarer.declareStream(SPLIT, fields);</span><br><span class="line">    declarer.declareStream(EACH, fields);</span><br><span class="line">    declarer.declareStream(OUTPUT, fields);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的分析我们知道，虽然FlowInitBolt发射时指定了stream-id是Stream中第一个FlowOp的名称（上面几种算子中的某一个）。<br>但是下游Bolt要想获得FlowInitBolt发射的消息，必须在分组策略时做文章：<br>确保订阅了FlowInitBolt的component-id，以及FlowInitBolt发射的stream-id。  </p>
<h3 id="Dynamic_FlowOp’s_Bolt_Definition">Dynamic FlowOp’s Bolt Definition</h3><p>stream-id和在Topology中定义Bolt时指定分组策略的第二个参数息息相关。<br>下面我们就回到FlowmixBuilder这个类中接着FlowInitBolt后面定义算子类型的Bolt部分：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CEP Bolt Definition</span></span><br><span class="line">declarebolt(builder, FILTER, <span class="keyword">new</span> FilterBolt(), parallelismHint, <span class="keyword">true</span>);</span><br><span class="line">declarebolt(builder, SELECT, <span class="keyword">new</span> SelectorBolt(), parallelismHint, <span class="keyword">true</span>);</span><br><span class="line">declarebolt(builder, PARTITION, <span class="keyword">new</span> PartitionBolt(), parallelismHint, <span class="keyword">true</span>);</span><br><span class="line">declarebolt(builder, SWITCH, <span class="keyword">new</span> SwitchBolt(), parallelismHint, <span class="keyword">true</span>);</span><br><span class="line">declarebolt(builder, AGGREGATE, <span class="keyword">new</span> AggregatorBolt(), parallelismHint, <span class="keyword">true</span>);</span><br><span class="line">declarebolt(builder, JOIN, <span class="keyword">new</span> JoinBolt(), parallelismHint, <span class="keyword">true</span>);</span><br><span class="line">declarebolt(builder, EACH, <span class="keyword">new</span> EachBolt(), parallelismHint, <span class="keyword">true</span>);</span><br><span class="line">declarebolt(builder, SORT, <span class="keyword">new</span> SortBolt(), parallelismHint, <span class="keyword">true</span>);</span><br><span class="line">declarebolt(builder, SPLIT, <span class="keyword">new</span> SplitBolt(), parallelismHint, <span class="keyword">true</span>);</span><br><span class="line">declarebolt(builder, OUTPUT, outputBolt, parallelismHint, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>第一次看到这样的代码，我的内心其实是很纠结的，在对stream-id做了实验之后，参考：<a href="http://zqhxuyuan.github.io/2016/06/30/Hello-Storm/" target="_blank" rel="noopener">http://zqhxuyuan.github.io/2016/06/30/Hello-Storm/</a><br>我终于明白了一个道理：定义这么多Group其实没有关系，实际上真正用到的并不多！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">declarebolt</span><span class="params">(TopologyBuilder builder, String boltName, IRichBolt bolt, <span class="keyword">int</span> parallelism, <span class="keyword">boolean</span> control)</span> </span>&#123;</span><br><span class="line">    BoltDeclarer declarer = builder.setBolt(boltName, bolt, parallelism)</span><br><span class="line">      <span class="comment">//XXXGrouping的两个参数: component-id, stream-id</span></span><br><span class="line">      .allGrouping(FLOW_LOADER_STREAM, FLOW_LOADER_STREAM)</span><br><span class="line">      .allGrouping(<span class="string">"tick"</span>, <span class="string">"tick"</span>)</span><br><span class="line">      .localOrShuffleGrouping(INITIALIZER, boltName)</span><br><span class="line"></span><br><span class="line">      .localOrShuffleGrouping(FILTER, boltName)</span><br><span class="line">      .fieldsGrouping(PARTITION, boltName, <span class="keyword">new</span> Fields(FLOW_ID, PARTITION))    <span class="comment">// guaranteed partitions will always group the same flow for flows that have joins with default partitions.</span></span><br><span class="line">      .localOrShuffleGrouping(AGGREGATE, boltName)</span><br><span class="line">      .localOrShuffleGrouping(SELECT, boltName)</span><br><span class="line">      .localOrShuffleGrouping(EACH, boltName)</span><br><span class="line">      .localOrShuffleGrouping(SORT, boltName)</span><br><span class="line">      .localOrShuffleGrouping(SWITCH, boltName)</span><br><span class="line">      .localOrShuffleGrouping(SPLIT, boltName)</span><br><span class="line">      .localOrShuffleGrouping(JOIN, boltName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以declarebolt(“SELECT”)和declarebolt(“FILTER”)为例（其他Bolt同理）：<br>看起来SelectBolt或者FilterBolt订阅的数据源包括了所有的算子，以及FLOW_LOADER_STREAM，还有tick，当然少不了INITIALIZER！  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BoltDeclarer declarer = builder.setBolt(<span class="string">"SELECT"</span>, <span class="keyword">new</span> SelectBolt(), parallelism)</span><br><span class="line">  .allGrouping(FLOW_LOADER_STREAM, FLOW_LOADER_STREAM)</span><br><span class="line">  .allGrouping(<span class="string">"tick"</span>, <span class="string">"tick"</span>)</span><br><span class="line">  .localOrShuffleGrouping(INITIALIZER, <span class="string">"SELECT"</span>)   <span class="comment">//⬅</span></span><br><span class="line">  .localOrShuffleGrouping(FILTER, <span class="string">"SELECT"</span>)</span><br><span class="line">  .fieldsGrouping(PARTITION, <span class="string">"SELECT"</span>, <span class="keyword">new</span> Fields(FLOW_ID, PARTITION)) </span><br><span class="line">  .localOrShuffleGrouping(AGGREGATE, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SELECT, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(EACH, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SORT, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SWITCH, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SPLIT, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(JOIN, <span class="string">"SELECT"</span>);</span><br><span class="line"></span><br><span class="line">BoltDeclarer declarer = builder.setBolt(<span class="string">"FILTER"</span>, <span class="keyword">new</span> FilterBolt(), parallelism)</span><br><span class="line">  .allGrouping(FLOW_LOADER_STREAM, FLOW_LOADER_STREAM)</span><br><span class="line">  .allGrouping(<span class="string">"tick"</span>, <span class="string">"tick"</span>)</span><br><span class="line">  .localOrShuffleGrouping(INITIALIZER, <span class="string">"FILTER"</span>)    <span class="comment">//⬅</span></span><br><span class="line">  .localOrShuffleGrouping(FILTER, <span class="string">"FILTER"</span>)</span><br><span class="line">  .fieldsGrouping(PARTITION, <span class="string">"FILTER"</span>, <span class="keyword">new</span> Fields(FLOW_ID, PARTITION)) </span><br><span class="line">  .localOrShuffleGrouping(AGGREGATE, <span class="string">"FILTER"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SELECT, <span class="string">"FILTER"</span>)</span><br><span class="line">  .localOrShuffleGrouping(EACH, <span class="string">"FILTER"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SORT, <span class="string">"FILTER"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SWITCH, <span class="string">"FILTER"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SPLIT, <span class="string">"FILTER"</span>)</span><br><span class="line">  .localOrShuffleGrouping(JOIN, <span class="string">"FILTER"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么没有看到EVENT对应的EventSpout呢？注意只有FlowInitBolt才会订阅EventSpout，<br>FlowInitBolt是我们这里构建的Topology的第一个Bolt组件（前面还有三个Spout），<br>其他Bolt都是算子类型的Bolt，是会对事件进行计算的，这些算子Bolt不需要接收原始事件数据！  </p>
</blockquote>
<blockquote>
<p>算子类型的Bolt虽然没有Event，但是比FlowInitBolt多了tick：FlowInitBolt并没有订阅TickSpout！</p>
</blockquote>
<table>
<thead>
<tr>
<th>Bolt类型</th>
<th>订阅的Spout</th>
</tr>
</thead>
<tbody>
<tr>
<td>FlowInitBolt</td>
<td>FlowLoaderSpout,EventSpout</td>
</tr>
<tr>
<td>算子Bolt</td>
<td>FlowLoaderSpout,TickSpout</td>
</tr>
</tbody>
</table>
<h4 id="FlowInitBolt下一个Bolt">FlowInitBolt下一个Bolt</h4><p>因为客户端应用程序自定义Stream的第一个FlowOp是不固定的，你无法强制用户第一个算子就是什么，<br>所以紧接着FlowInitBolt的下一个Bolt为了订阅FlowInitBolt发射出来的不固定的消息流，<br>第二个参数必须能够和FlowInitBolt在emit时的第一个参数是一样的。  </p>
<p>举例用户在一个Flow中定义了两个Stream（或者两个Flow定义不同的Stream等等，都是可以的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FlowBuilder()...</span><br><span class="line">    stream(<span class="string">"stream1"</span>)</span><br><span class="line">        .select().end.().aggregate()....end()</span><br><span class="line">    .endStream()</span><br><span class="line">    .stream(<span class="string">"stream2"</span>)</span><br><span class="line">        .filter().end().aggregate().....end()</span><br><span class="line">    .endStream()</span><br></pre></td></tr></table></figure>
<p>FlowInitBolt作为入口，会将每一条事件发射到每个Stream的第一个FlowOp对应的Bolt<br>（FlowOp仅仅是算子，只有Bolt才可以接收数据并计算），最终发射的消息流和数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collector.emit(<span class="string">"SELECT"</span>, tuple, <span class="keyword">new</span> Values(<span class="string">"flow1"</span>, event, -<span class="number">1</span>, <span class="string">"stream1"</span>, <span class="string">"stream1"</span>)); <span class="comment">//第一个Stream第一个FlowOp是SelectOp</span></span><br><span class="line">collector.emit(<span class="string">"FILTER"</span>, tuple, <span class="keyword">new</span> Values(<span class="string">"flow1"</span>, event, -<span class="number">1</span>, <span class="string">"stream2"</span>, <span class="string">"stream2"</span>)); <span class="comment">//第二个Stream第一个FlowOp是FilterOp</span></span><br></pre></td></tr></table></figure>
<p>虽然现在我们还不知道FlowOp和FlowBolt的对应关系是怎么建立的，比如SelectOp对应SelectBolt，FilterOp对应FilterBolt。<br>但是我们至少相信SelectOp是会服务于SelectBolt的，从名称上来看SelectOp肯定不会对应到FilterBolt或者其他Bolt上的。<br>那么FlowInitBolt发射的stream-id=”SELECT”时，它其实是想要发送给SelectBolt的，同样stream-id=”FILTER”时，它也是想要发送给FilterBolt的。<br>（虽然并不是由发送者/上游组件来决定下游组件，而应该由下游组件主动订阅上游组件，但是上游组件其实心里也是有分寸的，它也不是漫无目的的）。  </p>
<p>SelectBolt为了订阅FlowInitBolt的stream-id=”SELECT”的消息流，FilterBolt为了订阅FlowInitBolt的”FILTER”消息流，需要这么做：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BoltDeclarer declarer = builder.setBolt(<span class="string">"SELECT"</span>, <span class="keyword">new</span> SelectBolt(), parallelism)</span><br><span class="line">    .localOrShuffleGrouping(INITIALIZER, <span class="string">"SELECT"</span>);     <span class="comment">//⬅</span></span><br><span class="line"></span><br><span class="line">BoltDeclarer declarer = builder.setBolt(<span class="string">"FILTER"</span>, <span class="keyword">new</span> FilterBolt(), parallelism)</span><br><span class="line">    .localOrShuffleGrouping(INITIALIZER, <span class="string">"FILTER"</span>);     <span class="comment">//⬅</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他组件也是类似，都要定义以INITIALIZER为component-id，以自己component-id为stream-id作为分组策略的第二个参数。<br>上游组件可以发射多个消息流，下游组件应该有目的地去选择其中（自己感兴趣的）一个消息流！</p>
</blockquote>
<p>另外一种理解方式，我们举例只定义了一个Stream，SelectBolt和FilterBolt都各自订阅了INITIALIZER中不同的消息流。<br>注意：除了订阅源INITIALIZER外，还必须指定消息流！但是FlowInitBolt实际上只发射了一个消息流，所以下面<br>只有SelectBolt才会从FlowInitBolt的SELECT消息流中读取到消息，而FilterBolt因为订阅的是FlowInitBolt的FILTER<br>消息流，但是FlowInitBolt并没有产生FILTER这个消息流（或者说即使存在FILTER消息流，但是这个消息流没有任何数据），<br>所以这里的FilterBolt是不会读取到FlowInitBolt发射的任何消息。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FlowInitBolt只发射了一个消息流，stream-id=SELECT</span></span><br><span class="line">collector.emit(<span class="string">"SELECT"</span>, tuple, <span class="keyword">new</span> Values(<span class="string">"flow1"</span>, event, -<span class="number">1</span>, <span class="string">"stream1"</span>, <span class="string">"stream1"</span>));</span><br><span class="line"></span><br><span class="line">BoltDeclarer declarer = builder.setBolt(<span class="string">"SELECT"</span>, <span class="keyword">new</span> SelectBolt(), parallelism)</span><br><span class="line">    .localOrShuffleGrouping(INITIALIZER, <span class="string">"SELECT"</span>);     <span class="comment">//⬅</span></span><br><span class="line"></span><br><span class="line">BoltDeclarer declarer = builder.setBolt(<span class="string">"FILTER"</span>, <span class="keyword">new</span> FilterBolt(), parallelism)</span><br><span class="line">    .localOrShuffleGrouping(INITIALIZER, <span class="string">"FILTER"</span>);     <span class="comment">//×</span></span><br></pre></td></tr></table></figure>
<p>那么为什么还要这么定义FilterBolt，前面说了，你怎么知道应用程序第一个FlowOp是什么？<br>（FlowInitBolt发射到的stream-id是第一个FlowOp对应的名称）。有可能如果Stream的<br>第一个FlowOp是”Filter”的话，那么下面示例中FilterBolt能收到数据，而SelectBolt就收不到了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FlowInitBolt只发射了一个消息流，stream-id=FILTER</span></span><br><span class="line">collector.emit(<span class="string">"FILTER"</span>, tuple, <span class="keyword">new</span> Values(<span class="string">"flow1"</span>, event, -<span class="number">1</span>, <span class="string">"stream1"</span>, <span class="string">"stream1"</span>));</span><br><span class="line"></span><br><span class="line">BoltDeclarer declarer = builder.setBolt(<span class="string">"SELECT"</span>, <span class="keyword">new</span> SelectBolt(), parallelism)</span><br><span class="line">    .localOrShuffleGrouping(INITIALIZER, <span class="string">"SELECT"</span>);     <span class="comment">//×      </span></span><br><span class="line"></span><br><span class="line">BoltDeclarer declarer = builder.setBolt(<span class="string">"FILTER"</span>, <span class="keyword">new</span> FilterBolt(), parallelism)</span><br><span class="line">    .localOrShuffleGrouping(INITIALIZER, <span class="string">"FILTER"</span>);     <span class="comment">//⬅</span></span><br></pre></td></tr></table></figure>
<p>所以为了构建动态的消息流，最好的办法是事先把所有可能的消息流都定义好，<br>然后在上游组件中通过指定stream-id的方式来保证把消息流发送给下游指定的Bolt组件。比如事先会给所有算子<br>对应的Bolt（SelectBolt、FilterBolt、AggregateBolt、EachBolt等）都订阅了INITIALIZER消息源，<br>第二个参数是当前Bolt对应的名称（SELECT、FILTER、AGGREGATE、EACH）。<br>然后在上游组件中，如果只是想发送给SelectBolt，在emit时，第一个参数stream-id=”SELECT”。<br>如果不想发送给SelectBolt了而是想发送给FilterBolt，在emit时设置第一个参数为”FILTER”。  </p>
<blockquote>
<p>这种做法看起来好像是由上游组件来决定要发送消息给哪个下游组件[方案1]，跟前面我们探讨的让下游组件主动订阅上游组件[约束条件]<br>貌似有点矛盾啊！实际上这种方案并没有违反约束条件，下游组件确实也是有主动订阅上游组件的，只不过每个算子对应的Bolt都订阅了<br>同一个上游组件（比如这里的FlowInitBolt），但是实际上对于一个Stream而言，FlowInitBolt只需要把数据发送给Stream的第一个算子<br>对应的Bolt，其他Bolt虽然都订阅了FlowInitBolt，但是它们实际上不需要/不应该收到FlowInitBolt发射的消息的。  </p>
</blockquote>
<p>所以最好的解决办法是：如果能够在上游组件中只发射一个消息流，那么下游组件只可能有一个Bolt有机会得到这个消息流。<br>这里说的是一个Stream的情况，如果说上游组件要发射到多个Stream，而且每个Stream的第一个FlowOp是不一样的，<br>那么上游组件仍然可能产生多个Stream，当然同一个Stream也只会有第一个Bolt会接收到对应的消息流。  </p>
<blockquote>
<p>以前面的两个Stream为例，SelectBolt会收到第一个Stream的消息，FilterBolt会收到第二个Stream的消息。<br>这里并不会说SelectBolt也会收到第二个Stream的消息，因为第二个Stream发射的是FILTER消息流，<br>而SelecdBolt并没有订阅FlowInitBolt的FILTER消息流（实际上也不应该让SelectdBolt去订阅其他类型的消息流）。  </p>
</blockquote>
<p>collector.emit(“SELECT”, tuple, new Values(“flow1”, event, -1, “stream1”, “stream1”)); //第一个Stream第一个FlowOp是SelectOp<br>collector.emit(“FILTER”, tuple, new Values(“flow1”, event, -1, “stream2”, “stream2”)); //第二个Stream第一个FlowOp是FilterOp  </p>
<blockquote>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709135059685" alt="flowmix7"><br>我感觉自己好啰（能）嗦（说）啊！</p>
</blockquote>
<h4 id="算子Bolt之间的上下游依赖关系">算子Bolt之间的上下游依赖关系</h4><p>回到下游组件定义订阅数据源的地方，除了FlowLoaderSpout，TickSpout，和第一个FlowInitBolt外，还定义了其他算子类型的输入源。  </p>
<p>就像SelectBolt虽然订阅了INITIALIZER-&gt;SELECT消息流，但并不一定会获取到FlowInitBolt发射的消息流，<br>因为如果FlowInitBolt没有发射SELECT消息流的话，SelectBolt就不会真正读取到消息。<br>但是如果不订阅的话，则肯定是有问题的：FlowInitBolt发射的消息流，必须确保会有下游组件接收，否则消息就会丢失。  </p>
<p>所以每个算子类型的Bolt都要订阅其他所有算子的输入源（以SelectBolt为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BoltDeclarer declarer = builder</span><br><span class="line">.setBolt(<span class="string">"SELECT"</span>, <span class="keyword">new</span> SelectBolt(), parallelism)</span><br><span class="line">  .allGrouping(FLOW_LOADER_STREAM, FLOW_LOADER_STREAM)</span><br><span class="line">  .allGrouping(<span class="string">"tick"</span>, <span class="string">"tick"</span>)</span><br><span class="line">  .localOrShuffleGrouping(INITIALIZER, <span class="string">"SELECT"</span>)  </span><br><span class="line">  .localOrShuffleGrouping(FILTER, <span class="string">"SELECT"</span>)</span><br><span class="line">  .fieldsGrouping(PARTITION,<span class="string">"SELECT"</span>,<span class="keyword">new</span> Fields(FLOW_ID,PARTITION)) </span><br><span class="line">  .localOrShuffleGrouping(AGGREGATE, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SELECT, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(EACH, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SORT, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SWITCH, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(SPLIT, <span class="string">"SELECT"</span>)</span><br><span class="line">  .localOrShuffleGrouping(JOIN, <span class="string">"SELECT"</span>);</span><br></pre></td></tr></table></figure>
<p>假设应用程序产生Flow的过程是：filter().select().aggregate().select().filter().each()，<br>Flow的Stream中各个FlowOp的顺序是：List<flowop>(FilterOp, SelectOp, AggregateOp, SelectOp, FilterOp, EachOp)。<br>注意这里允许多次调用同一种类型的FlowOp，而且数组链表也支持相同类型的元素存在。  </flowop></p>
<p>第一个FlowOp=FilterOp，对应的FilterBolt会订阅FlowInitBolt的INITIALIZER-&gt;”FILTER”消息流，<br>其他Bolt虽然也订阅了INITIALIZER输入源，但是由于FlowInitBolt只发射了FILTER，所以它们订阅的INITIALIZER不会有数据进来。  </p>
<p>下面详细分析了Stream中各个FlowOp对应的FlowBolt的分组策略：</p>
<p><strong>filter()</strong>.select().aggregate().select().filter().each()<br><strong>FilterOp</strong>, SelectOp, AggregateOp, SelectOp, FilterOp, EachOp<br><strong>FilterBolt</strong>, SelectBolt, AggregateBolt, SelectBolt, FilterBolt, EachBolt  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155902538" alt="group1"></p>
<p>filter().<strong>select()</strong>.aggregate().select().filter().each()<br>FilterOp, <strong>SelectOp</strong>, AggregateOp, SelectOp, FilterOp, EachOp<br>FilterBolt, <strong>SelectBolt</strong>, AggregateBolt, SelectBolt, FilterBolt, EachBolt  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155918256" alt="group2"></p>
<p>filter().select().<strong>aggregate()</strong>.select().filter().each()<br>FilterOp, SelectOp, <strong>AggregateOp</strong>, SelectOp, FilterOp, EachOp<br>FilterBolt, SelectBolt, <strong>AggregateBolt</strong>, SelectBolt, FilterBolt, EachBolt  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155928663" alt="group3"></p>
<p>filter().select().aggregate().<strong>select()</strong>.filter().each()<br>FilterOp, SelectOp, AggregateOp, <strong>SelectOp</strong>, FilterOp, EachOp<br>FilterBolt, SelectBolt, AggregateBolt, <strong>SelectBolt</strong>, FilterBolt, EachBolt  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155939147" alt="group4"></p>
<p>filter().select().aggregate().select().<strong>filter()</strong>.each()<br>FilterOp, SelectOp, AggregateOp, SelectOp, <strong>FilterOp</strong>, EachOp<br>FilterBolt, SelectBolt, AggregateBolt, SelectBolt, <strong>FilterBolt</strong>, EachBolt  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155949616" alt="group5"></p>
<p>filter().select().aggregate().select().filter().<strong>each()</strong><br>FilterOp, SelectOp, AggregateOp, SelectOp, FilterOp, <strong>EachOp</strong><br>FilterBolt, SelectBolt, AggregateBolt, SelectBolt, FilterBolt, <strong>EachBolt</strong>  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160709155959413" alt="group6"></p>
<blockquote>
<p>现在FlowmixBuilder类基本上分析完毕了，好家伙，这里面水真的不浅啊</p>
</blockquote>
<h2 id="算子Bolt">算子Bolt</h2><p>再来思考下FlowInitBolt需要EventSpout而不需要TickSpout，而算子Bolt需要TickSpout不需要EventSpout的原因。  </p>
<table>
<thead>
<tr>
<th>Bolt类型</th>
<th>订阅的Spout</th>
<th>订阅的Bolt</th>
</tr>
</thead>
<tbody>
<tr>
<td>FlowInitBolt</td>
<td>FlowLoaderSpout,EventSpout</td>
<td>null</td>
</tr>
<tr>
<td>算子Bolt</td>
<td>FlowLoaderSpout,TickSpout</td>
<td>上游Bolt</td>
</tr>
</tbody>
</table>
<p>EventSpout产生的事件只需要流入FlowInitBolt即可，后续FlowInitBolt下发给Stream的第一个Bolt，<br>并且按照Stream中FlowOp的顺序依次将每个Bolt中计算好的数据下发给下游的Bolt。<br>所以Stream中的Bolt并不直接解除原始EventSpout发射的事件。  </p>
<blockquote>
<p>如果EventSpout要发射事件给Stream中的Bolt，那么它就要跟FlowInitBolt那样，选择一个确定的stream-id，<br>并且也只发送事件给Stream中第一个Bolt：FlowInitBolt就是这么干的。<br>抽取出初始化Bolt的主要目的就是统一把事件发射到这里，<br>然后再由FlowInitBolt决定要把收到的事件转发给下游Stream的第一个Bolt。   </p>
</blockquote>
<blockquote>
<p>所以说FlowInitBolt是EventSpout和Stream第一个Bolt的中间介质。如果不使用FlowInitBolt，<br>而让EventSpout直接发射事件给Stream的第一个Bolt，可以想想会有什么问题的。<br>答案：EventSpout并不是把事件发射给Stream所有的Bolt，那么它就要知道Stream中第一个Bolt的stream-id是什么，<br>但是EventSpout本身是数据源，不会接收其他消息，就没办法知道Stream到底长什么样。<br>使用FlowInitBolt，它不仅可以接收FlowLoaderSpout发射的flows：这里包含Stream的List<flowop>信息，<br>同时还会收到EventSpout发射的数据，FlowInitBolt会首先计算出Stream的第一个FlowOp的stream-id，<br>然后把从EventSpout收到的事件原封不动地发射到这个stream-id上。<br>关键是EventSpout和Stream第一个FlowOp中间必须有flows数据，才能让EventSpout决定目标stream-id。<br>当然你可以像构造FlowLoaderSpout那样，把客户端应用程序创建的flows也传递给EventSpout，<br>这样就可以把FlowInitBolt去掉了，不过通常我们不希望EventSpout和flows绑定的太紧。  </flowop></p>
</blockquote>
<p>算子Bolt和FlowInitBolt（这两种类型的Bolt是FlowmixBuilder中Topology的所有Bolt，再没有其他的Bolt了）都<br>需要接收FlowLoaderSpout发射的flows，而且算子Bolt还会接收TickSpout发射的tick tock tick tock空/心跳消息。  </p>
<h3 id="SelectBolt">SelectBolt</h3><p>同FlowInitBolt一样，SelectBolt也会接收FlowLoaderSpout发射的FLOW_LOADER_STREAM消息流（其他Bolt也都会），<br>必须确保先接收FlowLoaderSpout的消息，处理方式是使用一个Map来保存flows，key是Flow的ID，value是Flow对象。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Flow&gt; flows;</span><br><span class="line">    OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collector = outputCollector;</span><br><span class="line">        flows = <span class="keyword">new</span> HashMap&lt;String, Flow&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(FLOW_LOADER_STREAM.equals(tuple.getSourceStreamId())) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Flow flow : (Collection&lt;Flow&gt;)tuple.getValue(<span class="number">0</span>))</span><br><span class="line">                flows.put(flow.getId(), flow);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="string">"tick"</span>.equals(tuple.getSourceStreamId())) &#123;</span><br><span class="line">            FlowInfo flowInfo = <span class="keyword">new</span> FlowInfo(tuple);</span><br><span class="line">            Flow flow = flows.get(flowInfo.getFlowId());</span><br><span class="line">            <span class="keyword">if</span> (flow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//....</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        FlowmixBuilder.declareOutputStreams(outputFieldsDeclarer, fields);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SelectBolt以及其他算子类型的Bolt和FlowInitBolt的declareOutputFields方法都是一样的，定义了所有的输出stream。</p>
</blockquote>
<p>上面我们说过算子Bolt是有接收TickSpout的，但是SelectBolt的execute方法中看起来并不想处理TickSpout消息流。<br>其实算子Bolt除了接收FlowLoaderSpout和TickSpout外，还有一种情况是接收上游Bolt经过处理后的消息流。<br>假设SelectBolt是紧接着FlowInitBolt的下游Bolt，那么它也会接收FlowInitBolt发射的事件。<br>（FlowInitBolt的事件其实来自于EventSpout，它并没有对事件做处理，而是起到转发的作用）。  </p>
<p>同样在SelectBolt之后假设是FilterBolt，那么FilterBolt接收的数据源有三个：<br>FlowLoaderSpout发射的flows，TickSpout发射的心跳，SelectBolt处理过的消息流。  </p>
<blockquote>
<p>为什么SelectBolt不处理TickSpout呢？实际上Tick的目的是定时器，而Select算子并不需要定时！</p>
</blockquote>
<p>FlowInitBolt原封不动地发射event给Stream的第一个FlowOp，它的Values是经过设计的，最主要的是第二个和第三个参数：<br>第二个参数表示要发射的数据，第三个参数表示当前Bolt在Stream的FlowOp数组链表对应的索引位置，这个索引位置从-1开始，<br>每次经过一个Bolt的处理，index值就加1。FlowOp对应的Bolt都处理完了，index也到了数组链表的最后一个位置。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String streamid = stream.getFlowOps().get(<span class="number">0</span>).getComponentName();</span><br><span class="line">collector.emit(streamid, tuple, <span class="keyword">new</span> Values(flow.getId(), event, -<span class="number">1</span>, streamName, streamName));</span><br></pre></td></tr></table></figure>
<p>假设FlowInitBolt的下一个Bolt是SelectBolt（其他Bolt也是类似的），tuple就是上面FlowInitBolt发射的Values整个数据。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FlowInfo flowInfo = <span class="keyword">new</span> FlowInfo(tuple);</span><br><span class="line">Flow flow = flows.get(flowInfo.getFlowId());</span><br><span class="line">SelectOp selectOp = getFlowOpFromStream(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br></pre></td></tr></table></figure>
<p>Bolt接收的每个Tuple都会被封装为FlowInfo：除了事件数据外，还有其他和Flow相关的元数据：flowId，streamName这些就不用说了。<br><code>previousStream</code>主要用于多个Stream之间的合并操作比如join等，如果多个Stream没有关联关系，通常previousStream=streamName。<br><code>partition</code>这个字段用于聚合，比如前面Bolt的分组策略fieldsGrouping就会使用PARTITION。<br><code>idx</code>这个变量决定了当前Bolt接收到Tuple后，如何从Steram的List<flowop>中获取出对应位置的FlowOp。  </flowop></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlowInfo</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">  flowId = tuple.getStringByField(FLOW_ID);</span><br><span class="line">  event = (Event) tuple.getValueByField(EVENT);</span><br><span class="line">  idx = tuple.getIntegerByField(FLOW_OP_IDX);</span><br><span class="line">  idx++;</span><br><span class="line">  streamName = tuple.getStringByField(STREAM_NAME);</span><br><span class="line">  previousStream = tuple.getStringByField(LAST_STREAM);</span><br><span class="line">  <span class="keyword">if</span>(tuple.contains(PARTITION)) partition = tuple.getStringByField(PARTITION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以SelectBolt为例，它收到的FlowInitBolt发射的index=-1，所以它对-1+1=0，得到的index=0。<br><code>getFlowOpFromStream</code>方法根据传入的idx参数值=0，从Stream的List<flowop>得到的FlowOp=SelectOp!<br>因为我们前面假设了SelectBolt就是紧接着FlowInitBolt后面的Bolt，所以SelectBolt得到的一定是SelectOp!  </flowop></p>
<p>会不会说假设ArrayList<flowop>=[FilterOp,SelectOp,EachOp,FilterOp…]而导致SelectBolt选择出了FilterOp?<br>不会出现这种情况的！因为FlowInitBolt和其他所有Bolt使用的ArrayList<flowop>都是一致的数据结构。<br>如果Stream的ArrayList<flowop>真如上面的，那么FlowInitBolt发送的stream-id=Stream的第一个FlowOp=”FILTER”<br>这样只会有FilterBolt能够收到这个消息流，也就是说FlowInitBolt的下一个Bolt是FilterBolt，<br>那么FilterBolt得到的index=0后，从List<flowop>数组链表取得的FlowOp还是FilterOp！  </flowop></flowop></flowop></flowop></p>
<table>
<thead>
<tr>
<th>ArrayList<flowop></flowop></th>
<th>FlowInitBolt.emit(stream-id)</th>
<th>next bolt</th>
<th>index</th>
<th>getFlowOpFromStream</th>
</tr>
</thead>
<tbody>
<tr>
<td>SelectOp,FilterOp,EachOp</td>
<td>SELECT</td>
<td>SelectBolt</td>
<td>0</td>
<td>SelectOp</td>
</tr>
<tr>
<td>FilterOp,SelectOp,EachOp</td>
<td>FILTER</td>
<td>FilterBolt</td>
<td>0</td>
<td>FilterOp</td>
</tr>
<tr>
<td>EachOp,SelectOp,FilterOp</td>
<td>EACH</td>
<td>EachBolt</td>
<td>0</td>
<td>EachOp</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Flow的Stream的第idx个FlowOp</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends FlowOp&gt; <span class="function">T <span class="title">getFlowOpFromStream</span><span class="params">(Flow flow, String stream, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) flow.getStream(stream).getFlowOps().get(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Flow的Stream的FlowOps集合的下一个FlowOp. 因为组成Stream的flowOps是有序的,即根据定义顺序依次加入</span></span><br><span class="line"><span class="comment">//假设FlowOpsSize=5,idx从0开始.0,1,2,3.第四个(idx=3)的nextStream为最后一个(idx=4)Op的name.</span></span><br><span class="line"><span class="comment">//当处理的是最后一个时,idx+1=5 !&lt; 5,所以最后一个FlowOp的nextStream=OUTPUT.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNextStreamFromFlowInfo</span><span class="params">(Flow flow, String streamName, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> idx + <span class="number">1</span> &lt; flow.getStreamFlowOpsSize(streamName) ?</span><br><span class="line">            <span class="comment">//如果当前FlowOp在Stream中还有下一个FlowOp,则nextStream为下一个FlowOp的name.</span></span><br><span class="line">            <span class="comment">//如果当前FlowOp在Stream中是最后一个FlowOp,则nextStream=OUTPUT</span></span><br><span class="line">            flow.getFlowOp(streamName,idx+<span class="number">1</span>).getComponentName() : OUTPUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像FlowInitBolt发射事件时，要指定stream-id，从而将事件转交给下一个Bolt处理。假设当前Bolt是SelectBolt，<br>它也要将自己处理过的事件发射给下游Bolt，也要指定下游Bolt的stream-id，同样这个信息要从List<flowop>获取。  </flowop></p>
<p>FlowInitBolt发射的stream-id是List<flowop>的第一个FlowOp的名称，SelectBolt则要找第二个FlowOp的名称。<br>因为SelectBolt是List<flowop>中的第一个FlowOp！当然由于实际应用中SelectBolt不一定是第一个FlowOp，所以<br>我们应该使用动态的方式。因为接收上游发射的Tuple的index时，加上1为当前的FlowOp的索引位置，即FlowInfo的idx，<br>那么在当前FlowInfo.idx再加上1，就是当前FlowOp的下一个FlowOp–&gt;作为当前Bolt发射时的stream-id。Perfect！！！  </flowop></flowop></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FlowInfo flowInfo = <span class="keyword">new</span> FlowInfo(tuple);</span><br><span class="line">Flow flow = flows.get(flowInfo.getFlowId());</span><br><span class="line"><span class="keyword">if</span> (flow != <span class="keyword">null</span>) &#123;</span><br><span class="line">    SelectOp selectOp =  getFlowOpFromStream(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line">    String nextStream = Utils.getNextStreamFromFlowInfo(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//映射操作会对事件产生影响,只有包含对应字段的事件,才会进入下一轮</span></span><br><span class="line">    Event newEvent = <span class="keyword">new</span> BaseEvent(flowInfo.getEvent().getId(), flowInfo.getEvent().getTimestamp());</span><br><span class="line">    <span class="comment">//Event中的tuples类似于一个Map.</span></span><br><span class="line">    <span class="keyword">for</span>(org.calrissian.mango.domain.Tuple eventTuple : flowInfo.getEvent().getTuples()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(selectOp.getFields().contains(eventTuple.getKey()))</span><br><span class="line">          newEvent.put(eventTuple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If no selected tuples existed, event will not be emitted</span></span><br><span class="line">    <span class="keyword">if</span>(hasNextOutput(flow, flowInfo.getStreamName(), nextStream)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newEvent.getTuples().size() &gt; <span class="number">0</span>)</span><br><span class="line">        collector.emit(nextStream, tuple, <span class="keyword">new</span> Values(flowInfo.getFlowId(), newEvent, flowInfo.getIdx(), flowInfo.getStreamName(), flowInfo.getPreviousStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send directly to any non std output streams</span></span><br><span class="line">    <span class="keyword">if</span>(exportsToOtherStreams(flow, flowInfo.getStreamName(), nextStream)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String output : flow.getStream(flowInfo.getStreamName()).getOutputs()) &#123;</span><br><span class="line">        String outputStream = flow.getStream(output).getFlowOps().get(<span class="number">0</span>).getComponentName();</span><br><span class="line">        collector.emit(outputStream, tuple, <span class="keyword">new</span> Values(flowInfo.getFlowId(), flowInfo.getEvent(), -<span class="number">1</span>, output, flowInfo.getStreamName()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>exportsToOtherStreams这部分逻辑是多个流的处理，暂时放在一边</p>
</blockquote>
<p>假设ArrayList<flowop>=[SelectOp,FilterOp,EachOp,SelectOp,FilterOp]，那么各个Bolt的emit(stream-id)如下：</flowop></p>
<table>
<thead>
<tr>
<th>Bolt</th>
<th>FlowInfo(idx)</th>
<th>FlowOp</th>
<th>idx+1</th>
<th>nextStream id</th>
<th>new Values(event, flowInfo.idx)</th>
</tr>
</thead>
<tbody>
<tr>
<td>FlowInitBolt</td>
<td></td>
<td></td>
<td></td>
<td>SELECT</td>
<td>new Values(event,<strong>-1</strong>)</td>
</tr>
<tr>
<td>SelectBolt</td>
<td><strong>-1+1=0</strong></td>
<td>SelectOp</td>
<td><code>0+1=1</code></td>
<td><code>FILTER</code></td>
<td>new Values(event1,<strong>0</strong>)</td>
</tr>
<tr>
<td>FilterBolt</td>
<td>0+1=1</td>
<td>FilterOp</td>
<td>1+1=2</td>
<td>EACH</td>
<td>new Values(event2,1)</td>
</tr>
<tr>
<td>EachBolt</td>
<td>1+1=2</td>
<td>EachOp</td>
<td>2+1=3</td>
<td>SELECT</td>
<td>new Values(event3,2)</td>
</tr>
<tr>
<td>SelectBolt</td>
<td>2+1=3</td>
<td>SelectOp</td>
<td>3+1=4</td>
<td>FILTER</td>
<td>new Values(event4,3)</td>
</tr>
<tr>
<td>FilterBolt</td>
<td>3+1=4</td>
<td></td>
<td></td>
<td>OUTPUT</td>
<td>new Values(event5,4)</td>
</tr>
</tbody>
</table>
<p>这里主要流程如下：  </p>
<ol>
<li>收到上游组件的Tuple，构造FlowInfo，其中idx为上游组件的idx+1</li>
<li>getFlowOpFromStream获取indx对应的FlowOp，通常Bolt和FlowOp的算子类型是对应的</li>
<li>nextStream=getNextStreamFromFlowInfo</li>
<li>根据当前Bolt特有的计算逻辑，对收到的Event数据进行计算，并生成最新的事件数据Event’</li>
<li>emit(nextStream, new Values(Event’, FlowInfo.idx))</li>
</ol>
<p>按照这样的处理流程，基本的处理框架如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FlowInfo flowInfo = <span class="keyword">new</span> FlowInfo(tuple);</span><br><span class="line">Flow flow = flows.get(flowInfo.getFlowId());</span><br><span class="line"><span class="keyword">if</span>(flow != <span class="keyword">null</span>) &#123;</span><br><span class="line">    FlowOp myFlowOp = getFlowOpFromStream(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line">    String nextStream = Utils.getNextStreamFromFlowInfo(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line">    Event newEvent = processEvent(flowInfo.getEvent());</span><br><span class="line">    collector.emit(nextStream, tuple, <span class="keyword">new</span> Values(flowInfo.getFlowId(), newEvent, flowInfo.getIdx(), flowInfo.getStreamName(), flowInfo.getPreviousStream()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160132603" alt="flowmix13"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160144803" alt="flowmix14"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160154912" alt="flowmix15"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160204697" alt="flowmix16"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160215494" alt="flowmix17"></p>
<p>那么看接下来几种类型的Bolt就非常简单了（不同的是processEvent这部分逻辑）：  </p>
<ol>
<li>SelectBolt：只从事件中获取出指定的Fields字段，假设Event有[key1,key2,key3]三个字段，<br>而SelectOp只配置了key1，那么这条事件最后只有key1这一个字段</li>
<li>FilterBolt：假设Filter的accept方法是：equals(“key1”)，那么最后也只有key1一个字段</li>
<li>EachBolt类似于scala的map函数</li>
</ol>
<blockquote>
<p>问题：如果一个Stream中有相同的FlowOp，会有什么问题吗？比如.select().aggregate().select().aggregate()。<br><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713160854993" alt="flowmix-same-flowop"></p>
</blockquote>
<h3 id="FilterBolt">FilterBolt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FilterOp filterOp = getFlowOpFromStream(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line"></span><br><span class="line"><span class="comment">//将事件运用到Flow的FilterOp上,验证事件是否符合过滤器.</span></span><br><span class="line"><span class="keyword">if</span>(filterOp.getFilter().accept(flowInfo.getEvent())) &#123;</span><br><span class="line">  <span class="comment">//下一个FlowOp的stream-id</span></span><br><span class="line">  String nextStream = getNextStreamFromFlowInfo(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//还有下一个Component,则继续将自己处理完的tuple发射给下一个Component(Bolt)</span></span><br><span class="line">  <span class="keyword">if</span>(hasNextOutput(flow, flowInfo.getStreamName(), nextStream))</span><br><span class="line">    <span class="comment">//和InitBolt发射的Values一样,是构造FlowInfo的所有字段.</span></span><br><span class="line">    collector.emit(nextStream, tuple, <span class="keyword">new</span> Values(flow.getId(), flowInfo.getEvent(), flowInfo.getIdx(), flowInfo.getStreamName(), flowInfo.getPreviousStream()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EachBolt">EachBolt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EachOp functionOp =  getFlowOpFromStream(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line">String nextStream = getNextStreamFromFlowInfo(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function可以看做是map操作,将事件转换为新的事件</span></span><br><span class="line">List&lt;Event&gt; events = functionOp.getFunction().execute(flowInfo.getEvent());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hasNextOutput(flow, flowInfo.getStreamName(), nextStream)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (events != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Event newEvent : events)</span><br><span class="line">      collector.emit(nextStream, tuple, <span class="keyword">new</span> Values(flowInfo.getFlowId(), newEvent, flowInfo.getIdx(), flowInfo.getStreamName(), flowInfo.getPreviousStream()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PartitionBolt">PartitionBolt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PartitionOp partitionOp = getFlowOpFromStream(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line">String nextStream = Utils.getNextStreamFromFlowInfo(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line"></span><br><span class="line"><span class="comment">//Partition和Select一样,定义了一些字段,表示group by的字段</span></span><br><span class="line">String hash = buildKeyIndexForEvent(flowInfo.getFlowId(), flowInfo.getEvent(), partitionOp.getFields());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hasNextOutput(flow, flowInfo.getStreamName(), nextStream))</span><br><span class="line">  collector.emit(nextStream, tuple, <span class="keyword">new</span> Values(flowInfo.getFlowId(), flowInfo.getEvent(), flowInfo.getIdx(), flowInfo.getStreamName(), hash, flowInfo.getPreviousStream()));</span><br></pre></td></tr></table></figure>
<p>PartitionBolt的declareOutputFields partitionFields比普通的fields多了一个PARTITION字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">    declareOutputStreams(outputFieldsDeclarer, partitionFields);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Fields partitionFields = <span class="keyword">new</span> Fields(FLOW_ID, EVENT, FLOW_OP_IDX, STREAM_NAME, PARTITION, LAST_STREAM);</span><br></pre></td></tr></table></figure>
<p>FlowmixBuilder中订阅了PARTITION数据源的分组策略定义（以SelectBolt为例，其他Bolt同理）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bolt.setBolt(<span class="string">"SELECT"</span>, <span class="keyword">new</span> SelectBolt())</span><br><span class="line">    .fieldsGrouping(PARTITION, <span class="string">"SELECT"</span>, <span class="keyword">new</span> Fields(FLOW_ID,PARTITION));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的示例中，Topology拓扑图是：PartitionBolt跟着SelectBolt，因为SelectBolt订阅了PartitionBolt数据源，<br>比如客户端应用程序的调用顺序是：stream(“stream1”).partition().select()…<br>而且PartitionBolt发射的stream-id=”SELECT”，PartitionBolt不会发射其他stream-id（否则下一个Bolt就不是SelectBolt）！  </p>
</blockquote>
<p>PartitionOp和SelectOp类似，可以指定多个fields字段，SelectOp表示的是选择这几个字段作为事件的输出字段，<br>PartitionOp表示根据这几个字段进行分区/分组。  </p>
<table>
<thead>
<tr>
<th>fields…</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>stream(“stream1”).select().fields(“key1”, “key2”)</td>
<td>select key1, key2 from stream1</td>
</tr>
<tr>
<td>stream(“stream1”).partition().fields(“key1”, “key2”)</td>
<td>select * from stream1 group by key1,key2</td>
</tr>
</tbody>
</table>
<p>buildKeyIndexForEvent从一条事件中根据groupBy字段构建keyIndex，最后会作为发射时的hash即<strong>Fields的PARTITION字段</strong>。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildKeyIndexForEvent</span><span class="params">(Event event, List&lt;String&gt; groupBy)</span> </span>&#123;</span><br><span class="line">    StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">if</span> (groupBy == <span class="keyword">null</span> || groupBy.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> stringBuffer.toString();  <span class="comment">// default partition when no groupBy fields are specified.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//groupBy可以定义多个字段.</span></span><br><span class="line">    <span class="keyword">for</span> (String groupField : groupBy) &#123;</span><br><span class="line">        <span class="comment">//一条事件Event可以有多个Tuples.</span></span><br><span class="line">        Collection&lt;Tuple&gt; tuples = event.getAll(groupField); <span class="comment">//一个字段也允许多个Tuple!</span></span><br><span class="line">        SortedSet&lt;String&gt; values = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tuples == <span class="keyword">null</span>) &#123;</span><br><span class="line">            values.add(<span class="string">""</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple tuple : tuples)</span><br><span class="line">                values.add(registry.encode(tuple.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuffer.append(groupField + join(values, <span class="string">""</span>) + <span class="string">"|"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flowId|groupField1.xxxxx|groupField2.yyyyy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildKeyIndexForEvent</span><span class="params">(String flowId, Event event, List&lt;String&gt; groupBy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flowId + buildKeyIndexForEvent(event, groupBy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Event">Event</h3><p>通常每一条事件至少在某个字段上要保证唯一性，单单用时间撮是无法保证唯一性的，因为有可能在同一个时刻会产生多条事件。<br>如果业务意义上需要隔离的两条事件，因为时间撮相同而放在同一个Event中显然是有问题的！比下面的两条事件：  </p>
<p>事件1：[时间撮：1468220424，合作方：A，事件：登陆，账户：张三，IP：192.168.0.1，设备：AAAAAA]<br>事件2：[时间撮：1468220424，合作方：B，事件：付款，账户：张三，IP：192.168.0.1，设备：AAAAAA]  </p>
<p>虽然这两条事件的账户、IP、设备信息都是一样的，但是因为合作方不同，事件也不同，不能看做是同一条事件！<br>通常业务系统会自己设计一个全局唯一的序号（不管用哪种方式实现都要保证不同事件有不同的序号），比如sequence_id：  </p>
<p>事件1：[sequence_id: 1468220424001，时间撮：1468220424，合作方：A，事件：登陆，账户：张三，IP：192.168.0.1，设备：AAAAAA]<br>事件2：[sequence_id: 1468220424002，时间撮：1468220424，合作方：B，事件：付款，账户：张三，IP：192.168.0.1，设备：AAAAAA]  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Event&gt; <span class="title">getMockEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;Event&gt; eventCollection = <span class="keyword">new</span> ArrayList&lt;Event&gt;();</span><br><span class="line">    <span class="comment">//创建一条事件,只有UUID和时间撮</span></span><br><span class="line">    Event event = <span class="keyword">new</span> BaseEvent(UUID.randomUUID().toString(), System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往事件中填充信息. Key-Value键值对, event看起来像Map. 或者如果用JSON表示:</span></span><br><span class="line">    <span class="comment">//&#123;id:f171edb8-a393-4eaf-bbc0-8fece8f1a22b, timestamp:1441637681000, &#123;key1:val1, key2:val2, key3:val3&#125;&#125;</span></span><br><span class="line">    event.put(<span class="keyword">new</span> Tuple(<span class="string">"key1"</span>, <span class="string">"val1"</span>));</span><br><span class="line">    event.put(<span class="keyword">new</span> Tuple(<span class="string">"key2"</span>, <span class="string">"val2"</span>));</span><br><span class="line">    event.put(<span class="keyword">new</span> Tuple(<span class="string">"key3"</span>, <span class="string">"val3"</span>));</span><br><span class="line">    event.put(<span class="keyword">new</span> Tuple(<span class="string">"key4"</span>, <span class="string">"val4"</span>));</span><br><span class="line">    event.put(<span class="keyword">new</span> Tuple(<span class="string">"key5"</span>, <span class="string">"val5"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在一条事件中相同key有不同的value.而我们实际要的效果可能是在不同的event中相同key有不同value.用上面的方式模拟.</span></span><br><span class="line">    <span class="comment">//注意key1的值没有变化.而key3的值变化. 表示key1这个ip=val1,在不同的事件中,它的账户(key3)分别是val3和val-3</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    event.put(new Tuple("key1", "val1"));</span></span><br><span class="line"><span class="comment">    event.put(new Tuple("key3", "val-3"));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    eventCollection.add(event);</span><br><span class="line">    <span class="keyword">return</span> eventCollection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面举例了多种模拟事件：  </p>
<pre><code>//事件序号=<span class="number">1</span>，登陆事件，用户：张三，IP：<span class="number">192.168</span>.<span class="number">0.1</span>，设备：AAAAAAAA
event1.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"sequence_id"</span>, <span class="string">"1"</span>));
event1.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"type"</span>, <span class="string">"login"</span>));
event1.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"ip"</span>, <span class="string">"192.168.0.1"</span>));
event1.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"account"</span>, <span class="string">"张三"</span>));
event1.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"device"</span>, <span class="string">"AAAAAAAA"</span>));

//事件序号=<span class="number">2</span>，登陆事件，用户：李四，IP：<span class="number">192.168</span>.<span class="number">0.1</span>，设备：AAAAAAAA
event2.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"sequence_id"</span>, <span class="string">"2"</span>));
event2.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"type"</span>, <span class="string">"login"</span>));
event2.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"ip"</span>, <span class="string">"192.168.0.1"</span>));
event2.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"account"</span>, <span class="string">"李四"</span>));
event2.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"device"</span>, <span class="string">"AAAAAAAA"</span>));

//事件序号=<span class="number">3</span>，登陆事件，用户：张三，IP：<span class="number">192.168</span>.<span class="number">0.1</span>，设备：AAAAAAAA
event3.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"sequence_id"</span>, <span class="string">"3"</span>));
event3.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"type"</span>, <span class="string">"login"</span>));
event3.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"ip"</span>, <span class="string">"192.168.0.1"</span>));
event3.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"account"</span>, <span class="string">"张三"</span>));
event3.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"device"</span>, <span class="string">"AAAAAAAA"</span>));    

//事件序号=<span class="number">4</span>，登陆事件，用户：李四，IP：<span class="number">192.168</span>.<span class="number">0.1</span>，设备：BBBBBBBB
event4.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"sequence_id"</span>, <span class="string">"4"</span>));
event4.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"type"</span>, <span class="string">"login"</span>));
event4.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"ip"</span>, <span class="string">"192.168.0.1"</span>));
event4.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"account"</span>, <span class="string">"李四"</span>));
event4.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"device"</span>, <span class="string">"BBBBBBBB"</span>)); 

//事件序号=<span class="number">5</span>，登陆事件，用户：李四，IP：<span class="number">192.168</span>.<span class="number">0.2</span>，设备：BBBBBBBB
event5.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"sequence_id"</span>, <span class="string">"5"</span>));
event5.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"type"</span>, <span class="string">"login"</span>));
event5.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"ip"</span>, <span class="string">"192.168.0.2"</span>));
event5.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"account"</span>, <span class="string">"李四"</span>));
event5.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"device"</span>, <span class="string">"BBBBBBBB"</span>)); 

//事件序号=<span class="number">6</span>，登陆事件，用户：张三/李四，IP：<span class="number">192.168</span>.<span class="number">0.2</span>，设备：BBBBBBBB（同一台设备在一个IP地址上同时登陆两个账户）
event6.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"sequence_id"</span>, <span class="string">"6"</span>));
event6.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"type"</span>, <span class="string">"login"</span>));
event6.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"ip"</span>, <span class="string">"192.168.0.2"</span>));
event6.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"account"</span>, <span class="string">"张三"</span>));
event6.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"account"</span>, <span class="string">"李四"</span>));    
event6.<span class="keyword">put</span>(<span class="keyword">new</span> Tuple(<span class="string">"device"</span>, <span class="string">"BBBBBBBB"</span>)); 
</code></pre><p>注意到事件6的不同，如果按照业务逻辑可能并不符合实际情况，但是Event支持这种在同一个事件里允许存在<strong>相同key不同value</strong>的场景。  </p>
<h3 id="AggregatorBolt">AggregatorBolt</h3><p>聚合算子和前面的SelectBolt，FilterBolt，EachBolt只处理一个事件不同的是，聚合算子要<strong>聚合多个事件</strong>。<br>同时还要<strong>处理TickSpout发射的心跳</strong>，普通的Bolt虽然也配置了TickSpout输入源，但是并没有处理心跳！  </p>
<p>除此之外，还有一个不同点是双层Map变量：windows，第二层的Cache实际上也是一个Map。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregatorBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Flow&gt; flows;</span><br><span class="line">    OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚合比其他Bolt多了个聚合窗口. key=flowId.streamName.aggFlowOpsIndex. Cache.key=hash partition</span></span><br><span class="line">    Map&lt;String, Cache&lt;String, AggregatorWindow&gt;&gt; windows;</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">""</span>, Locale.SIMPLIFIED_CHINESE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collector = outputCollector;</span><br><span class="line">        flows = <span class="keyword">new</span> HashMap&lt;String, Flow&gt;();</span><br><span class="line">        windows = <span class="keyword">new</span> HashMap&lt;String, Cache&lt;String, AggregatorWindow&gt;&gt;();</span><br><span class="line">        sdf.applyPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(FLOW_LOADER_STREAM.equals(tuple.getSourceStreamId())) &#123; <span class="comment">//FlowLoaderSpout发射的flows</span></span><br><span class="line">            <span class="keyword">for</span>(Flow flow : (Collection&lt;Flow&gt;)tuple.getValue(<span class="number">0</span>))</span><br><span class="line">                flows.put(flow.getId(), flow);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"tick"</span>.equals(tuple.getSourceStreamId())) &#123; <span class="comment">//TickSpout发射的心跳事件</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="string">"tick"</span>.equals(tuple.getSourceStreamId()))&#123; <span class="comment">//上游Bolt发射的事件</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：AggregatorBolt一定要有window吗？window表示窗口，如果我只想要单纯的聚合，不想要窗口的功能呢？  </p>
</blockquote>
<h4 id="处理Event事件">处理Event事件</h4><p>处理Event事件时，Event一定来自于上游组件发射的tuple，根据tuple的idx，+1后，从Stream中获取的当前FlowOp=AggregateOp。  </p>
<blockquote>
<p>假设Stream=[SelectOp,FilterOp,AggregateOp]，Topology拓扑图的构建过程如下：<br><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160712170412780" alt="flowmix8"></p>
</blockquote>
<p>由于AggregateBolt的主要目的是要聚合Event，所以它不像普通的SelectBolt/FilterBolt收到输入tuple后经过计算后直接发射出去。<br>它会使用windows对事件进行暂存，windows的key是：flowId|streamName|flowOpIndex。最后的flowOpIndex表示当前FlowOp的索引位置。  </p>
<blockquote>
<p>在一个确定的AggregateBolt中，idx是确定的，那么windows的key只可能有一个元素！<br>Stream可以有不止一个AggregateOp，比如[SelectOp,AggregateOp,FilterOp,AggregateOp]存在两个AggregateOp。<br>对应的Bolt分别是：[SelectBolt,AggregateBolt,FilterBolt,AggregateBolt]。<br>思考问题：假设当前AggregateBolt是第二个，为什么windows还需要flowInfo.getIdx来区分呢？  </p>
</blockquote>
<p>windows的数据结构如下（构造这个双层Map的数据都来自于FlowInfo，FlowInfo又都是来自于上游的Tuple）：</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713073820989" alt="flowmix-windows map"></p>
<p>针对双层Map，往里面放入数据时，必须确保每一层的Map不为空，由于内层的value也是一个对象：AggregateWindow，所以要<br>保证windows.get(idx)得到的windowCache，以及windowCache.get(partiton)得到的AggregatorWindow都不能为空<br>时才能最终将事件（tuple-&gt;FlowInfo-&gt;getEvent）放入AggregatorWindow中（AggregatorWindow才是Event的最终归宿）。  </p>
<ol>
<li>AggregatorWindow.add(Event)</li>
<li>windowCache.put(Partition, AggregatorWindow)</li>
<li>windows.put(flow-stream-idx, windowCache)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在tick spout每秒都会发射tick tuple时.其他Bolt结合事件会发射到这里.在没有达到触发条件时,Aggregate负责收集事件到窗口内.在满足触发条件时,统计窗口内收集到的所有事件.</span></span><br><span class="line">FlowInfo flowInfo = <span class="keyword">new</span> FlowInfo(tuple);</span><br><span class="line"><span class="comment">//如果select一个字段,则打印出的都是1,说明调用一次execute,只有一条事件进来.尽管一秒钟(tick中)会有很多条事件.</span></span><br><span class="line"><span class="comment">//如果select了多个字段,则一个event因为有多个Tuple,size!=1</span></span><br><span class="line"><span class="comment">//System.out.println("events:" + flowInfo.getEvent().getTuples().size());</span></span><br><span class="line"><span class="comment">//System.out.println("events:" + flowInfo.getEvent());</span></span><br><span class="line">Flow flow = flows.get(flowInfo.getFlowId());</span><br><span class="line"><span class="keyword">if</span>(flow != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AggregateOp op = getFlowOpFromStream(flow, flowInfo.getStreamName(), flowInfo.getIdx());</span><br><span class="line">    Cache&lt;String, AggregatorWindow&gt; windowCache = windows.get(flowInfo.getFlowId() + <span class="string">"\0"</span> + flowInfo.getStreamName() + <span class="string">"\0"</span> + flowInfo.getIdx());</span><br><span class="line"></span><br><span class="line">    AggregatorWindow window = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(windowCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        window = windowCache.getIfPresent(flowInfo.getPartition());</span><br><span class="line">        <span class="comment">// if we have a window already constructed, proces it</span></span><br><span class="line">        <span class="keyword">if</span>(window != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//If we need to evict any buffered items, let's do that here 这里只有失效策略移除事件,没有触发策略增加计数器,计数器是在tick中</span></span><br><span class="line">            <span class="keyword">if</span>(op.getEvictionPolicy() == Policy.TIME)</span><br><span class="line">                window.timeEvict(op.getEvictionThreshold());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//may be exist window but expire after windowEvictMillis, or non exist window which is a new partition.</span></span><br><span class="line">            window = buildWindow(op, flowInfo.getStreamName(), flowInfo.getIdx(), flowInfo.getPartition(), flowInfo.getFlowId(), windowCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cache不存在,先创建这样的Cache,让后往Cache中put Key Value.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> default windowEvict=60min, what about long time window such as 1day,1week,even 1month,3month.after window evict, does data lost too?</span></span><br><span class="line"><span class="comment">         * after window expire, windowCache!=null, but window=null. see EventTupleTest.testCacheExpire. so buildWindow again.</span></span><br><span class="line"><span class="comment">         * window是针对partition的. 当这个partition的window在1个小时之内都没有任何事件再进来, 这个窗口就会被关闭!</span></span><br><span class="line"><span class="comment">         * 假设我们要统计过去2个小时的数据, 假设key3=val3有两条事件发生的时间是: 1min和65min. 在第一条事件发生的一个小时之后即61min时,window被关闭.</span></span><br><span class="line"><span class="comment">         * 当第二条事件进来时,windowCache!=null &amp; window=null. 创建了一个新的window. 然后往这个新的window添加了第二条事件.</span></span><br><span class="line"><span class="comment">         * 注意:还要考虑tick操作,因为是TIME-Based统计,所以在61min之后,在windowCache中不会存在key2=val3这个Window了.</span></span><br><span class="line"><span class="comment">         * 这样第二条事件只会放入新的Window中, 而旧的Window已经不复存在了. 所以旧的Window中的第一条事件信息也会丢失. 那么统计就不准确了.</span></span><br><span class="line"><span class="comment">         * 一个解决办法是如果TIME=2hour,则设置windowEvictMillis=2hour! 保证窗口不会过期. 但是如果时间跨度很大,window在内存中就存活地更长了.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        windowCache = CacheBuilder.newBuilder().expireAfterWrite(op.getWindowEvictMillis(), TimeUnit.MILLISECONDS).build();</span><br><span class="line">        <span class="comment">//先往windowCache中put partitionKey -&gt; 新build的AggregatorWindow</span></span><br><span class="line">        window = buildWindow(op, flowInfo.getStreamName(), flowInfo.getIdx(), flowInfo.getPartition(), flowInfo.getFlowId(), windowCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AggregatorWindow中put事件. 在窗口还没关闭时,一直往这个窗口内添加数据</span></span><br><span class="line">    window.add(flowInfo.getEvent(), flowInfo.getPreviousStream());</span><br><span class="line">    <span class="comment">//window eviction is on writes, so we need to write to the window to reset our expiration.</span></span><br><span class="line">    <span class="comment">//如果Aggregator前一个不是Partition,则partition=null.</span></span><br><span class="line">    <span class="comment">//NOTICE: 通常设置partition字段相当于SQL中的group by.相同partition的事件会进入同一个Window被聚合函数处理.</span></span><br><span class="line">    windowCache.put(flowInfo.getPartition(), window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Perform count-based trigger if necessary 基于次数:当窗口内的事件数量达到阈值时,开始聚合操作</span></span><br><span class="line">    <span class="comment">//emitAggregate动作有两处:基于时间在tick中, 基于次数在非tick中. 因为tick一秒钟可能有多条事件,所以用tick计数器每秒+1</span></span><br><span class="line">    <span class="comment">//非tick的tuple进来时,execute方法一次只可能接收一条事件,所以基于次数的统计,可以在这里增加计数器</span></span><br><span class="line">    <span class="comment">//因为一个AggregateOp只可能定义要么时间要么次数的策略,所以可以共用triggerTicks计数器,不会说既在tick中也在这里都往同一个计数器+1</span></span><br><span class="line">    <span class="keyword">if</span>(op.getTriggerPolicy() == Policy.COUNT) &#123;</span><br><span class="line">        window.incrTriggerTicks();</span><br><span class="line">        <span class="keyword">if</span>(window.getTriggerTicks() == op.getTriggerThreshold())&#123;</span><br><span class="line">            System.out.println(<span class="string">"COUNT emitAggregate.."</span>);</span><br><span class="line">            emitAggregate(flow, op, flowInfo.getStreamName(), flowInfo.getIdx(), window);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设客户端定义的Stream的FlowOp数组链表顺序是：[SelectOp,PartitionOp,AggregateOp,FilterOp,AggregateOp]，<br>对于第二个AggregateBolt，前面存在一个PartitionBolt，假设它定义的字段为”key1”，上游组件发射了如下的Event Tuple，</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Event Tuple</th>
</tr>
</thead>
<tbody>
<tr>
<td>event1</td>
<td>{“key1”: “val10”, “key2”: “val20”, “key3”: “val30”}</td>
</tr>
<tr>
<td>event2</td>
<td>{“key1”: “val11”, “key2”: “val21”, “key3”: “val31”}</td>
</tr>
<tr>
<td>event3</td>
<td>{“key1”: “val12”, “key2”: “val22”, “key3”: “val32”}</td>
</tr>
<tr>
<td>event4</td>
<td>{“key1”: “val10”, “key2”: “val23”, “key3”: “val33”}</td>
</tr>
<tr>
<td>event5</td>
<td>{“key1”: “val11”, “key2”: “val24”, “key3”: “val34”}</td>
</tr>
</tbody>
</table>
<p>注意Storm的Bolt处理的都是记录级别的，即一条事件进来都会执行一次Bolt的execute方法（不像batch方式一次处理多条事件）。<br>下面是AggregateBolt处理每一条（Event Tuple）记录的过程，假设Flow和Stream名称是”flow1”和”stream1”：  </p>
<p>第一条事件，windowCache=windows.get(“flow1.stream1.2”)=null，2表示这是第二个FlowOp<br>new一个windowCache（内层Map），以及buildWindow创建内层Map中的AggregatorWindow=window<br>这个AggregatorWindow对应的hash=”val10”，因为Partition字段=”key1”，tuple.get(“key1”)=”val10”=hash<br>将第一条事件添加到创建刚刚创建的AggregatorWindow中，window1.add(event1)<br>往windowCache中添加事件的hash-&gt;AggregatorWindow，即”val10”-&gt;AggregatorWindow(event1,”val10”)</p>
<p>第二条事件：windowCache!=null，因为第一条事件已经创建了windowCache，所以不需要再创建了，<br>第二条事件的partition=tuple.get(“key1”)=”val11”，window=windowCache.get(“val11”)=null不存在，<br>所以buildWindow()创建第二个AggregatorWindow(event2,”val11”)，<br>将第二条事件添加到创建刚刚创建的AggregatorWindow中，window2.add(event2)<br>往windowCache中添加事件的hash-&gt;AggregatorWindow，即”val11”-&gt;AggregatorWindow(event2,”val11”)</p>
<p>第三条事件和第二条的处理类似，最终：”val12”-&gt;AggregatorWindow(event2,”val12”)  </p>
<p>第四条事件，windowCache不需要创建，partition=tuple.get(“key1”)=”val10”，<br>window=windowCache.get(“val10”)在第一条事件中创建过了，所以不需要再buildWindow了，直接<br>将第四条事件添加到已经创建好的AggregatorWindow中，window1.add(event2)  </p>
<p>第五条事件，windowCache不需要创建，partition=tuple.get(“key1”)=”val11”，<br>window=windowCache.get(“val11”)在第二条事件中创建过了，所以不需要再buildWindow了，直接<br>将第五条事件添加到已经创建好的AggregatorWindow中，window2.add(event2)  </p>
<p>最终AggregatorBolt处理了上面的五条事件后，windows的数据结构如下：</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713073839872" alt="flowmix-windows example"></p>
<p>上面除了windows数据结构的添加外，如果window不为空，而且evict策略为TIME的话，调用timeEvict，<br>并且会在最后添加事件到AggregatorWindow以及windowCache.put(partition,window)后，如果<br>触发策略为COUNT，会增加计数器（基于COUNT的聚合，处理一条记录计数器+1），如果计数器等于触发阈值，<br>会调用emitAggregate(window)，将AggregatorWindow收集到的所有事件做最终的计算并发射出去。<br>具体的聚合计算方式跟Aggregator的实现类有关（COUNT,SUM等）。  </p>
<p>AggregatorBolt在处理每条事件的时候，如果聚合的窗口还没有到（不管是基于次数还是基于时间），<br>就应该把每条收到的事件暂存在AggregatorWindow中，这样最后窗口达到阈值时，就可以取出这个窗口内的<br>所有事件，并运用具体的Aggregator算法，对所有时间做计算，得到结果后，发射计算结果给下游组件。</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713073927302" alt="store event"></p>
<p>这种如果直接把原始的Event数据简单粗暴地存储在窗口中，如果一个窗口的内事件很多，而且在窗口还没触发执行时，<br>windows因为要保存所有Partition的窗口，如果Partition数量也很多，windows占用的内存将会非常可观（不容乐观）。  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713073940811" alt="many event"></p>
<p>那么有什么解决办法呢？在添加事件到AggregatorWindow的时候，根据Aggregator算法，只存储对最终计算结果有用的数据！<br>比如CountAggregator，在窗口中保存一个计数器，每条事件进来时，只需要增加计数器的值即可，不需要保存原始的事件！  </p>
<p>同样其他类似的Aggregator也可以采用类似的思路，比如SumAggregator/MaxAggregator等等，同样只需要一个变量，<br>当然和Count不需要关心现有状态（Count是无状态的），Sum/Max操作需要获取已有的值和当前事件的值进行比较（有状态）。  </p>
<p>现在每条事件进入窗口时，由原先存储原始事件改为只存储中间结果，下面是第一条事件：</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713080136719" alt="flowmix9"></p>
<p>第二条事件以及接下来的事件：</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713080148140" alt="flowmix10"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713080202171" alt="flowmix11"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713080213890" alt="flowmix12"></p>
<blockquote>
<p>目前的实现中，AggregatorWindow包含Aggregator和Window，Aggregator保存的是确实是每次事件的计算结果，<br>但是Window还是有保存原始事件的！既然add操作和evict操作都可以只更新Aggregator，为什么还需要Window的原始事件？<br><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713162734311" alt="flowmix-aggregator window"></p>
</blockquote>
<h4 id="AggregateOp">AggregateOp</h4><p>从Stream中获得的AggregateOp，会被用来构建AggregatorWindow。应用程序可以定义AggregateOp的各种属性，<br>比如触发策略（Policy.TIME），失效策略（Policy.COUNT），窗口大小（windowEvictMillis），比如下面的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;? extends Aggregator&gt; aggregatorClass;</span><br><span class="line"><span class="keyword">private</span> Policy triggerPolicy;   <span class="comment">//触发策略.比如每隔10分钟,或每隔100条数据,统计一次</span></span><br><span class="line"><span class="keyword">private</span> Policy evictionPolicy;  <span class="comment">//失效策略.当事件进来10分钟后,或者事件总数到达1000条后,移除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> triggerThreshold = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> evictionThreshold = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clearOnTrigger = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> windowEvictMillis = <span class="number">3600000</span>;   <span class="comment">// 60 minutes by default</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,String&gt; config = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br></pre></td></tr></table></figure>
<p>Policy分为三种：<code>COUNT, TIME, TIME_DELTA_LT</code>。  </p>
<p>有必要再解释下AggregateOp各个属性代表的含义，这对AggregateBolt的处理至关重要：</p>
<ol>
<li>触发策略/触发阈值：满足触发阈值时，执行emitAggregator方法</li>
<li>删除策略/删除阈值：窗口时间饱和/事件数量饱和时，删除最旧的事件，确保内存空间，不一定会执行触发策略</li>
<li>窗口大小：</li>
<li>自定义配置：定义Partition用于分区/分组的字段等</li>
</ol>
<h5 id="AggregateWindow">AggregateWindow</h5><p>AggregatorWindow是Aggregator和Window的组合。groupedIndex作为分组的unique key。<br>比如前面示例中Partition的字段=”key1”，那么key1对应的不同值作为分组条件。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregatorWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="comment">//聚合动作,计算策略</span></span><br><span class="line">    <span class="keyword">private</span> Aggregator aggregator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AggregatorWindow</span><span class="params">(Aggregator aggregator, String groupedIndex, <span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//基于容量的双端队列</span></span><br><span class="line">      events = <span class="keyword">new</span> AggregatorLimitingDeque(size, aggregator);</span><br><span class="line">      <span class="keyword">this</span>.groupedIndex = groupedIndex;</span><br><span class="line">      <span class="keyword">this</span>.aggregator = aggregator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AggregatorWindow支持事件的添加和删除，注意这里只是针对一个事件。  </p>
<ul>
<li>当往Window中添加事件，还要调用Aggregator的added方法添加一个WindowItem，  </li>
<li>从Window中删除事件时，也要调用Aggregator的evicted方法删除WindowItem。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowItem <span class="title">add</span><span class="params">(Event event, String previousStream)</span> </span>&#123;</span><br><span class="line">    WindowItem item = <span class="keyword">super</span>.add(event, previousStream); <span class="comment">//往窗口中添加一条事件</span></span><br><span class="line">    aggregator.added(item); <span class="comment">//更新聚合里的变量</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowItem <span class="title">expire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WindowItem item = <span class="keyword">super</span>.expire(); <span class="comment">//从窗口中删除一条事件（可能是窗口过期了，可能是事件数量太多了）</span></span><br><span class="line">    aggregator.evicted(item); <span class="comment">//更新聚合里的变量</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(size() &gt; <span class="number">0</span>) expire(); <span class="comment">//清除所有WindowItem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Window">Window</h4><p>一个Window作为事件的存储队列，为了更方便地支持队列元素的增加和删除，采用双端队列：  </p>
<ol>
<li>添加事件时，加入到队列尾部（add等价于addLast）</li>
<li>删除事件时，从队列尾部移除（这样会有问题吗？）</li>
</ol>
<p>AggregatorWindow继承了Window，而且AggregatorWindow最终是作为AggregatorBolt的windows缓存的最内层存储对象。<br>虽然我们保证了Aggregator添加事件/删除事件时更新了成员变量，但是Window本身还是要存储原始事件的！  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 窗口, 一个窗口内有很多事件, 用双端队列events保存这个窗口内的所有事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String groupedIndex;      <span class="comment">// a unique key given to the groupBy field/value combinations in the window buffer</span></span><br><span class="line">    <span class="keyword">protected</span> Deque&lt;WindowItem&gt; events; <span class="comment">// using standard array list for proof of concept. Circular buffer needs to be used after concept is proven</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> triggerTicks = <span class="number">0</span>;     <span class="comment">//计数器:在基于时间的触发策略中,在tick中增加计数器,表示增加了一秒; 在基于次数的触发策略中,在非tick中增加计数器,表示增加了一条事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//A progressive window buffer which automatically evicts by count</span></span><br><span class="line">    <span class="comment">//渐进的窗口缓冲区, 根据数量进行失效. 即窗口内的事件数量有个阈值, 当达到阈值时, 移除最早加入窗口内的事件.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Window</span><span class="params">(String groupedIndex, <span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.groupedIndex = groupedIndex;</span><br><span class="line">        events = <span class="keyword">new</span> LimitingDeque&lt;WindowItem&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大小无限制的队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Window</span><span class="params">(String groupedIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.groupedIndex = groupedIndex;</span><br><span class="line">        events = <span class="keyword">new</span> LinkedBlockingDeque&lt;WindowItem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个事件到窗口队列中,并返回这个事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WindowItem <span class="title">add</span><span class="params">(Event event, String previousStream)</span> </span>&#123;</span><br><span class="line">        WindowItem item = <span class="keyword">new</span> WindowItem(event, currentTimeMillis(), previousStream);</span><br><span class="line">        events.add(item);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Used for count-based expiration 基于个数的失效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WindowItem <span class="title">expire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowItem除了原始的事件记录外，当前时间撮（进入Bolt时的时间撮，不是事件的时间撮），以及前一个Stream的名称。  </p>
<blockquote>
<p>通常在StreamProcessing中，事件会存在两种时间撮：事件本身的时间撮，事件进入到Bolt里的时间撮。<br>其实由于事件进入窗口后，没有立即被处理，应该还存在一个事件被处理的时间撮（这里等同于进入Bolt的时间撮）。<br><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713084423487" alt="flowmix-event time">  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowItem</span> </span>&#123;</span><br><span class="line">    Event event;</span><br><span class="line">    <span class="keyword">long</span> timestamp;</span><br><span class="line">    String previousStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="time_evict/count_emit">time evict/count emit</h4><p>在收到事件时，需要处理基于时间的失效策略（EvictionPolicy=TIME）和基于次数的触发策略（TriggerPolicy=COUNT）。  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713111804601" alt="flowmix-policy"></p>
<blockquote>
<p>为什么没有基于时间的触发策略，或者基于次数的失效策略？先来看下基于次数的触发和失效策略：  </p>
<ol>
<li>触发策略跟收到的Tuple类型有关，这里是Event，Bolt处理一条Event算一次，跟时间无关，所以触发策略是COUNT</li>
<li>基于次数的失效策略，是内置在Window的add操作中，因为Window是有界队列，如果事件数量超过队列大小，会自动移除事件</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, AggregatorWindow&gt; windowCache = windows.get(flowInfo.getFlowId() + <span class="string">"\0"</span> + flowInfo.getStreamName() + <span class="string">"\0"</span> + flowInfo.getIdx());</span><br><span class="line">AggregatorWindow window = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(windowCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    window = windowCache.getIfPresent(flowInfo.getPartition());</span><br><span class="line">    <span class="keyword">if</span>(window != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(op.getEvictionPolicy() == Policy.TIME)</span><br><span class="line">            window.timeEvict(op.getEvictionThreshold());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        window = buildWindow(op, flowInfo.getStreamName(), flowInfo.getIdx(), flowInfo.getPartition(), flowInfo.getFlowId(), windowCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AggregatorWindow包括了Aggregator和Window，添加事件时不仅添加到Window中，也会更新Aggregator的变量</span></span><br><span class="line">window.add(flowInfo.getEvent(), flowInfo.getPreviousStream());</span><br><span class="line">windowCache.put(flowInfo.getPartition(), window);</span><br><span class="line"><span class="comment">//构建完AggregatorWindow，将事件放入窗口内</span></span><br><span class="line"><span class="comment">//由于Bolt处理的记录级别，所以需要知道什么时候触发执行</span></span><br><span class="line"><span class="comment">//基于COUNT的窗口一般通过计数器，处理一条记录，计数器+1，当计数器值等于阈值时，触发执行</span></span><br><span class="line"><span class="keyword">if</span>(op.getTriggerPolicy() == Policy.COUNT) &#123;</span><br><span class="line">    window.incrTriggerTicks(); <span class="comment">//Bolt每次处理一条记录，计数器+1</span></span><br><span class="line">    <span class="keyword">if</span>(window.getTriggerTicks() == op.getTriggerThreshold())&#123; <span class="comment">//计数器达到客户端设置的阈值，kick off</span></span><br><span class="line">        emitAggregate(flow, op, flowInfo.getStreamName(), flowInfo.getIdx(), window);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于Count的emit，如果计数器值等于阈值，就可以发射：</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713171704132" alt="flowmix-count-emitAggregate"></p>
<p>基于时间的失效策略参数thresholdInSeconds表示只保存这个时间段内的事件，thresholdInSeconds=60s表示只保存最近一分钟的。  </p>
<p>AggregatorWindow.timeEvict()基于时间的evict操作，和基于Count的expire()删除策略类似，都要操作events双端队列<br>以及调用aggregator.evicted(item)更新保存在Aggregator的临时变量（这个变量最终会被用于计算聚合结果）。  </p>
<p>由于事件添加到队列中按照时间顺序（排除事件时间撮out of order的场景），基于时间的删除做法是：找出队列第一个元素(peek)，<br>如果第一条事件的时间撮还没有超过thresholdInSeconds，说明队列中其他所有事件都还没有超时，表示不需要删除任何事件。  </p>
<p>如果第一条事件的时间撮超过thresholdInSeconds。比如阈值是一分钟，当前时间是09:15:30，而第一条事件的时间撮=09:14:00，<br>当前时间-第一条事件时间撮=09:15:30-09:14:00=01:30&gt;1min，说明该事件已经超时，需要移除（即poll）。<br>基于时间的删除，不止检查一个事件（对比基于次数，一次只删除一个，因为进来一个事件，如果队列满了，就删除一个事件），<br>如果队列中还有超时的，都要全部移除出去。比如队列中每条事件的时间撮分别是[09:14:00,09:14:01,09:14:10,09:14:35,…]<br>当前时间=09:15:30，前三个事件都超时了，都会被移除，检查到第四条事件=09:14:35，间隔&lt;1min，才不会继续检查，退出循环。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Used for age-based expiration(time-based)</span></span><br><span class="line"><span class="comment"> * 基于时间的失效策略: events.peek()选择队列中的第一个元素,因为基于时间的事件是按照时间顺序加入到队列中.</span></span><br><span class="line"><span class="comment"> * 如果第一个事件过期了,则从队列中弹出该事件,并调用aggregator.evicted使该事件失效,并继续判断下一个事件.</span></span><br><span class="line"><span class="comment"> * 如果第一个事件没有过期,则后面的事件也一定不会过期.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeEvict</span><span class="params">(<span class="keyword">long</span> thresholdInSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(events != <span class="keyword">null</span> &amp;&amp; events.peek() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (System.currentTimeMillis() - events.peek().getTimestamp()) &gt;= (thresholdInSeconds * <span class="number">1000</span>)) &#123;</span><br><span class="line">      WindowItem item = events.poll();</span><br><span class="line">      aggregator.evicted(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：处理记录级别–对应的是COUNT，还跟基于时间的失效策略有关？（基于时间的触发策略我们知道不能在接收事件这里处理）<br>答案：Bolt处理每条事件时，对不必要的事件进行过滤是最恰当的时机，如果不需要，根本就不需要存储到窗口（能删除尽早删除）。  </p>
</blockquote>
<blockquote>
<p>这里假设当前处理的事件总是落在thresholdInSeconds范围内，如果当前事件已经超时了，不应该添加到窗口中</p>
</blockquote>
<h4 id="buildWindow">buildWindow</h4><p>buildWindow构建AggregatorWindow，如果EvictPolicy为Count时，第三个参数用来作为队列的大小。<br>如果没有第三个参数，那么队列是无界的，比如EvictPolicy为Time时，不限制窗口中事件的数量。  </p>
<p>当然并不是说失效策略为Time时，就不允许EvictionThreshold没有值，基于Time的失效策略，<br>设置EvictionThreshold表示窗口内的事件的时间撮和当前时间相比，不能超过阈值。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端的失效策略基于次数Count，需要第三个参数（失效阈值）作为队列大小</span></span><br><span class="line">window=<span class="keyword">new</span> AggregatorWindow(agg, hash, op.getEvictionThreshold());</span><br><span class="line"></span><br><span class="line"><span class="comment">//尽管这里处理的是事件Tuple，也要处理失效策略为TIME的timeEvict删除事件</span></span><br><span class="line"><span class="keyword">if</span>(op.getEvictionPolicy() == Policy.TIME)</span><br><span class="line">    window.timeEvict(op.getEvictionThreshold());</span><br></pre></td></tr></table></figure>
<p>通常聚合算子前一个是Partition算子，并更新aggConfig，假设Partition指定的fields=”key1”,”key2”，<br>配置为：config.put(“GROUP_BY”，”key1.key2”)，用SQL表示就是<code>group by key1,key2</code>。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//window=null或者windowCache=null,都会创建新的聚合窗口. 并添加到windows map中. 而windows内层的KV中,因为value是新的聚合窗口,所以windowCache也要放一份.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AggregatorWindow <span class="title">buildWindow</span><span class="params">(AggregateOp op, String stream, <span class="keyword">int</span> idx, String hash, String flowId, Cache&lt;String, AggregatorWindow&gt; windowCache)</span> </span>&#123;</span><br><span class="line">    Aggregator agg = op.getAggregatorClass().newInstance();</span><br><span class="line">    AggregatorWindow window = op.getEvictionPolicy() == Policy.TIME || op.getEvictionPolicy() == Policy.TIME_DELTA_LT ?</span><br><span class="line">            <span class="keyword">new</span> AggregatorWindow(agg, hash) :</span><br><span class="line">            <span class="comment">//如果是Count,后台会使用带有容量限制的双端队列. 它的事件失效策略由队列自己控制:比如添加事件进来时,如果队列满了,自动删除队列头事件.所以不需要代码中手动控制.</span></span><br><span class="line">            <span class="keyword">new</span> AggregatorWindow(agg, hash, op.getEvictionThreshold());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一个是PartitionOp,则根据PartitionOp的字段进行GroupBy</span></span><br><span class="line">    FlowOp flowOp = getFlowOpFromStream(flows, flowId, stream, idx-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(flowOp <span class="keyword">instanceof</span> PartitionOp) &#123;</span><br><span class="line">        PartitionOp partitionOp = (PartitionOp)flowOp;</span><br><span class="line">        Map&lt;String,String&gt; aggConfig = op.getConfig();</span><br><span class="line">        aggConfig.put(GROUP_BY, join(partitionOp.getFields(), GROUP_BY_DELIM));</span><br><span class="line">        <span class="comment">//手动调用更新配置</span></span><br><span class="line">        agg.configure(aggConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新创建的聚合窗口AggregatorWindow,里面还没有填充数据,比如将事件加入到窗口中. 所以最后返回这个聚合窗口, 在execute中往window中填充事件.</span></span><br><span class="line">    windowCache.put(hash, window);</span><br><span class="line">    <span class="comment">//windows被看做是key -&gt; (key -&gt; value)的结构. 内层的key-&gt;value即windowCache. 由于是创建新的聚合窗口,说明这是第一次加入到windows中.</span></span><br><span class="line">    <span class="comment">//idx是AggregatorBolt在streams中的位置,注意key并没有和hash(partition)相关. idx更外层,hash为内层map的key.</span></span><br><span class="line">    windows.put(flowId + <span class="string">"\0"</span> + stream + <span class="string">"\0"</span> + idx, windowCache);</span><br><span class="line">    <span class="keyword">return</span> window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理Tick心跳">处理Tick心跳</h4><p><strong>tick tuple background</strong>  </p>
<p>参考：<a href="http://stackoverflow.com/questions/12603920/twitter-storms-window-on-aggregation" target="_blank" rel="noopener">http://stackoverflow.com/questions/12603920/twitter-storms-window-on-aggregation</a><br>和：<a href="http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/" target="_blank" rel="noopener">http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getComponentConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">    <span class="keyword">int</span> tickFrequencyInSeconds = <span class="number">10</span>;</span><br><span class="line">    conf.put(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS, tickFrequencyInSeconds);</span><br><span class="line">    <span class="keyword">return</span> conf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTickTuple(tuple)) &#123;</span><br><span class="line">        <span class="comment">// now you can trigger e.g. a periodic activity</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do something with the normal tuple</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTickTuple</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tuple.getSourceComponent().equals(Constants.SYSTEM_COMPONENT_ID)</span><br><span class="line">        &amp;&amp; tuple.getSourceStreamId().equals(Constants.SYSTEM_TICK_STREAM_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：和处理事件方式获取FlowOp不同的是，这里要遍历Stream的所有FlowOp，为什么不根据索引位置来查询呢？<br>如果FlowOp数组链表中有多个AggregateOp，这样遍历会不会有问题，因为会找出所有的AggregateOp？<br>答案：Topology中只有TickSpout会发射心跳，并且会发射心跳给除了FlowInitBolt外的其他所有Bolt。<br>Bolt接收的心跳只能来自于TickSpout，<strong>Bolt不会往下游Bolt发射心跳</strong>。而TickSpout没有发射索引位置！  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Flow flow : flows.values()) &#123;</span><br><span class="line">    <span class="keyword">for</span>(StreamDef curStream : flow.getStreams()) &#123;</span><br><span class="line">        <span class="comment">//一个Stream中会有多个AggOp. 从0开始找这样的AggOp. 即使不是AggOp,idx++.这样找到的AggOp,此时的idx表示AggOp在flowOps中第几个.</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(FlowOp curFlowOp : curStream.getFlowOps()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curFlowOp <span class="keyword">instanceof</span> AggregateOp) &#123;</span><br><span class="line">                AggregateOp op = (AggregateOp)curFlowOp;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//FlowOp的索引</span></span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tick时必须保证windowCache有数据，就好像Bolt处理Event数据时，必须保证flows有数据。  </p>
<ol>
<li>Bolt收到Tick心跳，但是没有收到Event事件，没有事件，有心跳也是白搭，心跳是无效的</li>
<li>Bolt收到Event数据，但是没有flows，就不会有FlowOp，不会有算子对事件进行计算，即使收到事件是无效的</li>
</ol>
<p>所以对于AggregateBolt而言，接收各种事件的顺序为：<strong>flows -&gt; Event -&gt; Tick</strong>。<br>因为Event事件先接收，而在处理Event事件时会构造<code>windows</code>双层Map，所以tick时，<code>windowCache</code>一定有数据。  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713150515435" alt="flowmix-tick"></p>
<blockquote>
<p>如果一个Stream中存在相同的FlowOp，目前的实现中这部分貌似没有做太多的逻辑判断。</p>
</blockquote>
<p>由于Stream可能有多个AggregatorBolt，tick方式没有上下文位置信息，所以只能获取所有的AggregateOp。<br>不过由于event方式得到的windows的限制，如果找到的不属于当前AggregatorBolt对应的AggregateOp，<br>是不会处理那样的AggregateOp的。举例假设Stream的FlowOp=[Select,Aggregate,Select,Aggregate]。<br>如果当前的AggregateBolt是第二个，在处理事件时，windows的key只可能是”flow-stream-2”，<br>尽管处理tick时，会找到第二个和第四个AggregateOp，但是windows.get(“flow-stream-4”)得到的windowCache一定为空。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有聚合操作符才需要统计动作,即触发窗口内的所有事件的聚合动作(当然不一定是立即计算)</span></span><br><span class="line"><span class="comment">//对于窗口内的所有事件,每当tick一次,基于时间的失效策略需要移除过期的事件.</span></span><br><span class="line">AggregateOp op = (AggregateOp)curFlowOp;</span><br><span class="line"><span class="comment">//If we need to trigger any time-based policies, let's do that here 基于时间的策略(触发策略和失效策略)的动作</span></span><br><span class="line"><span class="keyword">if</span>(op.getTriggerPolicy() == Policy.TIME || op.getEvictionPolicy() == Policy.TIME) &#123;</span><br><span class="line">    Cache&lt;String, AggregatorWindow&gt; windowCache = windows.get(flow.getId() + <span class="string">"\0"</span> + curStream.getName() + <span class="string">"\0"</span> + idx);</span><br><span class="line">    <span class="comment">//Cache中必须有,如果Cache为空,说明这个时间段内都没有事件进来.没有事件就没有Cache,就不需要移除事件的失效动作和统计结果的发射动作.</span></span><br><span class="line">    <span class="keyword">if</span>(windowCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//windowCache怎么存放数据在非tick中:&lt;flowInfo.getPartition(), AggregatorWindow&gt;.</span></span><br><span class="line">        <span class="comment">//如果没有partition,则只有一个AggregatorWindow. 则在满足ticks后,调用一次emitAggregate</span></span><br><span class="line">        <span class="comment">//如果有多个partition,则每个partition都有一个Window,并且每个partition在满足ticks后都会调用emitAggregate</span></span><br><span class="line">        <span class="comment">//是否达到ticks是由每个AggregatorWindow的计数器确定的.</span></span><br><span class="line">        <span class="keyword">for</span>(AggregatorWindow window : windowCache.asMap().values()) &#123;</span><br><span class="line">            <span class="comment">//失效策略,每tick一秒,移除过期的事件</span></span><br><span class="line">            <span class="keyword">if</span>(op.getEvictionPolicy() == Policy.TIME)</span><br><span class="line">                window.timeEvict(op.getEvictionThreshold());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//触发策略,每tick一秒,增加时间tick计数器. 每隔多长时间触发一次统计动作是由这个计数器引起的!</span></span><br><span class="line">            <span class="keyword">if</span>(op.getTriggerPolicy() == Policy.TIME)</span><br><span class="line">                window.incrTriggerTicks();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//因为每秒都会增加一次tick计数器. 最后计数器的值会达到阈值,触发聚合动作</span></span><br><span class="line">            <span class="comment">//假设Stream设置trigger(Policy.TIME, 5)即每5秒触发一次统计(单位是秒,所以计数器每秒+1,加到阈值后,刚好满足触发条件).</span></span><br><span class="line">            <span class="comment">//则tick spout发送5次tick tuple后.AggregatorBolt会统计5秒内的事件并发射给下一个Bolt</span></span><br><span class="line">            <span class="keyword">if</span>(window.getTriggerTicks() == op.getTriggerThreshold())&#123;</span><br><span class="line">                System.out.println(<span class="string">"TIME emitAggregate.."</span>);</span><br><span class="line">                emitAggregate(flow, op, curStream.getName(), idx, window);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里针对tick tuple，有多种操作：  </p>
<p>每次收到tick tuple，说明时间过去了interval，那么AggregatorWindow中的事件（Window）和计算结果临时变量（Aggregator）都要更新。<br>因为处理的不是事件（Bolt接收的但是event tuple，表示进来一条新的事件），所以只会进行evict操作，而不会有add操作。   </p>
<table>
<thead>
<tr>
<th>tuple</th>
<th>AggregatorWindow.add</th>
<th>AggregatorWindow.evict</th>
</tr>
</thead>
<tbody>
<tr>
<td>event</td>
<td>接收新的事件，添加事件到窗口，并更新Aggregator的临时变量</td>
<td>接收新事件，由于窗口事件数量的限制可能需要移除事件</td>
</tr>
<tr>
<td>tick</td>
<td>-</td>
<td>接收新的心跳，如果窗口队列的事件超时，应该删除</td>
</tr>
</tbody>
</table>
<p>Bolt接收event tuple，触发策略为COUNT时，会在event tuple的处理过程中增加计数器，当窗口事件数量累积到阈值时，会计算最终结果并发射到下游组件。<br>Bolt接收tick tuple，触发策略为TIME时，也会增加计数器（计数器可以用来表示COUNT和TIME），同样计数器达到阈值时，也会执行emitAggregate。  </p>
<p>tick和event不同的是，处理event时，因为每条事件对应的Window是确定的，计数器只会+1，而tick需要操作所有Window！  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180829872" alt="flowmix-time1"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180841077" alt="flowmix-time2"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180851154" alt="flowmix-time3"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180902561" alt="flowmix-time4"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180914358" alt="flowmix-time5"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160713180924514" alt="flowmix-time6"></p>
<blockquote>
<p>思考问题：基于Count的evict，如果计数器一直没有到达，那么是不是永远不会处置emit，</p>
</blockquote>
<h4 id="emitAggregate">emitAggregate</h4><p>TriggerPolicy为TIME或者COUNT，在满足条件时（达到触发阈值）都会执行emitAggregate。<br>对于COUNT，由于在处理事件时触发，所以一次只操作一个Window，对于TIMER，一次会操作多个Window。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emitAggregate</span><span class="params">(Flow flow, AggregateOp op, String stream, <span class="keyword">int</span> idx, AggregatorWindow window)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从窗口获取到的也是事件,这样可以继续将聚合结果下发给下一个组件.</span></span><br><span class="line">    <span class="comment">//while(window.getEvents().iterator().hasNext())&#123;</span></span><br><span class="line">    <span class="comment">//    System.out.println("AggregateEvents:"+window.getEvents().iterator().next().getEvent());</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    System.out.println(sdf.format(System.currentTimeMillis())+<span class="string">" Begin Aggregate....[aggOpIndex:"</span>+idx+<span class="string">", groupIndex:"</span> + window.getGroupedIndex()+<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    Collection&lt;AggregatedEvent&gt; eventsToEmit = window.getAggregate();</span><br><span class="line">    String nextStream = idx+<span class="number">1</span> &lt; flow.getStream(stream).getFlowOps().size() ? getFlowOpFromStream(flow, stream, idx + <span class="number">1</span>).getComponentName() : <span class="string">"output"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasNextOutput(flow, stream, nextStream)) &#123;</span><br><span class="line">      <span class="keyword">for</span>(AggregatedEvent event : eventsToEmit) &#123;</span><br><span class="line">        String previousStream = event.getPreviousStream() != <span class="keyword">null</span> ? event.getPreviousStream() : stream;</span><br><span class="line">        <span class="comment">// Note: If aggregated event isn't keeping the previous stream, it's possible it could be lost</span></span><br><span class="line">        collector.emit(nextStream, <span class="keyword">new</span> Values(flow.getId(), event.getEvent(), idx, stream, previousStream));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send to any other streams that are configured (aside from output)</span></span><br><span class="line">    <span class="keyword">if</span>(exportsToOtherStreams(flow, stream, nextStream)) &#123;</span><br><span class="line">      <span class="keyword">for</span>(String output : flow.getStream(stream).getOutputs()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(AggregatedEvent event : eventsToEmit) &#123;</span><br><span class="line">          String outputComponent = flow.getStream(output).getFlowOps().get(<span class="number">0</span>).getComponentName();</span><br><span class="line">          collector.emit(outputComponent, <span class="keyword">new</span> Values(flow.getId(), event.getEvent(), -<span class="number">1</span>, output, stream));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数器达到阈值后,触发emitAggregate调用,上面对窗口内的事件统计完毕后,清空计数器.使得下一个窗口继续使用新的计数器.</span></span><br><span class="line">    <span class="keyword">if</span>(op.isClearOnTrigger()) window.clear();</span><br><span class="line">    window.resetTriggerTicks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再论AggregatorWindow：</p>
<p>由于AggregatorWindow包括了Aggregator和Window，当Tuple事件进来时，不仅要将原始事件加入到Window中暂存，<br>还要更新Aggregator的相关临时变量的值，最后在emitAggregate时，获取Aggregator最新的结果发射出去。也就是说<br>AggregatorWindow.add()和evict()方法会被调用多次（其中add每次都会调用，但是evict根据失效策略只有在达到阈值时才调用），<br>但是emitAggregate()只会调用一次（不管是TIMER还是COUNT，只有达到触发器的计数器阈值时才调用）。<br>最后在发射出去之后，要清空Window中的事件（如果允许清空的话，有些场景可能不需要清空），并且重置触发器的计数器。  </p>
<h3 id="AbstractAggregator">AbstractAggregator</h3><p>所有的Aggregator实现类都实现了AbstractAggregator抽象父类。</p>
<h4 id="示例-1">示例</h4><p>场景：用户登陆事件（有IP，有账号）</p>
<p>RDBMS DataModel</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>ip</th>
<th>account</th>
</tr>
</thead>
<tbody>
<tr>
<td>E1</td>
<td>1.1.1.1</td>
<td>张三</td>
</tr>
<tr>
<td>E2</td>
<td>1.1.1.2</td>
<td>李四</td>
</tr>
<tr>
<td>E3</td>
<td>1.1.1.1</td>
<td>王五</td>
</tr>
</tbody>
</table>
<p>NOSQL DataModel</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>key1</th>
<th>key2</th>
<th>key3</th>
<th>key4</th>
<th>type</th>
</tr>
</thead>
<tbody>
<tr>
<td>E1</td>
<td>ip</td>
<td>account</td>
<td>1.1.1.1</td>
<td>张三</td>
<td>login</td>
</tr>
<tr>
<td>E2</td>
<td>ip</td>
<td>account</td>
<td>1.1.1.2</td>
<td>李四</td>
<td>login</td>
</tr>
<tr>
<td>E3</td>
<td>ip</td>
<td>account</td>
<td>1.1.1.1</td>
<td>王五</td>
<td>login</td>
</tr>
</tbody>
</table>
<h5 id="Count">Count</h5><ol>
<li>十分钟的登陆次数, key3能代表这是一条登陆事件</li>
<li>一天的交易次数,key3代表一条交易事件</li>
<li>一天的调用量,key3代表一条事件,可以用sequence_id字段表示</li>
</ol>
<p>SQL：select count(key3) from tbl where key3 is not null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Flow&gt; <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Flow flow = <span class="keyword">new</span> FlowBuilder()</span><br><span class="line">            .id(<span class="string">"flow1"</span>)</span><br><span class="line">            .flowDefs()</span><br><span class="line">                .stream(<span class="string">"stream1"</span>)</span><br><span class="line">                    .select().fields(<span class="string">"key3"</span>).end()</span><br><span class="line">                    .aggregate().aggregator(CountAggregator.class)</span><br><span class="line">                        .config(<span class="string">"operatedField"</span>, <span class="string">"key3"</span>)</span><br><span class="line">                        .evict(Policy.COUNT, <span class="number">50000</span>)</span><br><span class="line">                        .trigger(Policy.TIME, <span class="number">5</span>)</span><br><span class="line">                        .windowEvictMillis(<span class="number">3600000</span>) <span class="comment">//60min window</span></span><br><span class="line">                        .clearOnTrigger().end()</span><br><span class="line">                .endStream()</span><br><span class="line">            .endDefs()</span><br><span class="line">            .createFlow();</span><br><span class="line">    <span class="keyword">return</span> asList(<span class="keyword">new</span> Flow[]&#123;flow&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="GroupBy(Partition)">GroupBy(Partition)</h5><p>一天内各个合作方的调用量, key3代表一条调用记录,比如sequence_id</p>
<p>SQL：select key3, count(*) from tbl group by key3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  List&lt;Flow&gt; <span class="title">partitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Flow flow = <span class="keyword">new</span> FlowBuilder()</span><br><span class="line">            .id(<span class="string">"flow1"</span>)</span><br><span class="line">            .flowDefs()</span><br><span class="line">                .stream(<span class="string">"stream1"</span>)</span><br><span class="line">                    .select().fields(<span class="string">"key3"</span>).end()</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Every 5 seconds, emit the counts of events grouped by the key3 field.</span></span><br><span class="line"><span class="comment">                     * Don't allow more than 50000 items to exist in the window at any point in time (maxCount = 50000)</span></span><br><span class="line"><span class="comment">                     * remove this to get the total number of events</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    .partition().fields(<span class="string">"key3"</span>).end()</span><br><span class="line">                    .aggregate().aggregator(CountAggregator.class)</span><br><span class="line">                        .config(<span class="string">"operatedField"</span>, <span class="string">"key3"</span>)</span><br><span class="line">                        .evict(Policy.COUNT, <span class="number">50000</span>)</span><br><span class="line">                        .trigger(Policy.TIME, <span class="number">5</span>)</span><br><span class="line">                        .clearOnTrigger().end()</span><br><span class="line">                .endStream()</span><br><span class="line">            .endDefs()</span><br><span class="line">            .createFlow();</span><br><span class="line">    <span class="keyword">return</span> asList(<span class="keyword">new</span> Flow[]&#123;flow&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Fields">Fields</h4><p>AbstractAggregator有多种字段：  </p>
<ol>
<li>operatedField</li>
<li>outputField</li>
<li>groupByFields</li>
</ol>
<p>operatedField表示要取Event中该字段进行计算，groupByFields表示分组条件，这两个字段可以不同。<br>举例SQL：select sum(key3) from tbl group by key1,key2。对应的</p>
<ul>
<li>operatedField = key3</li>
<li>groupByFields = [key1,key2]</li>
</ul>
<p>其中groupByFields是由Aggregator之前的PartitionOp确定的，在buildWindow中创建<br>AggregatorWindow时会获取PartitionOp的Fields，并更新AggregatorOp的aggConfig Map。<br>以上面的SQL为例，在partition中指定fields=[key1,key2]，在aggregate中指定operateField=key3。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application</span></span><br><span class="line">    .partition().fields(<span class="string">"key1,key2"</span>).end()</span><br><span class="line">    .aggregate().aggregator(SumAggregator.class)</span><br><span class="line">        .config(<span class="string">"operatedField"</span>, <span class="string">"key3"</span>)</span><br><span class="line">        .evict(Policy.COUNT, <span class="number">50000</span>)</span><br><span class="line">        .trigger(Policy.TIME, <span class="number">5</span>)</span><br><span class="line">        .clearOnTrigger().end()</span><br><span class="line"></span><br><span class="line"><span class="comment">//AggregatorBolt.buildWindow</span></span><br><span class="line">FlowOp flowOp = getFlowOpFromStream(flows, flowId, stream, idx-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(flowOp <span class="keyword">instanceof</span> PartitionOp) &#123;</span><br><span class="line">    PartitionOp partitionOp = (PartitionOp)flowOp;</span><br><span class="line">    Map&lt;String,String&gt; aggConfig = op.getConfig();</span><br><span class="line">    aggConfig.put(GROUP_BY, join(partitionOp.getFields(), GROUP_BY_DELIM));</span><br><span class="line">    <span class="comment">//手动调用更新配置</span></span><br><span class="line">    agg.configure(aggConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ol>
<li>operatedField只能有一个字段</li>
<li>partition的groupByFields可以有多个，用逗号分隔</li>
</ol>
<p>这样通过Event获取operateField的值，也只能有一个。即<br>如果我们想获取多个字段并计算怎么办？  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAggregator</span>&lt;<span class="title">T</span>, <span class="title">F</span>&gt; <span class="keyword">implements</span> <span class="title">Aggregator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPERATED_FIELD = <span class="string">"operatedField"</span>;    <span class="comment">// field to operate with</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String OUTPUT_FIELD = <span class="string">"outputField"</span>;        <span class="comment">// output field</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASSOC_FIELD = <span class="string">"assocField"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, Collection&lt;Tuple&gt;&gt; groupedValues;         <span class="comment">// grouped fields description</span></span><br><span class="line">    <span class="keyword">protected</span> String[] groupByFields;                               <span class="comment">// fields to group by</span></span><br><span class="line">    <span class="keyword">protected</span> String operatedField;                                 <span class="comment">// operated field name</span></span><br><span class="line">    <span class="keyword">protected</span> String outputField = getOutputField();                <span class="comment">// output field set by implementation</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] assocField; <span class="comment">//关联字段,有两个,比如IP在账户上的关联个数.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, String&gt; configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (configuration.get(GROUP_BY) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupByFields = StringUtils.splitPreserveAllTokens(configuration.get(GROUP_BY), GROUP_BY_DELIM);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configuration.get(OUTPUT_FIELD) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            outputField = configuration.get(OUTPUT_FIELD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configuration.get(OPERATED_FIELD) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            operatedField = configuration.get(OPERATED_FIELD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configuration.get(ASSOC_FIELD) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            assocField = StringUtils.splitPreserveAllTokens(configuration.get(ASSOC_FIELD), <span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">added</span><span class="params">(WindowItem item)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一个窗口项(事件)进来时满足条件.后面的窗口项因为groupedValues!=null,不满足条件.</span></span><br><span class="line">        <span class="keyword">if</span> (groupedValues == <span class="keyword">null</span> &amp;&amp; groupByFields != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupedValues = <span class="keyword">new</span> HashMap&lt;String, Collection&lt;Tuple&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String group : groupByFields) &#123;</span><br><span class="line">                groupedValues.put(group, item.getEvent().getAll(group));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item.getEvent().get(operatedField) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//参数是事件记录中操作字段的值. 而不是事件记录本身.比如要聚合sum(key3),则我们要把key3的值取出来,作为sum的参数</span></span><br><span class="line">            add(((F) item.getEvent().get(operatedField).getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 关联字段</span></span><br><span class="line">        <span class="keyword">if</span>(assocField != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果关联的两个字段类型不同呢, 所以最好自定义的Aggregator的F为Object类型.</span></span><br><span class="line">            add(((F) item.getEvent().get(assocField[<span class="number">0</span>]).getValue()), ((F) item.getEvent().get(assocField[<span class="number">1</span>]).getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CountAggregator">CountAggregator</h4><h4 id="DistinctCountAggregator">DistinctCountAggregator</h4><h4 id="AssocCountAggregator">AssocCountAggregator</h4>
      
    </div>
    
  </div>
  
    
<div class="copyright">
  <p><span>本文标题:</span><a href="/2015/07/26/2015-09-11-Flowmix-CEP/">Storm的CEP框架 flowmix</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 任何忧伤,都抵不过世界的美丽 的个人博客">任何忧伤,都抵不过世界的美丽</a></p>
  <p><span>发布时间:</span>2015年07月26日 - 00时00分</p>
  <p><span>最后更新:</span>2019年02月14日 - 21时42分</p>
  <p>
    <span>原始链接:</span><a href="/2015/07/26/2015-09-11-Flowmix-CEP/" title="Storm的CEP框架 flowmix">http://github.com/zqhxuyuan/2015/07/26/2015-09-11-Flowmix-CEP/</a>
    <span class="btn" data-clipboard-text="原文: http://github.com/zqhxuyuan/2015/07/26/2015-09-11-Flowmix-CEP/　　作者: 任何忧伤,都抵不过世界的美丽" title="点击复制文章链接">
        <i class="fa fa-clipboard"></i>
    </span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。</p>
  <script src="/js/clipboard.min.js"></script>
  <script> var clipboard = new Clipboard('.btn'); </script>
</div>
<style type="text/css">
  .copyright p .btn {
    margin-left: 1em;
  }
  .copyright:hover p .btn::after {
    content: "复制"
  }
  .copyright p .btn:hover {
      color: gray;
      cursor: pointer;
    };
</style>



<nav id="article-nav">
  
    <div id="article-nav-newer" class="article-nav-title">
      <a href="/2015/07/26/2015-07-26-drill-fragment-execute/">
        Apache Drill源码阅读(6) execute
      </a>
    </div>
  
  
    <div id="article-nav-older" class="article-nav-title">
      <a href="/2015/07/15/2015-07-15-drill-fragments/">
        Apache Drill源码阅读(5) Fragment
      </a>
    </div>
  
</nav>

  
  
    <div class="post-donate">
	<br>
	<p>
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
		   招人广告：对蚂蚁金服中间件感兴趣的可以发邮件到：qihuang.zqh at antfin.com
        </span>
        <br>
    </div>  
	<div id="donate_guide" class="donate_bar center hidden">
		<img src="/img/zhifubao.png" alt="支付宝打赏"> 
		<img src="/img/weixin.png" alt="微信打赏">  
    </div>
	<script type="text/javascript">
		document.getElementById('btn_donate').onclick = function(){
			$('#donate_board').addClass('hidden');
			$('#donate_guide').removeClass('hidden');
		}
	</script>
</p></div>
  
</article>

<!-- 默认显示文章目录，在文章---前输入toc: false关闭目录 -->
<!-- Show TOC and tocButton in default, Hide TOC via putting "toc: false" before "---" at [post].md -->
<div id="toc" class="toc-article">
<strong class="toc-title">文章目录</strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduce"><span class="toc-number">1.</span> <span class="toc-text">Introduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例"><span class="toc-number">2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Topology组件"><span class="toc-number">3.</span> <span class="toc-text">Topology组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Builder"><span class="toc-number">4.</span> <span class="toc-text">Builder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算子Builder"><span class="toc-number">4.1.</span> <span class="toc-text">算子Builder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FlowmixBuilder"><span class="toc-number">5.</span> <span class="toc-text">FlowmixBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Event_Spout"><span class="toc-number">5.1.</span> <span class="toc-text">Event Spout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlowLoader_Spout"><span class="toc-number">5.2.</span> <span class="toc-text">FlowLoader Spout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tick_Spout"><span class="toc-number">5.3.</span> <span class="toc-text">Tick Spout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlowInitializerBolt"><span class="toc-number">5.4.</span> <span class="toc-text">FlowInitializerBolt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic_FlowOp’s_Bolt_Definition"><span class="toc-number">5.5.</span> <span class="toc-text">Dynamic FlowOp’s Bolt Definition</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FlowInitBolt下一个Bolt"><span class="toc-number">5.5.1.</span> <span class="toc-text">FlowInitBolt下一个Bolt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算子Bolt之间的上下游依赖关系"><span class="toc-number">5.5.2.</span> <span class="toc-text">算子Bolt之间的上下游依赖关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算子Bolt"><span class="toc-number">6.</span> <span class="toc-text">算子Bolt</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectBolt"><span class="toc-number">6.1.</span> <span class="toc-text">SelectBolt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FilterBolt"><span class="toc-number">6.2.</span> <span class="toc-text">FilterBolt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EachBolt"><span class="toc-number">6.3.</span> <span class="toc-text">EachBolt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PartitionBolt"><span class="toc-number">6.4.</span> <span class="toc-text">PartitionBolt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event"><span class="toc-number">6.5.</span> <span class="toc-text">Event</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AggregatorBolt"><span class="toc-number">6.6.</span> <span class="toc-text">AggregatorBolt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#处理Event事件"><span class="toc-number">6.6.1.</span> <span class="toc-text">处理Event事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AggregateOp"><span class="toc-number">6.6.2.</span> <span class="toc-text">AggregateOp</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AggregateWindow"><span class="toc-number">6.6.2.1.</span> <span class="toc-text">AggregateWindow</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Window"><span class="toc-number">6.6.3.</span> <span class="toc-text">Window</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#time_evict/count_emit"><span class="toc-number">6.6.4.</span> <span class="toc-text">time evict/count emit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buildWindow"><span class="toc-number">6.6.5.</span> <span class="toc-text">buildWindow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理Tick心跳"><span class="toc-number">6.6.6.</span> <span class="toc-text">处理Tick心跳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emitAggregate"><span class="toc-number">6.6.7.</span> <span class="toc-text">emitAggregate</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractAggregator"><span class="toc-number">6.7.</span> <span class="toc-text">AbstractAggregator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#示例-1"><span class="toc-number">6.7.1.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Count"><span class="toc-number">6.7.1.1.</span> <span class="toc-text">Count</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GroupBy(Partition)"><span class="toc-number">6.7.1.2.</span> <span class="toc-text">GroupBy(Partition)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fields"><span class="toc-number">6.7.2.</span> <span class="toc-text">Fields</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountAggregator"><span class="toc-number">6.7.3.</span> <span class="toc-text">CountAggregator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DistinctCountAggregator"><span class="toc-number">6.7.4.</span> <span class="toc-text">DistinctCountAggregator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AssocCountAggregator"><span class="toc-number">6.7.5.</span> <span class="toc-text">AssocCountAggregator</span></a></li></ol></li></ol></li></ol>
</div>
<style type="text/css">
  .left-col .switch-btn {
    display: none;
  }
  .left-col .switch-area {
    display: none;
  }
</style>

<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">
<script type="text/javascript">
  var toc_button= document.getElementById("tocButton");
  var toc_div= document.getElementById("toc");
  /* Show or hide toc when click on tocButton.
  通过点击设置的按钮显示或者隐藏文章目录.*/
  toc_button.onclick=function(){
  if(toc_div.style.display=="none"){
  toc_div.style.display="block";
  toc_button.value="隐藏目录";
  document.getElementById("switch-btn").style.display="none";
  document.getElementById("switch-area").style.display="none";
  }
  else{
  toc_div.style.display="none";
  toc_button.value="显示目录";
  document.getElementById("switch-btn").style.display="block";
  document.getElementById("switch-area").style.display="block";
  }
  }
    if ($(".toc").length < 1) {
        $("#toc").css("display","none");
        $("#tocButton").css("display","none");
        $(".switch-btn").css("display","block");
        $(".switch-area").css("display","block");
    }
</script>


    <style>
        .toc {
            white-space: nowrap;
            overflow-x: hidden;
        }
    </style>

    <script>
        $(document).ready(function() {
            $(".toc li a").mouseover(function() {
                var title = $(this).attr('href');
                $(this).attr("title", title);
            });
        })
    </script>




<div class="share">
	<div class="bdsharebuttonbox">
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
	<a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
	<a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
	</div>
	<script>
	window._bd_share_config={
		"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	</script>
</div>



<div class="duoshuo" id="comments">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2015/07/26/2015-09-11-Flowmix-CEP/" data-title="Storm的CEP框架 flowmix" data-url="http://github.com/zqhxuyuan/2015/07/26/2015-09-11-Flowmix-CEP/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"zqhxuyuan"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>






    <style type="text/css">
    #scroll {
      display: none;
    }
    </style>
    <div class="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
    </div>


  
  
    
    <div class="post-nav-button">
    <a href="/2015/07/26/2015-07-26-drill-fragment-execute/" title="上一篇: Apache Drill源码阅读(6) execute">
    <i class="fa fa-angle-left"></i>
    </a>
    <a href="/2015/07/15/2015-07-15-drill-fragments/" title="下一篇: Apache Drill源码阅读(5) Fragment">
    <i class="fa fa-angle-right"></i>
    </a>
    </div>
  



    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
        
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2019 任何忧伤,都抵不过世界的美丽
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style="display:none">
        <span id="site-visit">本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style="display:none">
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

<script>
  var backgroundnum = 5;
  var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));

  $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
</script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-80646710-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>