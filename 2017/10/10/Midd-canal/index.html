<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>深入解析中间件之-Canal | zqhxuyuan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="canal: 阿里巴巴mysql数据库binlog的增量订阅&amp;amp;消费组件">
<meta name="keywords" content="midd">
<meta property="og:type" content="article">
<meta property="og:title" content="深入解析中间件之-Canal">
<meta property="og:url" content="http://github.com/zqhxuyuan/2017/10/10/Midd-canal/index.html">
<meta property="og:site_name" content="zqhxuyuan">
<meta property="og:description" content="canal: 阿里巴巴mysql数据库binlog的增量订阅&amp;amp;消费组件">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160914112042547">
<meta property="og:image" content="https://camo.githubusercontent.com/db1debcfa50f4ebea1f56a1fa0e18a4e960cafcc/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333239372f39643765643133652d366138362d333836642d393266342d3835323233386334373562662e6a7067">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011202259253">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011211529169">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011225116791">
<meta property="og:image" content="https://camo.githubusercontent.com/031db3aa27461d13faa2dea479ef639f93386a00/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333134332f37393531633136392d663764662d336362332d616562622d6439323466353733313163622e6a7067">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011234800632">
<meta property="og:image" content="https://camo.githubusercontent.com/c8f1d98268a307821273e94e7eefcd29a26f9b78/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333330332f64333230326332362d653935342d333563302d613331392d3537363034313032633537642e6a7067">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171012184033228">
<meta property="og:image" content="https://camo.githubusercontent.com/8cc684cf92e22d738d57b002c356afba96bcc4f5/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303039302f363435332f39326233343335302d323566632d333162332d626361362d3865326131653763356532322e6a7067">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171012230738279">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171012234337736">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011211529169">
<meta property="og:updated_time" content="2019-02-14T13:42:29.375Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入解析中间件之-Canal">
<meta name="twitter:description" content="canal: 阿里巴巴mysql数据库binlog的增量订阅&amp;amp;消费组件">
<meta name="twitter:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160914112042547">
  
    <link rel="alternative" href="/atom.xml" title="zqhxuyuan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars1.githubusercontent.com/u/1088525?v=3&amp;s=180" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任何忧伤,都抵不过世界的美丽</a></h1>
		</hgroup>

		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">归档</a></li>
				        
							<li><a href="/tags/">标签</a></li>
				        
							<li><a href="/about/">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/xuyuantree" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="http://github.com/zqhxuyuan" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/apex/" style="font-size: 10px;">apex</a> <a href="/tags/bigdata/" style="font-size: 10px;">bigdata</a> <a href="/tags/book/" style="font-size: 10px;">book</a> <a href="/tags/cassandra/" style="font-size: 18.89px;">cassandra</a> <a href="/tags/clojure/" style="font-size: 10px;">clojure</a> <a href="/tags/drill/" style="font-size: 16.67px;">drill</a> <a href="/tags/druid/" style="font-size: 13.33px;">druid</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/etl/" style="font-size: 10px;">etl</a> <a href="/tags/geode/" style="font-size: 10px;">geode</a> <a href="/tags/graph/" style="font-size: 12.22px;">graph</a> <a href="/tags/hadoop/" style="font-size: 11.11px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 15.56px;">hbase</a> <a href="/tags/ignite/" style="font-size: 10px;">ignite</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/kafka/" style="font-size: 20px;">kafka</a> <a href="/tags/midd/" style="font-size: 10px;">midd</a> <a href="/tags/ops/" style="font-size: 12.22px;">ops</a> <a href="/tags/redis/" style="font-size: 11.11px;">redis</a> <a href="/tags/rocketmq/" style="font-size: 10px;">rocketmq</a> <a href="/tags/scala/" style="font-size: 13.33px;">scala</a> <a href="/tags/spark/" style="font-size: 17.78px;">spark</a> <a href="/tags/storm/" style="font-size: 17.78px;">storm</a> <a href="/tags/tcc/" style="font-size: 10px;">tcc</a> <a href="/tags/timeseries/" style="font-size: 12.22px;">timeseries</a> <a href="/tags/work/" style="font-size: 14.44px;">work</a> <a href="/tags/流处理/" style="font-size: 11.11px;">流处理</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">BIG(DATA)</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">任何忧伤,都抵不过世界的美丽</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="https://avatars1.githubusercontent.com/u/1088525?v=3&amp;s=180" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">任何忧伤,都抵不过世界的美丽</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">归档</a></li>
		        
					<li><a href="/tags/">标签</a></li>
		        
					<li><a href="/about/">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/xuyuantree" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="http://github.com/zqhxuyuan" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Midd-canal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/10/Midd-canal/" class="article-date">
  	<time datetime="2017-10-09T16:00:00.000Z" itemprop="datePublished">2017-10-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入解析中间件之-Canal
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/midd/">midd</a>
	</div>


        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/midd/">midd</a></li></ul>
	</div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p><a href="https://github.com/alibaba/canal">canal</a>: 阿里巴巴mysql数据库binlog的增量订阅&amp;消费组件<br><a id="more"></a></p>
<h2 id="MySQL_binlog">MySQL binlog</h2><h3 id="MySQL主从复制">MySQL主从复制</h3><p>mysql服务端修改配置并重启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog-format=ROW</span><br><span class="line">server_id=1</span><br><span class="line"></span><br><span class="line">$ mysql -uroot</span><br><span class="line">CREATE USER canal IDENTIFIED BY &apos;canal&apos;;  </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;canal&apos;@&apos;%&apos; ;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">$ sudo service mysqld start</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：创建canal用户的目的是什么？直接使用现有的用户名可以吗，比如root。<br>答案：有些用户没有REPLICATION SLAVE, REPLICATION CLIENT的权限，用这些用户连接canal时，无法获取到binlog。<br>这里的canal用户授权了全部权限，所以客户端可以从canal中获取binlog。</p>
</blockquote>
<p>明确两个概念：canal server连接mysql，客户端连接canal server。</p>
<ul>
<li>canal指的是canal server，它会读取mysql的binlog，解析后存储起来</li>
<li>客户端指的是消费canal server的binlog</li>
</ul>
<p>本机连接服务端，验证binlog的格式是ROW</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -h192.168.6.52 -ucanal -pcanal</span><br><span class="line">mysql&gt; show variables like &apos;%binlog_format%&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>mysql主从复制的原理：</p>
<ul>
<li>master将改变记录到二进制日志(binary log)中；</li>
<li>slave将master的binary log events拷贝到它的中继日志(relay log)；</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>
</ul>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20160914112042547" alt="mysql replication"></p>
<h3 id="binlog">binlog</h3><p>在启动canal之前，先来了解下什么是mysql的binlog:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events;</span><br><span class="line">| Log_name         | Pos   | Event_type  | Server_id | End_log_pos | Info                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |</span><br><span class="line">+------------------+-------+-------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| mysql-bin.000001 |     4 | Format_desc |         1 |         106 | Server ver: 5.1.73-log, Binlog ver: 4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |</span><br><span class="line">| mysql-bin.000001 |   106 | Query       |         1 |        1864 | use `mysql`; CREATE TABLE IF NOT EXISTS db (   Host char(60) binary DEFAULT &apos;&apos; NOT NULL, Db char(64) binary DEFAULT &apos;&apos; NOT NULL, User char(16) binary DEFAULT &apos;&apos; NOT NULL, Select_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Insert_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Update_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Delete_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Create_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Drop_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Grant_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, References_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Index_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Alter_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Create_tmp_table_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Lock_tables_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Create_view_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Show_view_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Create_routine_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Alter_routine_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Execute_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Event_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Trigger_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, PRIMARY KEY Host (Host,Db,User), KEY User (User) ) engine=MyISAM CHARACTER SET utf8 COLLATE utf8_bin comment=&apos;Database privileges&apos; |</span><br><span class="line">| mysql-bin.000001 |  1864 | Query       |         1 |        3518 | use `mysql`; CREATE TABLE IF NOT EXISTS host (  Host char(60) binary DEFAULT &apos;&apos; NOT NULL, Db char(64) binary DEFAULT &apos;&apos; NOT NULL, Select_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Insert_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Update_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Delete_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Create_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Drop_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Grant_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, References_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Index_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Alter_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Create_tmp_table_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Lock_tables_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Create_view_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Show_view_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Create_routine_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Alter_routine_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Execute_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, Trigger_priv enum(&apos;N&apos;,&apos;Y&apos;) COLLATE utf8_general_ci DEFAULT &apos;N&apos; NOT NULL, PRIMARY KEY Host (Host,Db) ) engine=MyISAM CHARACTER SET utf8 COLLATE utf8_bin comment=&apos;Host privileges;  Merged with database privileges&apos; |</span><br></pre></td></tr></table></figure>
<p>mysql数据文件下会生成mysql-bin.xxx的binlog文件，以及索引文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 canal]$ ll /var/lib/mysql/</span><br><span class="line">总用量 26228</span><br><span class="line">drwx------ 2 mysql mysql     4096 10月 11 14:05 canal_test</span><br><span class="line">-rw-rw---- 1 mysql mysql 10485760 9月  30 22:12 ibdata1</span><br><span class="line">-rw-rw---- 1 mysql mysql  5242880 10月 11 09:57 ib_logfile0</span><br><span class="line">-rw-rw---- 1 mysql mysql  5242880 10月 11 09:57 ib_logfile1</span><br><span class="line">drwx------ 2 mysql mysql     4096 8月   2 11:01 mysql</span><br><span class="line">-rw-rw---- 1 mysql mysql    18451 8月   2 11:01 mysql-bin.000001</span><br><span class="line">-rw-rw---- 1 mysql mysql   929226 8月   2 11:01 mysql-bin.000002</span><br><span class="line">-rw-rw---- 1 mysql mysql  4890698 9月  30 22:12 mysql-bin.000003</span><br><span class="line">-rw-rw---- 1 mysql mysql      897 10月 11 14:06 mysql-bin.000004</span><br><span class="line">-rw-rw---- 1 mysql mysql       76 10月 11 09:57 mysql-bin.index</span><br><span class="line">srwxrwxrwx 1 mysql mysql        0 10月 11 09:57 mysql.sock</span><br></pre></td></tr></table></figure>
<p>针对mysql的操作都会有二进制的事件记录到binlog文件中。下面的一些操作包括创建用户，授权，创建数据库，创建表，插入一条记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 canal]$ sudo strings /var/lib/mysql/mysql-bin.000004</span><br><span class="line">5.1.73-log</span><br><span class="line">CREATE USER canal IDENTIFIED BY &apos;canal&apos;</span><br><span class="line">root    localhost</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;canal&apos;@&apos;%&apos;</span><br><span class="line">FLUSH PRIVILEGES</span><br><span class="line">canal_test</span><br><span class="line">create database canal_test    ===》创建数据库</span><br><span class="line">canal_test</span><br><span class="line">create table test (   uid int (4) primary key not null auto_increment,   name varchar(10) not null)  ==》创建表</span><br><span class="line">canal_test</span><br><span class="line">BEGIN     ==》插入记录，这里有事务。但是没有把具体的语句打印出来</span><br><span class="line">canal_test</span><br><span class="line">test</span><br><span class="line">canal_test</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<h2 id="Canal_QuickStart">Canal QuickStart</h2><h3 id="canal_&amp;_config">canal &amp; config</h3><p>部署canal server到6.52，并启动。查看canal的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 canal]$ cat logs/canal/canal.log</span><br><span class="line">2017-10-11 11:31:52.076 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## start the canal server.</span><br><span class="line">2017-10-11 11:31:52.151 [main] INFO  com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[192.168.6.52:11111]</span><br><span class="line">2017-10-11 11:31:52.644 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## the canal server is running now ......</span><br></pre></td></tr></table></figure>
<p>查看instance的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 canal]$ cat logs/example/example.log</span><br><span class="line">2017-10-11 11:31:52.435 [main] INFO  c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [canal.properties]</span><br><span class="line">2017-10-11 11:31:52.444 [main] INFO  c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [example/instance.properties]</span><br><span class="line">2017-10-11 11:31:52.587 [main] INFO  c.a.otter.canal.instance.spring.CanalInstanceWithSpring - start CannalInstance for 1-example</span><br><span class="line">2017-10-11 11:31:52.599 [main] INFO  c.a.otter.canal.instance.core.AbstractCanalInstance - start successful....</span><br><span class="line">2017-10-11 11:31:52.679 [destination = example , address = /127.0.0.1:3306 , EventParser] WARN  c.a.otter.canal.parse.inbound.mysql.MysqlEventParser - prepare to find start position just show master status</span><br></pre></td></tr></table></figure>
<p>canal server的conf下有几个配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  canal.deployer-1.0.24 tree conf</span><br><span class="line">conf</span><br><span class="line">├── canal.properties</span><br><span class="line">├── example</span><br><span class="line">│   └── instance.properties</span><br><span class="line">├── logback.xml</span><br><span class="line">└── spring</span><br><span class="line">    ├── default-instance.xml</span><br><span class="line">    ├── file-instance.xml</span><br><span class="line">    ├── group-instance.xml</span><br><span class="line">    ├── local-instance.xml</span><br><span class="line">    └── memory-instance.xml</span><br></pre></td></tr></table></figure>
<p>先来看<code>canal.properties</code>的<strong>common</strong>属性前四个配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canal.id= 1</span><br><span class="line">canal.ip=</span><br><span class="line">canal.port= 11111</span><br><span class="line">canal.zkServers=</span><br></pre></td></tr></table></figure>
<p>canal.id是canal的编号，在集群环境下，不同canal的id不同，注意它和mysql的server_id不同。<br>ip这里不指定，默认为本机，比如上面是192.168.6.52，端口号是11111。zk用于canal cluster。</p>
<p>再看下<code>canal.properties</code>下<strong>destinations</strong>相关的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#################################################</span><br><span class="line">#########       destinations        ############# </span><br><span class="line">#################################################</span><br><span class="line">canal.destinations = example</span><br><span class="line">canal.conf.dir = ../conf</span><br><span class="line">canal.auto.scan = true</span><br><span class="line">canal.auto.scan.interval = 5</span><br><span class="line"></span><br><span class="line">canal.instance.global.mode = spring </span><br><span class="line">canal.instance.global.lazy = false</span><br><span class="line">canal.instance.global.spring.xml = classpath:spring/file-instance.xml</span><br></pre></td></tr></table></figure>
<p>这里的canal.destinations = example可以设置多个，比如example1,example2，<br>则需要创建对应的两个文件夹，并且每个文件夹下都有一个instance.properties文件。</p>
<p>全局的canal实例管理用spring，这里的<code>file-instance.xml</code>最终会实例化所有的destinations instances:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.alibaba.otter.canal.instance.spring.support.PropertyPlaceholderConfigurer&quot; lazy-init=&quot;false&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;ignoreResourceNotFound&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;systemPropertiesModeName&quot; value=&quot;SYSTEM_PROPERTIES_MODE_OVERRIDE&quot;/&gt;&lt;!-- 允许system覆盖 --&gt;</span><br><span class="line">    &lt;property name=&quot;locationNames&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;classpath:canal.properties&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;classpath:$&#123;canal.instance.destination:&#125;/instance.properties&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;instance&quot; class=&quot;com.alibaba.otter.canal.instance.spring.CanalInstanceWithSpring&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;destination&quot; value=&quot;$&#123;canal.instance.destination&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;eventParser&quot;&gt;&lt;ref local=&quot;eventParser&quot; /&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;eventSink&quot;&gt;&lt;ref local=&quot;eventSink&quot; /&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;eventStore&quot;&gt;&lt;ref local=&quot;eventStore&quot; /&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;metaManager&quot;&gt;&lt;ref local=&quot;metaManager&quot; /&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;alarmHandler&quot;&gt;&lt;ref local=&quot;alarmHandler&quot; /&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>比如<code>canal.instance.destination</code>等于example，就会加载<code>example/instance.properties</code>配置文件</p>
<p>example下instance.properties配置文件不需要修改。一个canal server可以运行多个canal instance。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#################################################</span><br><span class="line">## mysql serverId，这里的slaveId不能和myql集群中已有的server_id一样</span><br><span class="line">canal.instance.mysql.slaveId = 1234</span><br><span class="line"></span><br><span class="line"># position info 这里连接的是mysql master的地址。</span><br><span class="line">canal.instance.master.address = 127.0.0.1:3306</span><br><span class="line">canal.instance.master.journal.name = </span><br><span class="line">canal.instance.master.position = </span><br><span class="line">canal.instance.master.timestamp = </span><br><span class="line"></span><br><span class="line">#canal.instance.standby.address = </span><br><span class="line">#canal.instance.standby.journal.name =</span><br><span class="line">#canal.instance.standby.position = </span><br><span class="line">#canal.instance.standby.timestamp = </span><br><span class="line"></span><br><span class="line"># username/password</span><br><span class="line">canal.instance.dbUsername = canal</span><br><span class="line">canal.instance.dbPassword = canal</span><br><span class="line">canal.instance.defaultDatabaseName =</span><br><span class="line">canal.instance.connectionCharset = UTF-8</span><br><span class="line"></span><br><span class="line">canal.instance.filter.regex = .*\\..*</span><br><span class="line">canal.instance.filter.black.regex =  </span><br><span class="line">#################################################</span><br></pre></td></tr></table></figure>
<h3 id="simple_client">simple client</h3><p>在mysql上创建数据库，创建表，插入一条记录，再修改记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create database canal_test;</span><br><span class="line">use canal_test;</span><br><span class="line">create table test (   uid int (4) primary key not null auto_increment,   name varchar(10) not null);</span><br><span class="line">insert into test (name) values(&apos;10&apos;);</span><br></pre></td></tr></table></figure>
<p>修改<a href="https://github.com/alibaba/canal/blob/master/example/src/main/java/com/alibaba/otter/canal/example/SimpleCanalClientTest.java">客户端测试例子</a>的连接信息。其中example对应了canal实例的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleCanalClientTest extends AbstractCanalClientTest &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        String destination = &quot;example&quot;;</span><br><span class="line">        CanalConnector connector = CanalConnectors.newSingleConnector(</span><br><span class="line">            new InetSocketAddress(&quot;192.168.6.52&quot;, 11111), destination, &quot;canal&quot;, &quot;canal&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果连接有错误，客户端测试例子会立即结束，打印## stop the canal client。正常的话，终端不会退出，会一直运行。</p>
</blockquote>
<p>SimpleCanalClientTest控制台的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">****************************************************</span><br><span class="line">* Batch Id: [1] ,count : [2] , memsize : [263] , Time : 2017-10-11 14:06:06</span><br><span class="line">* Start : [mysql-bin.000004:396:1507701897000(2017-10-11 14:04:57)] </span><br><span class="line">* End : [mysql-bin.000004:491:1507701904000(2017-10-11 14:05:04)] </span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">----------------&gt; binlog[mysql-bin.000004:396] , name[canal_test,] , eventType : QUERY , executeTime : 1507701897000 , delay : 69710ms</span><br><span class="line"> sql ----&gt; create database canal_test</span><br><span class="line"></span><br><span class="line">----------------&gt; binlog[mysql-bin.000004:491] , name[canal_test,test] , eventType : CREATE , executeTime : 1507701904000 , delay : 62723ms</span><br><span class="line"> sql ----&gt; create table test (   uid int (4) primary key not null auto_increment,   name varchar(10) not null)</span><br></pre></td></tr></table></figure>
<p>插入一条记录：（其中uid和name的update都等于true）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">****************************************************</span><br><span class="line">* Batch Id: [2] ,count : [3] , memsize : [186] , Time : 2017-10-11 14:06:32</span><br><span class="line">* Start : [mysql-bin.000004:659:1507701989000(2017-10-11 14:06:29)] </span><br><span class="line">* End : [mysql-bin.000004:822:1507701989000(2017-10-11 14:06:29)] </span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">================&gt; binlog[mysql-bin.000004:659] , executeTime : 1507701989000 , delay : 3142ms</span><br><span class="line"> BEGIN ----&gt; Thread id: 11</span><br><span class="line">----------------&gt; binlog[mysql-bin.000004:785] , name[canal_test,test] , eventType : INSERT , executeTime : 1507701989000 , delay : 3154ms</span><br><span class="line">uid : 1    type=int(4)    update=true</span><br><span class="line">name : 10    type=varchar(10)    update=true</span><br><span class="line">----------------</span><br><span class="line"> END ----&gt; transaction id: 0</span><br><span class="line">================&gt; binlog[mysql-bin.000004:822] , executeTime : 1507701989000 , delay : 3179ms</span><br></pre></td></tr></table></figure>
<p>修改记录：（其中name的update等于true）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">****************************************************</span><br><span class="line">* Batch Id: [3] ,count : [3] , memsize : [202] , Time : 2017-10-11 14:49:11</span><br><span class="line">* Start : [mysql-bin.000004:897:1507704547000(2017-10-11 14:49:07)] </span><br><span class="line">* End : [mysql-bin.000004:1076:1507704547000(2017-10-11 14:49:07)] </span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">================&gt; binlog[mysql-bin.000004:897] , executeTime : 1507704547000 , delay : 4048ms</span><br><span class="line"> BEGIN ----&gt; Thread id: 13</span><br><span class="line">----------------&gt; binlog[mysql-bin.000004:1023] , name[canal_test,test] , eventType : UPDATE , executeTime : 1507704547000 , delay : 4059ms</span><br><span class="line">uid : 1    type=int(4)</span><br><span class="line">name : zqhxuyuan    type=varchar(10)    update=true</span><br><span class="line">----------------</span><br><span class="line"> END ----&gt; transaction id: 0</span><br><span class="line">================&gt; binlog[mysql-bin.000004:1076] , executeTime : 1507704547000 , delay : 4096ms</span><br></pre></td></tr></table></figure>
<p>canal安装包下的example instance下除了example.log外，还有一个<code>meta.log</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 canal]$ cat logs/example/meta.log</span><br><span class="line">2017-10-11 14:06:03.728 - clientId:1001 cursor:[mysql-bin.000004,396,1507701897000] address[/127.0.0.1:3306]</span><br><span class="line">2017-10-11 14:06:04.589 - clientId:1001 cursor:[mysql-bin.000004,491,1507701904000] address[localhost/127.0.0.1:3306]</span><br><span class="line">2017-10-11 14:06:29.589 - clientId:1001 cursor:[mysql-bin.000004,822,1507701989000] address[localhost/127.0.0.1:3306]</span><br><span class="line">2017-10-11 14:49:08.589 - clientId:1001 cursor:[mysql-bin.000004,1076,1507704547000] address[localhost/127.0.0.1:3306]</span><br></pre></td></tr></table></figure>
<h2 id="Cannal_Internal_Overview">Cannal Internal Overview</h2><h3 id="canal_client_&amp;_server">canal client &amp; server</h3><p><a href="https://github.com/alibaba/canal/blob/master/example/src/main/java/com/alibaba/otter/canal/example/AbstractCanalClientTest.java">canal client</a>与canal server之间是C/S模式的通信，客户端采用NIO，服务端采用Netty。<br>canal server启动后，如果没有canal client，那么canal server不会去mysql拉取binlog。<br>即Canal客户端主动发起拉取请求，服务端才会模拟一个MySQL Slave节点去主节点拉取binlog。<br>通常Canal客户端是一个死循环，这样客户端一直调用get方法，服务端也就会一直拉取binlog。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractCanalClientTest &#123;</span><br><span class="line">    protected void process() &#123;</span><br><span class="line">        int batchSize = 5 * 1024; // 一次请求拉取多条记录</span><br><span class="line">        try &#123;</span><br><span class="line">            connector.connect(); // 先连接服务端</span><br><span class="line">            connector.subscribe(); // 订阅</span><br><span class="line">            // keep send request to canal server, thus canal server can fetch binlog from mysql</span><br><span class="line">            while (running) &#123; </span><br><span class="line">                Message message = connector.getWithoutAck(batchSize); // 获取指定数量的数据</span><br><span class="line">                long batchId = message.getId();</span><br><span class="line">                int size = message.getEntries().size();</span><br><span class="line">                printSummary(message, batchId, size);</span><br><span class="line">                printEntry(message.getEntries());</span><br><span class="line">                connector.ack(batchId); // 提交确认</span><br><span class="line">                //connector.rollback(batchId); // 处理失败, 回滚数据</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>canal client与canal server之间属于增量订阅/消费，流程图如下：（其中C端是canal client，S端是canal server）</p>
<p><img src="https://camo.githubusercontent.com/db1debcfa50f4ebea1f56a1fa0e18a4e960cafcc/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333239372f39643765643133652d366138362d333836642d393266342d3835323233386334373562662e6a7067" alt="canal protocol"></p>
<p>canal client调用<a href="https://github.com/alibaba/canal/blob/master/client/src/main/java/com/alibaba/otter/canal/client/impl/SimpleCanalConnector.java#L129"><code>connect()</code></a>方法时，发送的数据包（PacketType）类型为：</p>
<ol>
<li><a href="https://github.com/alibaba/canal/blob/master/server/src/main/java/com/alibaba/otter/canal/server/netty/handler/HandshakeInitializationHandler.java"><strong>HANDSHAKE</strong></a>，</li>
<li><a href="https://github.com/alibaba/canal/blob/master/server/src/main/java/com/alibaba/otter/canal/server/netty/handler/ClientAuthenticationHandler.java"><strong>CLIENTAUTHENTICATION</strong></a>。</li>
</ol>
<p>canal client调用<code>subscribe()</code>方法，类型为[<strong>SUBSCRIPTION</strong>]。</p>
<p>对应服务端采用netty处理RPC请求（<a href="https://github.com/alibaba/canal/blob/master/server/src/main/java/com/alibaba/otter/canal/server/netty/CanalServerWithNetty.java"><code>CanalServerWithNetty</code></a>）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class CanalServerWithNetty extends AbstractCanalLifeCycle implements CanalServer &#123;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">            public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line">                ChannelPipeline pipelines = Channels.pipeline();</span><br><span class="line">                pipelines.addLast(FixedHeaderFrameDecoder.class.getName(), new FixedHeaderFrameDecoder());</span><br><span class="line">                // 处理客户端的HANDSHAKE请求</span><br><span class="line">                pipelines.addLast(HandshakeInitializationHandler.class.getName(),</span><br><span class="line">                    new HandshakeInitializationHandler(childGroups));</span><br><span class="line">                // 处理客户端的CLIENTAUTHENTICATION请求</span><br><span class="line">                pipelines.addLast(ClientAuthenticationHandler.class.getName(),</span><br><span class="line">                    new ClientAuthenticationHandler(embeddedServer));</span><br><span class="line"></span><br><span class="line">                // 处理客户端的会话请求，包括SUBSCRIPTION，GET等</span><br><span class="line">                SessionHandler sessionHandler = new SessionHandler(embeddedServer);</span><br><span class="line">                pipelines.addLast(SessionHandler.class.getName(), sessionHandler);</span><br><span class="line">                return pipelines;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClientAuthenticationHandler处理鉴权后，会移除HandshakeInitializationHandler和<a href="https://github.com/alibaba/canal/blob/master/server/src/main/java/com/alibaba/otter/canal/server/netty/handler/ClientAuthenticationHandler.java#L81">ClientAuthenticationHandler</a>。<br>最重要的是会话处理器<a href="https://github.com/alibaba/canal/blob/master/server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java"><strong>SessionHandler</strong></a>。</p>
<p>以client发送GET，server从mysql得到binlog后，返回<strong>MESSAGES</strong>给client为例，说明client和server的rpc交互过程：</p>
<p>SimpleCanalConnector发送<a href="https://github.com/alibaba/canal/blob/master/client/src/main/java/com/alibaba/otter/canal/client/impl/SimpleCanalConnector.java#L272"><strong>GET</strong></a>请求，并读取响应结果的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public Message getWithoutAck(int batchSize, Long timeout, TimeUnit unit) throws CanalClientException &#123;</span><br><span class="line">    waitClientRunning();</span><br><span class="line">    int size = (batchSize &lt;= 0) ? 1000 : batchSize;</span><br><span class="line">    long time = (timeout == null || timeout &lt; 0) ? -1 : timeout; // -1代表不做timeout控制</span><br><span class="line">    if (unit == null) unit = TimeUnit.MILLISECONDS;</span><br><span class="line"></span><br><span class="line">    // client发送GET请求</span><br><span class="line">    writeWithHeader(Packet.newBuilder()</span><br><span class="line">        .setType(PacketType.GET)</span><br><span class="line">        .setBody(Get.newBuilder()</span><br><span class="line">            .setAutoAck(false)</span><br><span class="line">            .setDestination(clientIdentity.getDestination())</span><br><span class="line">            .setClientId(String.valueOf(clientIdentity.getClientId()))</span><br><span class="line">            .setFetchSize(size)</span><br><span class="line">            .setTimeout(time)</span><br><span class="line">            .setUnit(unit.ordinal())</span><br><span class="line">            .build()</span><br><span class="line">            .toByteString())</span><br><span class="line">        .build()</span><br><span class="line">        .toByteArray());</span><br><span class="line">    // client获取GET结果    </span><br><span class="line">    return receiveMessages();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Message receiveMessages() throws IOException &#123;</span><br><span class="line">    // 读取server发送的数据包</span><br><span class="line">    Packet p = Packet.parseFrom(readNextPacket());</span><br><span class="line">    switch (p.getType()) &#123;</span><br><span class="line">        case MESSAGES: &#123;</span><br><span class="line">            Messages messages = Messages.parseFrom(p.getBody());</span><br><span class="line">            Message result = new Message(messages.getBatchId());</span><br><span class="line">            for (ByteString byteString : messages.getMessagesList()) &#123;</span><br><span class="line">                result.addEntry(Entry.parseFrom(byteString));</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端SessionHandler处理客户端发送的<a href="https://github.com/alibaba/canal/blob/master/server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java#L105"><strong>GET</strong></a>请求流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">case GET:</span><br><span class="line">    // 读取客户端发送的数据包，封装为Get对象</span><br><span class="line">    Get get = CanalPacket.Get.parseFrom(packet.getBody());</span><br><span class="line">    // destination表示canal instance</span><br><span class="line">    if (StringUtils.isNotEmpty(get.getDestination()) &amp;&amp; StringUtils.isNotEmpty(get.getClientId())) &#123;</span><br><span class="line">        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));</span><br><span class="line">        Message message = null;</span><br><span class="line">        if (get.getTimeout() == -1) &#123;// 是否是初始值</span><br><span class="line">            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            TimeUnit unit = convertTimeUnit(get.getUnit());</span><br><span class="line">            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize(), get.getTimeout(), unit);</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置返回给客户端的数据包类型为MESSAGES   </span><br><span class="line">        Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();</span><br><span class="line">        packetBuilder.setType(PacketType.MESSAGES);</span><br><span class="line">        // 构造Message</span><br><span class="line">        Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();</span><br><span class="line">        messageBuilder.setBatchId(message.getId());</span><br><span class="line">        if (message.getId() != -1 &amp;&amp; !CollectionUtils.isEmpty(message.getEntries())) &#123;</span><br><span class="line">            for (Entry entry : message.getEntries()) &#123;</span><br><span class="line">                messageBuilder.addMessages(entry.toByteString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        packetBuilder.setBody(messageBuilder.build().toByteString());</span><br><span class="line">        // 输出数据，返回给客户端</span><br><span class="line">        NettyUtils.write(ctx.getChannel(), packetBuilder.build().toByteArray(), null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>get/ack/rollback协议介绍：</p>
<ul>
<li><code>Message getWithoutAck(int batchSize)</code>，允许指定batchSize，一次可以获取多条，每次返回的对象为Message，包含的内容为：<br>– batch id 唯一标识<br>– entries 具体的数据对象，对应的数据对象格式：<a href="https://github.com/alibaba/canal/blob/master/protocol/src/main/java/com/alibaba/otter/canal/protocol/EntryProtocol.proto">EntryProtocol.proto</a></li>
<li><a href="https://github.com/alibaba/canal/blob/master/client/src/main/java/com/alibaba/otter/canal/client/impl/SimpleCanalConnector.java#L325"><code>void rollback(long batchId)</code></a>，回滚上次的get请求，重新获取数据。基于get获取的batchId进行提交，避免误操作</li>
<li><a href="https://github.com/alibaba/canal/blob/master/client/src/main/java/com/alibaba/otter/canal/client/impl/SimpleCanalConnector.java#L343"><code>void ack(long batchId)</code></a>，确认已经消费成功，通知server删除数据。基于get获取的batchId进行提交，避免误操作</li>
</ul>
<p>EntryProtocol.protod对应的canal消息结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Entry  </span><br><span class="line">    Header  </span><br><span class="line">        logfileName [binlog文件名]  </span><br><span class="line">        logfileOffset [binlog position]  </span><br><span class="line">        executeTime [binlog里记录变更发生的时间戳,精确到秒]  </span><br><span class="line">        schemaName   </span><br><span class="line">        tableName  </span><br><span class="line">        eventType [insert/update/delete类型]  </span><br><span class="line">    entryType   [事务头BEGIN/事务尾END/数据ROWDATA]  </span><br><span class="line">    storeValue  [byte数据,可展开，对应的类型为RowChange]  </span><br><span class="line">      </span><br><span class="line">RowChange  </span><br><span class="line">    isDdl       [是否是ddl变更操作，比如create table/drop table]  </span><br><span class="line">    sql         [具体的ddl sql]  </span><br><span class="line">    rowDatas    [具体insert/update/delete的变更数据，可为多条，1个binlog event事件可对应多条变更，比如批处理]  </span><br><span class="line">        beforeColumns [Column类型的数组，变更前的数据字段]  </span><br><span class="line">        afterColumns [Column类型的数组，变更后的数据字段]  </span><br><span class="line">          </span><br><span class="line">Column   </span><br><span class="line">    index         </span><br><span class="line">    sqlType     [jdbc type]  </span><br><span class="line">    name        [column name]  </span><br><span class="line">    isKey       [是否为主键]  </span><br><span class="line">    updated     [是否发生过变更]  </span><br><span class="line">    isNull      [值是否为null]  </span><br><span class="line">    value       [具体的内容，注意为string文本]</span><br></pre></td></tr></table></figure>
<p>SessionHandler中服务端处理客户端的其他类型请求，都会调用<a href="https://github.com/alibaba/canal/blob/master/server/src/main/java/com/alibaba/otter/canal/server/embedded/CanalServerWithEmbedded.java">CanalServerWithEmbedded</a>的相关方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case SUBSCRIPTION:</span><br><span class="line">        Sub sub = Sub.parseFrom(packet.getBody());</span><br><span class="line">        embeddedServer.subscribe(clientIdentity);</span><br><span class="line">case GET:</span><br><span class="line">        Get get = CanalPacket.Get.parseFrom(packet.getBody());</span><br><span class="line">        message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());</span><br><span class="line">case CLIENTACK:</span><br><span class="line">        ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());</span><br><span class="line">        embeddedServer.ack(clientIdentity, ack.getBatchId());</span><br><span class="line">case CLIENTROLLBACK:</span><br><span class="line">        ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());</span><br><span class="line">        embeddedServer.rollback(clientIdentity);// 回滚所有批次</span><br></pre></td></tr></table></figure>
<p>所以真正的处理逻辑在CanalServerWithEmbedded中，下面重点来了。。。</p>
<h3 id="CanalServerWithEmbedded">CanalServerWithEmbedded</h3><p>CanalServer包含多个Instance，它的成员变量<code>canalInstances</code>记录了instance名称与<a href="https://github.com/alibaba/canal/blob/master/instance/core/src/main/java/com/alibaba/otter/canal/instance/core/AbstractCanalInstance.java">实例</a>的映射关系。<br>因为是一个Map，所以同一个Server不允许出现相同instance名称（本例中实例名称为example），<br>比如不能同时有两个example在一个server上。但是允许一个Server上有example1和example2。</p>
<blockquote>
<p>注意：<code>CanalServer</code>中最重要的是<code>CanalServerWithEmbedded</code>，而CanalServerWithEmbedded中最重要的是<code>CanalInstance</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class CanalServerWithEmbedded extends AbstractCanalLifeCycle implements CanalServer, CanalService &#123;</span><br><span class="line">    private Map&lt;String, CanalInstance&gt; canalInstances;</span><br><span class="line">    private CanalInstanceGenerator     canalInstanceGenerator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图表示一个server配置了两个Canal实例（instance），每个Client连接一个Instance。<br>每个Canal实例模拟为一个MySQL的slave，所以每个Instance的slaveId必须不一样。<br>比如图中两个Instance的id分别是1234和1235，它们都会拉取MySQL主节点的binlog。</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011202259253" alt="instances"></p>
<p>这里每个Canal Client都对应一个Instance，每个Client在启动时，<br>都会指定一个Destination，这个Destination就表示Instance的名称。<br>所以CanalServerWithEmbedded处理各种请求时的参数都有ClientIdentity，<br>从ClientIdentity中获取destination，就可以获取出对应的CanalInstance。</p>
<p>理解下各个组件的对应关系：</p>
<ul>
<li>Canal Client通过destination找出Canal Server中对应的Canal Instance。</li>
<li>一个Canal Server可以配置多个Canal Instances。</li>
</ul>
<p>下面以CanalServerWithEmbedded的订阅方法为例：</p>
<ol>
<li>根据客户端标识获取CanalInstance</li>
<li>向CanalInstance的元数据管理器订阅当前客户端</li>
<li>从元数据管理中获取客户端的游标</li>
<li>通知CanalInstance订阅关系发生变化</li>
</ol>
<blockquote>
<p>注意：提供订阅方法的作用是：MySQL新增了一张表，客户端原先没有同步这张表，现在需要同步，所以需要重新订阅。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void subscribe(ClientIdentity clientIdentity) throws CanalServerException &#123;</span><br><span class="line">    // ClientIdentity表示Canal Client客户端，从中可以获取出客户端指定连接的Destination</span><br><span class="line">    // 由于CanalServerWithEmbedded记录了每个Destination对应的Instance，可以获取客户端对应的Instance</span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    if (!canalInstance.getMetaManager().isStart()) &#123;</span><br><span class="line">        canalInstance.getMetaManager().start(); // 启动Instance的元数据管理器</span><br><span class="line">    &#125;</span><br><span class="line">    canalInstance.getMetaManager().subscribe(clientIdentity); // 执行一下meta订阅</span><br><span class="line">    Position position = canalInstance.getMetaManager().getCursor(clientIdentity);</span><br><span class="line">    if (position == null) &#123;</span><br><span class="line">        position = canalInstance.getEventStore().getFirstPosition();// 获取一下store中的第一条</span><br><span class="line">        if (position != null) &#123;</span><br><span class="line">            canalInstance.getMetaManager().updateCursor(clientIdentity, position); // 更新一下cursor</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 通知下订阅关系变化</span><br><span class="line">    canalInstance.subscribeChange(clientIdentity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个CanalInstance中包括了四个组件：<strong>EventParser、EventSink、EventStore、MetaManager</strong>。</p>
<p>服务端主要的处理方法包括get/ack/rollback，这三个方法都会用到Instance上面的几个内部组件，主要还是EventStore和MetaManager：</p>
<p>在这之前，要先理解EventStore的含义，EventStore是一个RingBuffer，有三个指针：<strong>Put、Get、Ack</strong>。</p>
<ul>
<li>Put: Canal Server从MySQL拉取到数据后，放到内存中，Put增加</li>
<li>Get: 消费者（Canal Client）从内存中消费数据，Get增加</li>
<li>Ack: 消费者消费完成，Ack增加。并且会删除Put中已经被Ack的数据</li>
</ul>
<p>这三个操作与Instance组件的关系如下：</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011211529169" alt="ops"></p>
<p>客户端通过canal server获取mysql binlog有几种方式（get方法和getWithoutAck）：</p>
<ul>
<li>如果timeout为null，则采用tryGet方式，即时获取  </li>
<li>如果timeout不为null  <ol>
<li>timeout为0，则采用get阻塞方式，获取数据，不设置超时，直到有足够的batchSize数据才返回  </li>
<li>timeout不为0，则采用get+timeout方式，获取数据，超时还没有batchSize足够的数据，有多少返回多少  </li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Events&lt;Event&gt; getEvents(CanalEventStore eventStore, Position start, int batchSize, Long timeout,</span><br><span class="line">                                TimeUnit unit) &#123;</span><br><span class="line">    if (timeout == null) &#123;</span><br><span class="line">        return eventStore.tryGet(start, batchSize); // 即时获取</span><br><span class="line">    &#125; else if (timeout &lt;= 0)&#123;</span><br><span class="line">        return eventStore.get(start, batchSize); // 阻塞获取</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return eventStore.get(start, batchSize, timeout, unit); // 异步获取</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：EventStore的实现采用了类似Disruptor的RingBuffer环形缓冲区。RingBuffer的实现类是MemoryEventStoreWithBuffer</p>
</blockquote>
<p>get方法和getWithoutAck方法的区别是：</p>
<ul>
<li>get方法会立即调用ack</li>
<li>getWithoutAck方法不会调用ack</li>
</ul>
<h3 id="EventStore">EventStore</h3><p>以10条数据为例，初始时current=-1，第一个元素起始next=0，end=9，循环<code>[0,9]</code>所有元素。<br>List元素为(A,B,C,D,E,F,G,H,I,J)</p>
<table>
<thead>
<tr>
<th>next</th>
<th>entries[next]</th>
<th>next-current-1</th>
<th>list element</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>entries[0]</td>
<td>0-(-1)-1=0</td>
<td>A</td>
</tr>
<tr>
<td>1</td>
<td>entries[1]</td>
<td>1-(-1)-1=1</td>
<td>B</td>
</tr>
<tr>
<td>2</td>
<td>entries[2]</td>
<td>2-(-1)-1=2</td>
<td>C</td>
</tr>
<tr>
<td>3</td>
<td>entries[3]</td>
<td>3-(-1)-1=3</td>
<td>D</td>
</tr>
<tr>
<td>.</td>
<td>……….</td>
<td>……….</td>
<td>.</td>
</tr>
<tr>
<td>9</td>
<td>entries[9]</td>
<td>9-(-1)-1=9</td>
<td>J</td>
</tr>
</tbody>
</table>
<p>第一批10个元素put完成后，putSequence设置为end=9。假设第二批又Put了5个元素:(K,L,M,N,O)</p>
<p>current=9，起始next=9+1=10，end=9+5=14，在Put完成后，putSequence设置为end=14。</p>
<table>
<thead>
<tr>
<th>next</th>
<th>entries[next]</th>
<th>next-current-1</th>
<th>list element</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>entries[10]</td>
<td>10-(9)-1=0</td>
<td>K</td>
</tr>
<tr>
<td>11</td>
<td>entries[11]</td>
<td>11-(9)-1=1</td>
<td>L</td>
</tr>
<tr>
<td>12</td>
<td>entries[12]</td>
<td>12-(9)-1=2</td>
<td>M</td>
</tr>
<tr>
<td>13</td>
<td>entries[13]</td>
<td>13-(9)-1=3</td>
<td>N</td>
</tr>
<tr>
<td>14</td>
<td>entries[14]</td>
<td>14-(9)-1=3</td>
<td>O</td>
</tr>
</tbody>
</table>
<p>这里假设环形缓冲区的最大大小为15个（源码中是16MB），那么上面两批一共产生了15个元素，刚好填满了环形缓冲区。<br>如果又有Put事件进来，由于环形缓冲区已经满了，没有可用的slot，则Put操作会被阻塞，直到被消费掉。</p>
<p>下面是Put填充环形缓冲区的代码，检查可用slot（checkFreeSlotAt方法）在几个put方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MemoryEventStoreWithBuffer extends AbstractCanalStoreScavenge implements CanalEventStore&lt;Event&gt;, CanalStoreScavenge &#123;</span><br><span class="line">    private static final long INIT_SQEUENCE = -1;</span><br><span class="line">    private int               bufferSize    = 16 * 1024;</span><br><span class="line">    private int               bufferMemUnit = 1024;                         // memsize的单位，默认为1kb大小</span><br><span class="line">    private int               indexMask;</span><br><span class="line">    private Event[]           entries;</span><br><span class="line"></span><br><span class="line">    // 记录下put/get/ack操作的三个下标</span><br><span class="line">    private AtomicLong        putSequence   = new AtomicLong(INIT_SQEUENCE); // 代表当前put操作最后一次写操作发生的位置</span><br><span class="line">    private AtomicLong        getSequence   = new AtomicLong(INIT_SQEUENCE); // 代表当前get操作读取的最后一条的位置</span><br><span class="line">    private AtomicLong        ackSequence   = new AtomicLong(INIT_SQEUENCE); // 代表当前ack操作的最后一条的位置</span><br><span class="line"></span><br><span class="line">    // 启动EventStore时，创建指定大小的缓冲区，Event数组的大小是16*1024</span><br><span class="line">    // 也就是说算个数的话，数组可以容纳16000个事件。算内存的话，大小为16MB</span><br><span class="line">    public void start() throws CanalStoreException &#123;</span><br><span class="line">        super.start();</span><br><span class="line">        indexMask = bufferSize - 1;</span><br><span class="line">        entries = new Event[bufferSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // EventParser解析后，会放入内存中（Event数组，缓冲区）</span><br><span class="line">    private void doPut(List&lt;Event&gt; data) &#123;</span><br><span class="line">        long current = putSequence.get(); // 取得当前的位置，初始时为-1，第一个元素为-1+1=0</span><br><span class="line">        long end = current + data.size(); // 最末尾的位置，假设Put了10条数据，end=-1+10=9</span><br><span class="line">        // 先写数据，再更新对应的cursor,并发度高的情况，putSequence会被get请求可见，拿出了ringbuffer中的老的Entry值</span><br><span class="line">        for (long next = current + 1; next &lt;= end; next++) &#123;</span><br><span class="line">            entries[getIndex(next)] = data.get((int) (next - current - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        putSequence.set(end);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Put是生产数据，Get是消费数据，Get一定不会超过Put。比如Put了10条数据，Get最多只能获取到10条数据。但有时候为了保证Get处理的速度，Put和Get并不会相等。<br>可以把Put看做是生产者，Get看做是消费者。生产者速度可以很快，消费者则可以慢慢地消费。比如Put了1000条，而Get我们只需要每次处理10条数据。</p>
<p>仍然以前面的示例来说明Get的流程，初始时current=-1，假设Put了两批数据一共15条，maxAbleSequence=14，而Get的BatchSize假设为10。<br>初始时next=current=-1，end=-1。通过startPosition，会设置next=0。最后end又被赋值为9，即循环缓冲区[0,9]一共10个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private Events&lt;Event&gt; doGet(Position start, int batchSize) throws CanalStoreException &#123;</span><br><span class="line">    LogPosition startPosition = (LogPosition) start;</span><br><span class="line"></span><br><span class="line">    long current = getSequence.get();</span><br><span class="line">    long maxAbleSequence = putSequence.get();</span><br><span class="line">    long next = current;</span><br><span class="line">    long end = current;</span><br><span class="line">    // 如果startPosition为null，说明是第一次，默认+1处理</span><br><span class="line">    if (startPosition == null || !startPosition.getPostion().isIncluded()) &#123; // 第一次订阅之后，需要包含一下start位置，防止丢失第一条记录</span><br><span class="line">        next = next + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end = (next + batchSize - 1) &lt; maxAbleSequence ? (next + batchSize - 1) : maxAbleSequence;</span><br><span class="line">    // 提取数据并返回</span><br><span class="line">    for (; next &lt;= end; next++) &#123;</span><br><span class="line">        Event event = entries[getIndex(next)];</span><br><span class="line">        if (ddlIsolation &amp;&amp; isDdl(event.getEntry().getHeader().getEventType())) &#123;</span><br><span class="line">            // 如果是ddl隔离，直接返回</span><br><span class="line">            if (entrys.size() == 0) &#123;</span><br><span class="line">                entrys.add(event);// 如果没有DML事件，加入当前的DDL事件</span><br><span class="line">                end = next; // 更新end为当前</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果之前已经有DML事件，直接返回了，因为不包含当前next这记录，需要回退一个位置</span><br><span class="line">                end = next - 1; // next-1一定大于current，不需要判断</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            entrys.add(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理PositionRange，然后设置getSequence为end</span><br><span class="line">    getSequence.compareAndSet(current, end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ack操作的上限是Get，假设Put了15条数据，Get了10条数据，最多也只能Ack10条数据。Ack的目的是清空缓冲区中已经被Get过的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void ack(Position position) throws CanalStoreException &#123;</span><br><span class="line">    cleanUntil(position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void cleanUntil(Position position) throws CanalStoreException &#123;</span><br><span class="line">    long sequence = ackSequence.get();</span><br><span class="line">    long maxSequence = getSequence.get();</span><br><span class="line"></span><br><span class="line">    boolean hasMatch = false;</span><br><span class="line">    long memsize = 0;</span><br><span class="line">    for (long next = sequence + 1; next &lt;= maxSequence; next++) &#123;</span><br><span class="line">        Event event = entries[getIndex(next)];</span><br><span class="line">        memsize += calculateSize(event);</span><br><span class="line">        boolean match = CanalEventUtils.checkPosition(event, (LogPosition) position);</span><br><span class="line">        if (match) &#123;// 找到对应的position，更新ack seq</span><br><span class="line">            hasMatch = true;</span><br><span class="line"></span><br><span class="line">            if (batchMode.isMemSize()) &#123;</span><br><span class="line">                ackMemSize.addAndGet(memsize);</span><br><span class="line">                // 尝试清空buffer中的内存，将ack之前的内存全部释放掉</span><br><span class="line">                for (long index = sequence + 1; index &lt; next; index++) &#123;</span><br><span class="line">                    entries[getIndex(index)] = null;// 设置为null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ackSequence.compareAndSet(sequence, next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rollback回滚方法的实现则比较简单，将getSequence回退到ack位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void rollback() throws CanalStoreException &#123;</span><br><span class="line">    getSequence.set(ackSequence.get());</span><br><span class="line">    getMemSize.set(ackMemSize.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图展示了RingBuffer的几个操作示例：</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011225116791" alt="ringbuffer"></p>
<h3 id="EventParser_WorkFlow">EventParser WorkFlow</h3><p>EventStore负责存储解析后的Binlog事件，而解析动作负责拉取Binlog，它的流程比较复杂。需要和MetaManager进行交互。<br>比如要记录每次拉取的Position，这样下一次就可以从上一次的最后一个位置继续拉取。所以MetaManager应该是有状态的。</p>
<p>EventParser的流程如下：</p>
<ol>
<li>Connection获取上一次解析成功的位置 (如果第一次启动，则获取初始指定的位置或者是当前数据库的binlog位点)</li>
<li>Connection建立链接，发送BINLOG_DUMP指令</li>
<li>Mysql开始推送Binaly Log</li>
<li>接收到的Binaly Log的通过Binlog parser进行协议解析，补充一些特定信息</li>
<li>传递给EventSink模块进行数据存储，是一个阻塞操作，直到存储成功</li>
<li>存储成功后，定时记录Binaly Log位置</li>
</ol>
<p><img src="https://camo.githubusercontent.com/031db3aa27461d13faa2dea479ef639f93386a00/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333134332f37393531633136392d663764662d336362332d616562622d6439323466353733313163622e6a7067" alt="parser"></p>
<p>上面提到的Connection指的是实现了<code>ErosaConnection</code>接口的<code>MysqlConnection</code>。<br><code>EventParser</code>的实现类是实现了<code>AbstractEventParser</code>的<code>MysqlEventParser</code>。</p>
<p><code>EventParser</code>解析binlog后通过<code>EventSink</code>写入到<code>EventStore</code>，这条链路可以通过EventStore的put方法串联起来：</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011234800632" alt="put"></p>
<p>其实这里还有一个EventTransactionBuffer缓冲区，即Parser解析后先放到缓冲区中，<br>当事务发生时或者数据超过阈值，就会执行刷新操作：即消费缓冲区的数据，放到EventStore中。<br>这个缓冲区有两个偏移量指针：putSequence和flushSequence。</p>
<h2 id="Canal_HA">Canal HA</h2><p>单机模拟两个Canal Server，将单机模式复制出两个文件夹，并修改相关配置</p>
<p>canal_m/conf/canal.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">canal.id= 2</span><br><span class="line">canal.ip=</span><br><span class="line">canal.port= 11112</span><br><span class="line">canal.zkServers=localhost:2181</span><br><span class="line">canal.instance.global.spring.xml = classpath:spring/default-instance.xml</span><br></pre></td></tr></table></figure>
<p>canal_m/conf/example/instance.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canal.instance.mysql.slaveId = 1235</span><br></pre></td></tr></table></figure>
<p>canal_s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">canal.id= 3</span><br><span class="line">canal.ip=</span><br><span class="line">canal.port= 11113</span><br><span class="line">canal.zkServers=localhost:2181</span><br><span class="line">canal.instance.global.spring.xml = classpath:spring/default-instance.xml</span><br></pre></td></tr></table></figure>
<p>canal_s/conf/example/instance.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canal.instance.mysql.slaveId = 1236</span><br></pre></td></tr></table></figure>
<p>启动canal_m</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-10-12 14:51:45.202 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## start the canal server.</span><br><span class="line">2017-10-12 14:51:45.776 [main] INFO  com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[192.168.6.52:11112]</span><br><span class="line">2017-10-12 14:51:46.687 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## the canal server is running now ......</span><br></pre></td></tr></table></figure>
<p>启动canal_s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-10-12 14:52:18.999 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## start the canal server.</span><br><span class="line">2017-10-12 14:52:19.208 [main] INFO  com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[192.168.6.52:11113]</span><br><span class="line">2017-10-12 14:52:19.364 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## the canal server is running now ......</span><br></pre></td></tr></table></figure>
<p>master提供服务，canal_m/logs/example/example.log下有日志，而canal_s/logs没有example文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 ~]$ tail -f canal_m/logs/example/example.log</span><br><span class="line">2017-10-12 14:51:46.453 [main] INFO  c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [canal.properties]</span><br><span class="line">2017-10-12 14:51:46.463 [main] INFO  c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [example/instance.properties]</span><br><span class="line">2017-10-12 14:51:46.624 [main] INFO  c.a.otter.canal.instance.spring.CanalInstanceWithSpring - start CannalInstance for 1-example</span><br><span class="line">2017-10-12 14:51:46.644 [main] INFO  c.a.otter.canal.instance.core.AbstractCanalInstance - start successful....</span><br><span class="line">2017-10-12 14:51:46.658 [destination = example , address = /127.0.0.1:3306 , EventParser] WARN  c.a.otter.canal.parse.inbound.mysql.MysqlEventParser - prepare to find start position just show master status</span><br></pre></td></tr></table></figure>
<p>查看Canal HA记录在ZK的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 7] ls /otter/canal/destinations/example/cluster</span><br><span class="line">[192.168.6.52:11112, 192.168.6.52:11113]</span><br><span class="line"></span><br><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 10] get /otter/canal/destinations/example/running</span><br><span class="line">&#123;&quot;active&quot;:true,&quot;address&quot;:&quot;192.168.6.52:11112&quot;,&quot;cid&quot;:2&#125;</span><br></pre></td></tr></table></figure>
<p>启动example的<a href="https://github.com/alibaba/canal/blob/master/example/src/main/java/com/alibaba/otter/canal/example/ClusterCanalClientTest.java">ClusterCanalClientTest</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CanalConnector connector = CanalConnectors.newClusterConnector(&quot;192.168.6.52:2181&quot;, destination, &quot;canal&quot;, &quot;canal&quot;);</span><br></pre></td></tr></table></figure>
<p>执行SQL：<code>update test set name = &#39;zqh&#39; where uid=1;</code>，控制台打印日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">****************************************************</span><br><span class="line">* Batch Id: [1] ,count : [3] , memsize : [203] , Time : 2017-10-12 15:05:20</span><br><span class="line">* Start : [mysql-bin.000004:1151:1507791918000(2017-10-12 15:05:18)] </span><br><span class="line">* End : [mysql-bin.000004:1331:1507791918000(2017-10-12 15:05:18)] </span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">================&gt; binlog[mysql-bin.000004:1151] , executeTime : 1507791918000 , delay : 2080ms</span><br><span class="line"> BEGIN ----&gt; Thread id: 763</span><br><span class="line">----------------&gt; binlog[mysql-bin.000004:1277] , name[canal_test,test] , eventType : UPDATE , executeTime : 1507791918000 , delay : 2092ms</span><br><span class="line">uid : 1    type=int(4)</span><br><span class="line">name : zqh    type=varchar(10)    update=true</span><br><span class="line">----------------</span><br><span class="line"> END ----&gt; transaction id: 0</span><br><span class="line">================&gt; binlog[mysql-bin.000004:1331] , executeTime : 1507791918000 , delay : 2130ms</span><br></pre></td></tr></table></figure>
<p>再次查看ZK中记录的客户端信息：</p>
<ul>
<li>一个Instance对应一个Client，这里的Instance名称为example，对应的客户端编号是1001</li>
<li>为了验证Instance确实是由指定的Client连接，在Server上查看11112端口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 18] get /otter/canal/destinations/example/1001/running</span><br><span class="line">&#123;&quot;active&quot;:true,&quot;address&quot;:&quot;10.57.241.44:53942&quot;,&quot;clientId&quot;:1001&#125;</span><br><span class="line"></span><br><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 19] get /otter/canal/destinations/example/1001/cursor</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.alibaba.otter.canal.protocol.position.LogPosition&quot;,</span><br><span class="line">&quot;identity&quot;:&#123;&quot;slaveId&quot;:-1,&quot;sourceAddress&quot;:&#123;&quot;address&quot;:&quot;localhost&quot;,&quot;port&quot;:3306&#125;&#125;,</span><br><span class="line">&quot;postion&quot;:&#123;&quot;included&quot;:false,&quot;journalName&quot;:&quot;mysql-bin.000004&quot;,&quot;position&quot;:1331,&quot;serverId&quot;:1,&quot;timestamp&quot;:1507791918000&#125;&#125; ==》serverId表示MySQL的server_id</span><br><span class="line"></span><br><span class="line">[qihuang.zheng@dp0652 ~]$ netstat -anpt|grep 11112</span><br><span class="line">tcp        0      0 0.0.0.0:11112               0.0.0.0:*                   LISTEN      27816/java   ==》Canal服务端</span><br><span class="line">tcp        0     19 192.168.6.52:11112          10.57.241.44:53942          ESTABLISHED 27816/java   ==》Canal客户端</span><br></pre></td></tr></table></figure>
<p>停止canal_m</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 canal_m]$ bin/stop.sh</span><br><span class="line">dp0652: stopping canal 27816 ...</span><br><span class="line">Oook! cost:1</span><br></pre></td></tr></table></figure>
<p>Instance会在slave节点即canal_s上启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 ~]$ tail -f canal_s/logs/example/example.log</span><br><span class="line">2017-10-12 15:17:21.452 [New I/O server worker #1-1] ERROR com.alibaba.otter.canal.server.netty.NettyUtils - ErrotCode:400 , Caused by :</span><br><span class="line">something goes wrong with channel:[id: 0x0c182149, /10.57.241.44:54008 =&gt; /192.168.6.52:11113], exception=com.alibaba.otter.canal.server.exception.CanalServerException: destination:example should start first</span><br><span class="line"></span><br><span class="line">2017-10-12 15:17:21.661 [pool-1-thread-1] INFO  c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [canal.properties]</span><br><span class="line">2017-10-12 15:17:21.663 [pool-1-thread-1] INFO  c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [example/instance.properties]</span><br><span class="line">2017-10-12 15:17:21.767 [pool-1-thread-1] WARN  org.springframework.beans.TypeConverterDelegate - PropertyEditor [com.sun.beans.editors.EnumEditor] found through deprecated global PropertyEditorManager fallback - consider using a more isolated form of registration, e.g. on the BeanWrapper/BeanFactory!</span><br><span class="line">2017-10-12 15:17:21.968 [pool-1-thread-1] INFO  c.a.otter.canal.instance.spring.CanalInstanceWithSpring - start CannalInstance for 1-example</span><br><span class="line">2017-10-12 15:17:21.998 [pool-1-thread-1] INFO  c.a.otter.canal.instance.core.AbstractCanalInstance - start successful....</span><br><span class="line">2017-10-12 15:17:22.071 [destination = example , address = /127.0.0.1:3306 , EventParser] WARN  c.a.otter.canal.parse.inbound.mysql.MysqlEventParser - prepare to find start position just last position</span><br><span class="line"> &#123;&quot;identity&quot;:&#123;&quot;slaveId&quot;:-1,&quot;sourceAddress&quot;:&#123;&quot;address&quot;:&quot;localhost&quot;,&quot;port&quot;:3306&#125;&#125;,&quot;postion&quot;:&#123;&quot;included&quot;:false,&quot;journalName&quot;:&quot;mysql-bin.000004&quot;,&quot;position&quot;:1331,&quot;serverId&quot;:1,&quot;timestamp&quot;:1507791918000&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>停止canal_m后，只剩下canal_s，所以Canal集群只有一个节点了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 14] ls /otter/canal/cluster</span><br><span class="line">[192.168.6.52:11113]</span><br><span class="line"></span><br><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 5] get /otter/canal/destinations/example/running</span><br><span class="line">&#123;&quot;active&quot;:true,&quot;address&quot;:&quot;192.168.6.52:11113&quot;,&quot;cid&quot;:3&#125;</span><br></pre></td></tr></table></figure>
<p>切换过程中，Client的日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2017-10-12 15:17:22.524 [Thread-2] WARN  c.alibaba.otter.canal.client.impl.ClusterCanalConnector - failed to connect to:/192.168.6.52:11113 after retry 0 times</span><br><span class="line">2017-10-12 15:17:22.529 [Thread-2] WARN  c.a.otter.canal.client.impl.running.ClientRunningMonitor - canal is not run any in node</span><br><span class="line">2017-10-12 15:17:27.695 [Thread-2] INFO  c.alibaba.otter.canal.client.impl.ClusterCanalConnector - restart the connector for next round retry.</span><br><span class="line"></span><br><span class="line">****************************************************</span><br><span class="line">* Batch Id: [1] ,count : [1] , memsize : [75] , Time : 2017-10-12 15:17:27</span><br><span class="line">* Start : [mysql-bin.000004:1331:1507791918000(2017-10-12 15:05:18)] </span><br><span class="line">* End : [mysql-bin.000004:1331:1507791918000(2017-10-12 15:05:18)] </span><br><span class="line">****************************************************</span><br><span class="line">----------------</span><br><span class="line"> END ----&gt; transaction id: 0</span><br><span class="line">================&gt; binlog[mysql-bin.000004:1331] , executeTime : 1507791918000 , delay : 729763ms</span><br></pre></td></tr></table></figure>
<p>再次执行SQL语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">****************************************************</span><br><span class="line">* Batch Id: [2] ,count : [3] , memsize : [198] , Time : 2017-10-12 15:20:56</span><br><span class="line">* Start : [mysql-bin.000004:1406:1507792855000(2017-10-12 15:20:55)] </span><br><span class="line">* End : [mysql-bin.000004:1581:1507792855000(2017-10-12 15:20:55)] </span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">================&gt; binlog[mysql-bin.000004:1406] , executeTime : 1507792855000 , delay : 1539ms</span><br><span class="line"> BEGIN ----&gt; Thread id: 763</span><br><span class="line">----------------&gt; binlog[mysql-bin.000004:1532] , name[canal_test,test] , eventType : UPDATE , executeTime : 1507792855000 , delay : 1539ms</span><br><span class="line">uid : 1    type=int(4)</span><br><span class="line">name : zqhx    type=varchar(10)    update=true</span><br><span class="line">----------------</span><br><span class="line"> END ----&gt; transaction id: 0</span><br><span class="line">================&gt; binlog[mysql-bin.000004:1581] , executeTime : 1507792855000 , delay : 1540ms</span><br></pre></td></tr></table></figure>
<p>停止客户端后，查询ZK中的客户端信息。注意，仍然有cursor信息，但是没有running，因为instance没有对应的client了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 1] ls /otter/canal/destinations/example</span><br><span class="line">[running, cluster, 1001]</span><br><span class="line"></span><br><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 0] ls /otter/canal/destinations/example/1001</span><br><span class="line">[cursor]</span><br><span class="line"></span><br><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 6] get /otter/canal/destinations/example/1001/cursor</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.alibaba.otter.canal.protocol.position.LogPosition&quot;,</span><br><span class="line">&quot;identity&quot;:&#123;&quot;slaveId&quot;:-1,&quot;sourceAddress&quot;:&#123;&quot;address&quot;:&quot;localhost&quot;,&quot;port&quot;:3306&#125;&#125;,</span><br><span class="line">&quot;postion&quot;:&#123;&quot;included&quot;:false,&quot;journalName&quot;:&quot;mysql-bin.000004&quot;,&quot;position&quot;:1581,&quot;serverId&quot;:1,&quot;timestamp&quot;:1507792855000&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>cursor信息是instance消费binlog的位置，即使客户端停掉了，也仍然保留在zk中。</p>
<blockquote>
<p>注意：1001是ClientIdentity的固定编号，相关源码在<a href="https://github.com/alibaba/canal/blob/master/client/src/main/java/com/alibaba/otter/canal/client/impl/SimpleCanalConnector.java#L88">SimpleCanalConnector</a>的构造方法里。</p>
</blockquote>
<p>下面总结下zk中的相关记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/otter/canal/</span><br><span class="line">  |- cluster          ==&gt; [192.168.6.52:11112, 192.168.6.52:11113]</span><br><span class="line">  |- destinations     ==&gt; instances</span><br><span class="line">     |- example1/     ==&gt; instance name</span><br><span class="line">     |  |- cluster    ==&gt; [192.168.6.52:11112, 192.168.6.52:11113]</span><br><span class="line">     |  |- running    ==&gt; &#123;&quot;active&quot;:true,&quot;address&quot;:&quot;192.168.6.52:11112&quot;,&quot;cid&quot;:2&#125;</span><br><span class="line">     |  |- 1001</span><br><span class="line">     |     |- running  ==&gt; &#123;&quot;active&quot;:true,&quot;address&quot;:&quot;10.57.241.44:53942&quot;,&quot;clientId&quot;:1001&#125;</span><br><span class="line">     |     |- cursor  ==&gt; &#123;localhost:3306,&quot;journalName&quot;:&quot;mysql-bin.000004&quot;,&quot;position&quot;:1331,&quot;serverId&quot;:1&#125;</span><br><span class="line">     |- example2/</span><br><span class="line">     |  |- cluster    ==&gt; [192.168.6.52:11112, 192.168.6.52:11113]</span><br><span class="line">     |  |- running    ==&gt; &#123;&quot;active&quot;:true,&quot;address&quot;:&quot;192.168.6.52:11112&quot;,&quot;cid&quot;:2&#125;</span><br><span class="line">     |  |- 1001</span><br><span class="line">     |     |- running  ==&gt; &#123;&quot;active&quot;:true,&quot;address&quot;:&quot;10.57.241.44:53942&quot;,&quot;clientId&quot;:1001&#125;</span><br><span class="line">     |     |- cursor  ==&gt; &#123;localhost:3306,&quot;journalName&quot;:&quot;mysql-bin.000004&quot;,&quot;position&quot;:1331,&quot;serverId&quot;:1&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里有两个running节点，第一个是CanalServer，第二个是CanalClient。</p>
<ul>
<li><code>/otter/canal/destinations/example1/running</code>: <em>{“active”:true,”address”:”192.168.6.52:11112”,”cid”:2}</em></li>
<li><code>/otter/canal/destinations/example1/1001/running</code>: <em>{“active”:true,”address”:”10.57.241.44:53942”,”clientId”:1001}</em></li>
</ul>
<p>下图是Canal Server HA的流程图：</p>
<ol>
<li>canal server要启动某个canal instance时都先向zookeeper进行一次尝试启动判断 (实现：创建EPHEMERAL节点，谁创建成功就允许谁启动)</li>
<li>创建zookeeper节点成功后，对应的canal server就启动对应的canal instance，没有创建成功的canal instance就会处于standby状态</li>
<li>一旦zookeeper发现canal server A创建的节点消失后，立即通知其他的canal server再次进行步骤1的操作，重新选出一个canal server启动instance.</li>
<li>canal client每次进行connect时，会首先向zookeeper询问当前是谁启动了canal instance，然后和其建立链接，一旦链接不可用，会重新尝试connect.</li>
</ol>
<p><img src="https://camo.githubusercontent.com/c8f1d98268a307821273e94e7eefcd29a26f9b78/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333330332f64333230326332362d653935342d333563302d613331392d3537363034313032633537642e6a7067" alt="server ha"></p>
<h2 id="Canal_Client_HA">Canal Client HA</h2><p>Canal Client的方式和canal server方式类似，也是利用zookeeper的抢占EPHEMERAL节点的方式进行控制。</p>
<blockquote>
<p>HA的实现，客户端是ClientRunningMonitor，服务端是ServerRunningMonitor。</p>
</blockquote>
<p>关于Canal Client HA的验证，可以参考：<a href="http://blog.csdn.net/xiaolinzi007/article/details/52933909" target="_blank" rel="noopener">http://blog.csdn.net/xiaolinzi007/article/details/52933909</a></p>
<ul>
<li>在IDEA中同时启动多个客户端，执行一条SQL语句，其中一个客户端会打印日志，另一个不会打印。</li>
<li>停止打印日志的那个客户端（在停止这个客户端之前，日志一直发动到这个客户端，不是负载均衡）。</li>
<li>再次执行SQL语句，另外一个客户端会打印日志。</li>
</ul>
<p>Client1的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">****************************************************</span><br><span class="line">* Batch Id: [3] ,count : [3] , memsize : [198] , Time : 2017-10-12 17:59:59</span><br><span class="line">* Start : [mysql-bin.000004:1656:1507802398000(2017-10-12 17:59:58)] </span><br><span class="line">* End : [mysql-bin.000004:1831:1507802398000(2017-10-12 17:59:58)] </span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">================&gt; binlog[mysql-bin.000004:1656] , executeTime : 1507802398000 , delay : 1188ms</span><br><span class="line"> BEGIN ----&gt; Thread id: 768</span><br><span class="line">----------------&gt; binlog[mysql-bin.000004:1782] , name[canal_test,test] , eventType : UPDATE , executeTime : 1507802398000 , delay : 1199ms</span><br><span class="line">uid : 1    type=int(4)</span><br><span class="line">name : zqh    type=varchar(10)    update=true</span><br><span class="line">----------------</span><br><span class="line"> END ----&gt; transaction id: 0</span><br><span class="line">================&gt; binlog[mysql-bin.000004:1831] , executeTime : 1507802398000 , delay : 1236ms</span><br><span class="line">## stop the canal client## canal client is down.</span><br></pre></td></tr></table></figure>
<p>停止Client1后，Client2的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">****************************************************</span><br><span class="line">* Batch Id: [4] ,count : [3] , memsize : [198] , Time : 2017-10-12 18:02:15</span><br><span class="line">* Start : [mysql-bin.000004:1906:1507802534000(2017-10-12 18:02:14)] </span><br><span class="line">* End : [mysql-bin.000004:2081:1507802534000(2017-10-12 18:02:14)] </span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">================&gt; binlog[mysql-bin.000004:1906] , executeTime : 1507802534000 , delay : 1807ms</span><br><span class="line"> BEGIN ----&gt; Thread id: 768</span><br><span class="line">----------------&gt; binlog[mysql-bin.000004:2032] , name[canal_test,test] , eventType : UPDATE , executeTime : 1507802534000 , delay : 1819ms</span><br><span class="line">uid : 1    type=int(4)</span><br><span class="line">name : zqhx    type=varchar(10)    update=true</span><br><span class="line">----------------</span><br><span class="line"> END ----&gt; transaction id: 0</span><br><span class="line">================&gt; binlog[mysql-bin.000004:2081] , executeTime : 1507802534000 , delay : 1855ms</span><br></pre></td></tr></table></figure>
<p>观察ZK节点中instance对应的client节点，在Client切换时，会进行变更。<br>比如下面的客户端从56806端口切换到了56842端口。<br>把所有客户端都关闭后，1001下没有running。表示instance没有客户端消费binlog了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">启动两个客户端，第一个客户端（56806）正在运行</span><br><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 29] get /otter/canal/destinations/example/1001/running</span><br><span class="line">&#123;&quot;active&quot;:true,&quot;address&quot;:&quot;10.57.241.44:56806&quot;,&quot;clientId&quot;:1001&#125;</span><br><span class="line"></span><br><span class="line">停止第一个客户端，删除节点</span><br><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 30] get /otter/canal/destinations/example/1001/running</span><br><span class="line">Node does not exist: /otter/canal/destinations/example/1001/running</span><br><span class="line"></span><br><span class="line">第二个客户端（56842）成为主</span><br><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 31] get /otter/canal/destinations/example/1001/running</span><br><span class="line">&#123;&quot;active&quot;:true,&quot;address&quot;:&quot;10.57.241.44:56842&quot;,&quot;clientId&quot;:1001&#125;</span><br><span class="line"></span><br><span class="line">[zk: 192.168.6.52:2181(CONNECTED) 32] ls /otter/canal/destinations/example/1001</span><br><span class="line">[cursor]</span><br></pre></td></tr></table></figure>
<p>具体实现相关类有：ClientRunningMonitor/ClientRunningListener/ClientRunningData。</p>
<p>client running相关控制，主要为解决client自身的failover机制。<br>canal client允许同时启动多个canal client，<br>通过running机制，可保证只有一个client在工作，其他client做为冷备.<br>当运行中的client挂了，running会控制让冷备中的client转为工作模式，<br>这样就可以确保canal client也不会是单点. 保证整个系统的高可用性.</p>
<p>下图左边是客户端的HA实现，右边是服务端的HA实现</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171012184033228" alt="ha"></p>
<h2 id="Develop_Canal_Client"><a href="https://github.com/alibaba/canal/wiki/ClientAPI">Develop Canal Client</a></h2><p>先理解下面的类图结构：</p>
<ul>
<li>CanalConnector接口，定义了连接、订阅、获取、应答、回滚等方法</li>
<li>SimpleCanalConnector实现，单机版本</li>
<li>ClusterCanalConnector实现，HA版本</li>
</ul>
<p><img src="https://camo.githubusercontent.com/8cc684cf92e22d738d57b002c356afba96bcc4f5/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303039302f363435332f39326233343335302d323566632d333162332d626361362d3865326131653763356532322e6a7067" alt="client"></p>
<h3 id="subscribe_change">subscribe change</h3><p>重新看下CanalServerWithEmbedded的订阅方法。我们知道客户端在连接服务端的某个destination之后，会紧接着调用subscribe()方法。</p>
<p>客户端连接服务端时，必须指定destination名称，因为一个服务端可能有多个destination。<br>比如服务端启动了两个Instance，它们的destination名称分别是example1和example2。<br>假设有两个客户端A和B，A连接example1，B连接example2（在代码中手动指定的，不是自动选择）。<br>服务端的canalInstances字典为：{example1=&gt;Instance1，example2-&gt;Instance2}。<br>那么ClientA的destination等于example1，对应的服务端实例为Instance1。<br>ClientB的destination等于example2，对应的服务端实例为Instance3。</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171012230738279" alt="clients"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 客户端订阅，重复订阅时会更新对应的filter信息</span><br><span class="line"> */</span><br><span class="line">public void subscribe(ClientIdentity clientIdentity) throws CanalServerException &#123;</span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    if (!canalInstance.getMetaManager().isStart()) &#123;</span><br><span class="line">        canalInstance.getMetaManager().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canalInstance.getMetaManager().subscribe(clientIdentity); // 执行一下meta订阅</span><br><span class="line"></span><br><span class="line">    // 根据Client从MetaManager中获取最近一次的Cursor</span><br><span class="line">    Position position = canalInstance.getMetaManager().getCursor(clientIdentity);</span><br><span class="line">    if (position == null) &#123; // 如果没有</span><br><span class="line">        position = canalInstance.getEventStore().getFirstPosition();// 获取一下store中的第一条</span><br><span class="line">        if (position != null) &#123;</span><br><span class="line">            canalInstance.getMetaManager().updateCursor(clientIdentity, position); // 更新一下cursor</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(&quot;subscribe successfully, &#123;&#125; with first position:&#123;&#125; &quot;, clientIdentity, position);</span><br><span class="line">    &#125; else &#123; // 有就直接使用</span><br><span class="line">        logger.info(&quot;subscribe successfully, use last cursor position:&#123;&#125; &quot;, clientIdentity, position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通知下订阅关系变化</span><br><span class="line">    canalInstance.subscribeChange(clientIdentity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面关于订阅方法有两个地方，CanalInstance本身调用了subscribeChange，它关联的MetaManager也调用了subscribe方法。</p>
<p>一个CanalServer可以有多个CanalInstance，每个Instance都会有一个MetaManager。<br>而一个Instance对应一个Client。那么，这么说来，一个MetaManager也就只会有一个Client了。<br>但是从下面的数据结构来看的话，一个MetaManager貌似可以有多个Destination。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MemoryMetaManager extends AbstractCanalLifeCycle implements CanalMetaManager &#123;</span><br><span class="line">    protected Map&lt;String, List&lt;ClientIdentity&gt;&gt;              destinations;</span><br><span class="line">    protected Map&lt;ClientIdentity, MemoryClientIdentityBatch&gt; batches;</span><br><span class="line">    protected Map&lt;ClientIdentity, Position&gt;                  cursors;</span><br><span class="line"></span><br><span class="line">    public synchronized void subscribe(ClientIdentity clientIdentity) throws CanalMetaManagerException &#123;</span><br><span class="line">        List&lt;ClientIdentity&gt; clientIdentitys = destinations.get(clientIdentity.getDestination());</span><br><span class="line">        if (clientIdentitys.contains(clientIdentity)) &#123;</span><br><span class="line">            clientIdentitys.remove(clientIdentity);</span><br><span class="line">        &#125;</span><br><span class="line">        clientIdentitys.add(clientIdentity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>猜测：多个Client可以连接到同一个Instance（虽然只会有一个Instance起作用），所以一个MetaManager可以管理多个Client。<br>NO！Client的HA与MetaManager记录的Client是不一样的。HA表示同一时间只有一个Client起作用，那么MetaManager不可能同时记录两个Client。</p>
</blockquote>
<blockquote>
<p>官方ClientAPI文档上：ClientIdentity是canal client和server交互之间的身份标识，目前clientId写死为1001.<br><strong><font color="red" size="5">目前canal server上的一个instance只能有一个client消费</font></strong>，<br>clientId的设计是为1个instance多client消费模式而预留的，暂时不需要理会。</p>
</blockquote>
<p>也就是说：一个Instance还是有可能有多个Client连接上来的，只是目前只允许一个而已！！！</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171012234337736" alt="subscribes"></p>
<p>这里的数据结构为什么这么设计，还需要参考<em>AbstractMetaManagerTest</em>的<em>doSubscribeTest</em>方法来理解。</p>
<p>对于相同的destination，可以订阅不同的client。下面的示例分别订阅了[client1,client2]和[client1,client3]。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void doSubscribeTest(CanalMetaManager metaManager) &#123;</span><br><span class="line">    ClientIdentity client1 = new ClientIdentity(destination, (short) 1);</span><br><span class="line">    metaManager.subscribe(client1);</span><br><span class="line">    metaManager.subscribe(client1); // 重复调用：删除旧的client1，并继续增加新的client1</span><br><span class="line">    ClientIdentity client2 = new ClientIdentity(destination, (short) 2);</span><br><span class="line">    metaManager.subscribe(client2);</span><br><span class="line"></span><br><span class="line">    List&lt;ClientIdentity&gt; clients = metaManager.listAllSubscribeInfo(destination);</span><br><span class="line">    Assert.assertEquals(Arrays.asList(client1, client2), clients);</span><br><span class="line"></span><br><span class="line">    metaManager.unsubscribe(client2);</span><br><span class="line">    ClientIdentity client3 = new ClientIdentity(destination, (short) 3);</span><br><span class="line">    metaManager.subscribe(client3);</span><br><span class="line"></span><br><span class="line">    clients = metaManager.listAllSubscribeInfo(destination);</span><br><span class="line">    Assert.assertEquals(Arrays.asList(client1, client3), clients);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有不懂的地方，可以看看测试用例，验证自己的想法是否正确。</p>
</blockquote>
<p><strong>CanalServerWithEmbedded</strong>的订阅方法最后还会调用<strong>AbstractCanalInstance</strong>的<code>subscribeChange</code>方法。<br>这里会设置表名的filter，以及黑名单。配置项在instance.properties中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># table regex</span><br><span class="line">canal.instance.filter.regex = .*\\..*</span><br><span class="line"># table black regex</span><br><span class="line">canal.instance.filter.black.regex =</span><br></pre></td></tr></table></figure>
<p>filter表示客户端要通过Canal Server获取MySQL哪些表的binlog，上面配置项表示获取所有表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractCanalInstance extends AbstractCanalLifeCycle implements CanalInstance &#123;</span><br><span class="line">    protected Long                                   canalId;                                                      // 和manager交互唯一标示</span><br><span class="line">    protected String                                 destination;                                                  // 队列名字</span><br><span class="line">    protected CanalEventStore&lt;Event&gt;                 eventStore;                                                   // 有序队列</span><br><span class="line"></span><br><span class="line">    protected CanalEventParser                       eventParser;                                                  // 解析对应的数据信息</span><br><span class="line">    protected CanalEventSink&lt;List&lt;CanalEntry.Entry&gt;&gt; eventSink;                                                    // 链接parse和store的桥接器</span><br><span class="line">    protected CanalMetaManager                       metaManager;                                                  // 消费信息管理器</span><br><span class="line">    protected CanalAlarmHandler                      alarmHandler;                                                 // alarm报警机制</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean subscribeChange(ClientIdentity identity) &#123;</span><br><span class="line">        if (StringUtils.isNotEmpty(identity.getFilter())) &#123;</span><br><span class="line">            logger.info(&quot;subscribe filter change to &quot; + identity.getFilter());</span><br><span class="line">            AviaterRegexFilter aviaterFilter = new AviaterRegexFilter(identity.getFilter());</span><br><span class="line"></span><br><span class="line">            boolean isGroup = (eventParser instanceof GroupEventParser);</span><br><span class="line">            if (isGroup) &#123;</span><br><span class="line">                // 处理group的模式</span><br><span class="line">                List&lt;CanalEventParser&gt; eventParsers = ((GroupEventParser) eventParser).getEventParsers();</span><br><span class="line">                for (CanalEventParser singleEventParser : eventParsers) &#123;// 需要遍历启动</span><br><span class="line">                    ((AbstractEventParser) singleEventParser).setEventFilter(aviaterFilter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ((AbstractEventParser) eventParser).setEventFilter(aviaterFilter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // filter的处理规则</span><br><span class="line">        // a. parser处理数据过滤处理</span><br><span class="line">        // b. sink处理数据的路由&amp;分发,一份parse数据经过sink后可以分发为多份，每份的数据可以根据自己的过滤规则不同而有不同的数据</span><br><span class="line">        // 后续内存版的一对多分发，可以考虑</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应在EventParser中，存在两个Filter的引用。比如上面eventParser.setEventFilter()方法会设置AbstractEventParser的eventFilter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractEventParser&lt;EVENT&gt; extends AbstractCanalLifeCycle implements CanalEventParser&lt;EVENT&gt; &#123;</span><br><span class="line">    protected CanalLogPositionManager                logPositionManager         = null;</span><br><span class="line">    protected CanalEventSink&lt;List&lt;CanalEntry.Entry&gt;&gt; eventSink                  = null;</span><br><span class="line">    protected CanalEventFilter                       eventFilter                = null;</span><br><span class="line">    protected CanalEventFilter                       eventBlackFilter           = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EventParser_Implement">EventParser Implement</h3><p>AbstractEventParser的start()方法是解析binlog的主要方法。<br>在启动transactionBuffer和BinLogParser后，<br>会启动一个后台的工作线程<strong>parseThread</strong>一直运行：  </p>
<p>注意：下面的几个步骤是嵌套在一个while死循环里，最后会进行sleep。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 开始执行replication</span><br><span class="line">// 1. 构造Erosa连接</span><br><span class="line">erosaConnection = buildErosaConnection();</span><br><span class="line"></span><br><span class="line">// 2. 启动一个心跳线程</span><br><span class="line">startHeartBeat(erosaConnection);</span><br><span class="line"></span><br><span class="line">// 3. 执行dump前的准备工作</span><br><span class="line">preDump(erosaConnection);</span><br><span class="line"></span><br><span class="line">// 4. 连接MySQL数据库</span><br><span class="line">erosaConnection.connect(); </span><br><span class="line"></span><br><span class="line">// 5. 获取最后的位置信息</span><br><span class="line">EntryPosition startPosition = findStartPosition(erosaConnection);</span><br><span class="line">logger.info(&quot;find start position : &#123;&#125;&quot;, startPosition.toString());</span><br><span class="line">// 重新链接，因为在找position过程中可能有状态，需要断开后重建</span><br><span class="line">erosaConnection.reconnect();</span><br><span class="line"></span><br><span class="line">// 定义回调函数，当解析成功后，sink()方法会暂存到缓冲区transactionBuffer中。缓冲区的数据会通过心跳线程放入EventSink</span><br><span class="line">final SinkFunction sinkHandler = new SinkFunction&lt;EVENT&gt;() &#123;</span><br><span class="line">    private LogPosition lastPosition;</span><br><span class="line"></span><br><span class="line">    public void sink(EVENT event) &#123;</span><br><span class="line">        CanalEntry.Entry entry = parseAndProfilingIfNecessary(event);</span><br><span class="line">        if (entry != null) &#123;</span><br><span class="line">            transactionBuffer.add(entry);</span><br><span class="line">            this.lastPosition = buildLastPosition(entry);  // 记录一下对应的positions</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 6. 开始dump数据</span><br><span class="line">if (StringUtils.isEmpty(startPosition.getJournalName()) &amp;&amp; startPosition.getTimestamp() != null) &#123;</span><br><span class="line">    erosaConnection.dump(startPosition.getTimestamp(), sinkHandler);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    erosaConnection.dump(startPosition.getJournalName(), startPosition.getPosition(), sinkHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的erosaConnection指的是Canal Server到MySQL的连接。<br>而前面我们说的客户端（CanalClient）连接CanalConnector指的是CanalClient到CanalServer的连接。</p>
<p><strong><font color="red" size="3">CanalServer到MySQL的连接是要获取binlog的dump数据包。而CanalClient到CanalServer有多种请求（GET/ACK等）。</font></strong></p>
<p>我们不会具体分析<em>dump</em>的流程，不过粗略看下erosaConnection的MySQL实现<strong>MysqlConnection</strong>是如何在获取到事件后调用回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void dump(String binlogfilename, Long binlogPosition, SinkFunction func) throws IOException &#123;</span><br><span class="line">    updateSettings();</span><br><span class="line">    sendBinlogDump(binlogfilename, binlogPosition);</span><br><span class="line">    // connector指的是CanalServer到MySQL Master服务器的连接，创建一个拉取线程拉取MySQL的binlog</span><br><span class="line">    DirectLogFetcher fetcher = new DirectLogFetcher(connector.getReceiveBufferSize());</span><br><span class="line">    fetcher.start(connector.getChannel());</span><br><span class="line">    LogDecoder decoder = new LogDecoder(LogEvent.UNKNOWN_EVENT, LogEvent.ENUM_END_EVENT);</span><br><span class="line">    LogContext context = new LogContext();</span><br><span class="line">    while (fetcher.fetch()) &#123; // 由于设置了缓冲区的大小，每次dump都只会拉取一批数据</span><br><span class="line">        LogEvent event = null;</span><br><span class="line">        event = decoder.decode(fetcher, context);</span><br><span class="line">        if (!func.sink(event)) break; // 调用回调方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端有一个心跳线程，它的目的是消费<em>transactionBuffer</em>，并写入到<strong>EventSink</strong>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected boolean consumeTheEventAndProfilingIfNecessary(List&lt;CanalEntry.Entry&gt; entrys) &#123;</span><br><span class="line">    boolean result = eventSink.sink(entrys, </span><br><span class="line">        (runningInfo == null) ? null : runningInfo.getAddress(), destination);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>EventSink</strong>最终会将数据写入到<strong>EventStore</strong>中，即<em>Put</em>到<strong>RingBuffer</strong>中。回顾下这张图：</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171011211529169" alt="ops"></p>
<h2 id="CanalController">CanalController</h2><p>前面分析了这么多，一直没分析Canal服务是怎么起来的，其实很简单，<br>执行脚本startup.sh本质上通过CanalLauncher会启动CanalController。</p>
<h2 id="eunomia">eunomia</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[zk: 192.168.6.55:2181(CONNECTED) 3] ls /otter/canal/destinations</span><br><span class="line">[octopus_demeter, example_bak, namelist_test, xiaopang2, namelist2, xiaopang3, namelist1, example, xiaopang]</span><br><span class="line"></span><br><span class="line">[zk: 192.168.6.55:2181(CONNECTED) 4] ls /otter/canal/destinations/xiaopang</span><br><span class="line">[eunomia, cluster, 1001, running]</span><br><span class="line"></span><br><span class="line">[zk: 192.168.6.55:2181(CONNECTED) 5] ls /otter/canal/destinations/xiaopang/eunomia</span><br><span class="line">[_c_2a900d4e-75fb-4445-b30c-04e1bdb2e5d9-lock-0001381746, runnning, _c_ea33db37-9193-4c75-9e61-85e59e123109-lock-0001381738]</span><br><span class="line"></span><br><span class="line">// Eunomia Server？还是Canal Client？</span><br><span class="line">[zk: 192.168.6.55:2181(CONNECTED) 7] get /otter/canal/destinations/xiaopang/eunomia/runnning</span><br><span class="line">10.57.17.100</span><br><span class="line"></span><br><span class="line">[zk: 192.168.6.55:2181(CONNECTED) 18] get /otter/canal/destinations/xiaopang/1001/running</span><br><span class="line">&#123;&quot;active&quot;:true,&quot;address&quot;:&quot;10.57.17.100:60661&quot;,&quot;clientId&quot;:1001&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
<div class="copyright">
  <p><span>本文标题:</span><a href="/2017/10/10/Midd-canal/">深入解析中间件之-Canal</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 任何忧伤,都抵不过世界的美丽 的个人博客">任何忧伤,都抵不过世界的美丽</a></p>
  <p><span>发布时间:</span>2017年10月10日 - 00时00分</p>
  <p><span>最后更新:</span>2019年02月14日 - 21时42分</p>
  <p>
    <span>原始链接:</span><a href="/2017/10/10/Midd-canal/" title="深入解析中间件之-Canal">http://github.com/zqhxuyuan/2017/10/10/Midd-canal/</a>
    <span class="btn" data-clipboard-text="原文: http://github.com/zqhxuyuan/2017/10/10/Midd-canal/　　作者: 任何忧伤,都抵不过世界的美丽" title="点击复制文章链接">
        <i class="fa fa-clipboard"></i>
    </span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。</p>
  <script src="/js/clipboard.min.js"></script>
  <script> var clipboard = new Clipboard('.btn'); </script>
</div>
<style type="text/css">
  .copyright p .btn {
    margin-left: 1em;
  }
  .copyright:hover p .btn::after {
    content: "复制"
  }
  .copyright p .btn:hover {
      color: gray;
      cursor: pointer;
    };
</style>



<nav id="article-nav">
  
    <div id="article-nav-newer" class="article-nav-title">
      <a href="/2017/10/18/Midd-Dubbo/">
        深入解析中间件之-Dubbo
      </a>
    </div>
  
  
    <div id="article-nav-older" class="article-nav-title">
      <a href="/2017/09/15/2017-09-15-Spark-DataSources/">
        Spark DataSources Implementation
      </a>
    </div>
  
</nav>

  
  
    <div class="post-donate">
	<br>
	<p>
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
		   招人广告：对蚂蚁金服中间件感兴趣的可以发邮件到：qihuang.zqh at antfin.com
        </span>
        <br>
    </div>  
	<div id="donate_guide" class="donate_bar center hidden">
		<img src="/img/zhifubao.png" alt="支付宝打赏"> 
		<img src="/img/weixin.png" alt="微信打赏">  
    </div>
	<script type="text/javascript">
		document.getElementById('btn_donate').onclick = function(){
			$('#donate_board').addClass('hidden');
			$('#donate_guide').removeClass('hidden');
		}
	</script>
</p></div>
  
</article>

<!-- 默认显示文章目录，在文章---前输入toc: false关闭目录 -->
<!-- Show TOC and tocButton in default, Hide TOC via putting "toc: false" before "---" at [post].md -->
<div id="toc" class="toc-article">
<strong class="toc-title">文章目录</strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL_binlog"><span class="toc-number">1.</span> <span class="toc-text">MySQL binlog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL主从复制"><span class="toc-number">1.1.</span> <span class="toc-text">MySQL主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog"><span class="toc-number">1.2.</span> <span class="toc-text">binlog</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canal_QuickStart"><span class="toc-number">2.</span> <span class="toc-text">Canal QuickStart</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#canal_&_config"><span class="toc-number">2.1.</span> <span class="toc-text">canal &amp; config</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#simple_client"><span class="toc-number">2.2.</span> <span class="toc-text">simple client</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cannal_Internal_Overview"><span class="toc-number">3.</span> <span class="toc-text">Cannal Internal Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#canal_client_&_server"><span class="toc-number">3.1.</span> <span class="toc-text">canal client &amp; server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CanalServerWithEmbedded"><span class="toc-number">3.2.</span> <span class="toc-text">CanalServerWithEmbedded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventStore"><span class="toc-number">3.3.</span> <span class="toc-text">EventStore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventParser_WorkFlow"><span class="toc-number">3.4.</span> <span class="toc-text">EventParser WorkFlow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canal_HA"><span class="toc-number">4.</span> <span class="toc-text">Canal HA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canal_Client_HA"><span class="toc-number">5.</span> <span class="toc-text">Canal Client HA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Develop_Canal_Client"><span class="toc-number">6.</span> <span class="toc-text">Develop Canal Client</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#subscribe_change"><span class="toc-number">6.1.</span> <span class="toc-text">subscribe change</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventParser_Implement"><span class="toc-number">6.2.</span> <span class="toc-text">EventParser Implement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CanalController"><span class="toc-number">7.</span> <span class="toc-text">CanalController</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eunomia"><span class="toc-number">8.</span> <span class="toc-text">eunomia</span></a></li></ol>
</div>
<style type="text/css">
  .left-col .switch-btn {
    display: none;
  }
  .left-col .switch-area {
    display: none;
  }
</style>

<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">
<script type="text/javascript">
  var toc_button= document.getElementById("tocButton");
  var toc_div= document.getElementById("toc");
  /* Show or hide toc when click on tocButton.
  通过点击设置的按钮显示或者隐藏文章目录.*/
  toc_button.onclick=function(){
  if(toc_div.style.display=="none"){
  toc_div.style.display="block";
  toc_button.value="隐藏目录";
  document.getElementById("switch-btn").style.display="none";
  document.getElementById("switch-area").style.display="none";
  }
  else{
  toc_div.style.display="none";
  toc_button.value="显示目录";
  document.getElementById("switch-btn").style.display="block";
  document.getElementById("switch-area").style.display="block";
  }
  }
    if ($(".toc").length < 1) {
        $("#toc").css("display","none");
        $("#tocButton").css("display","none");
        $(".switch-btn").css("display","block");
        $(".switch-area").css("display","block");
    }
</script>


    <style>
        .toc {
            white-space: nowrap;
            overflow-x: hidden;
        }
    </style>

    <script>
        $(document).ready(function() {
            $(".toc li a").mouseover(function() {
                var title = $(this).attr('href');
                $(this).attr("title", title);
            });
        })
    </script>




<div class="share">
	<div class="bdsharebuttonbox">
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
	<a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
	<a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
	</div>
	<script>
	window._bd_share_config={
		"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	</script>
</div>



<div class="duoshuo" id="comments">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2017/10/10/Midd-canal/" data-title="深入解析中间件之-Canal" data-url="http://github.com/zqhxuyuan/2017/10/10/Midd-canal/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"zqhxuyuan"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>






    <style type="text/css">
    #scroll {
      display: none;
    }
    </style>
    <div class="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
    </div>


  
  
    
    <div class="post-nav-button">
    <a href="/2017/10/18/Midd-Dubbo/" title="上一篇: 深入解析中间件之-Dubbo">
    <i class="fa fa-angle-left"></i>
    </a>
    <a href="/2017/09/15/2017-09-15-Spark-DataSources/" title="下一篇: Spark DataSources Implementation">
    <i class="fa fa-angle-right"></i>
    </a>
    </div>
  



    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
        
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2019 任何忧伤,都抵不过世界的美丽
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style="display:none">
        <span id="site-visit">本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style="display:none">
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

<script>
  var backgroundnum = 5;
  var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));

  $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
</script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-80646710-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>