<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>深入解析中间件之-RocketMQ | zqhxuyuan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Apache RocketMQ: http://rocketmq.apache.org/">
<meta name="keywords" content="rocketmq">
<meta property="og:type" content="article">
<meta property="og:title" content="深入解析中间件之-RocketMQ">
<meta property="og:url" content="http://github.com/zqhxuyuan/2017/10/18/Midd-RocketMQ/index.html">
<meta property="og:site_name" content="zqhxuyuan">
<meta property="og:description" content="Apache RocketMQ: http://rocketmq.apache.org/">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://rocketmq.apache.org/assets/images/rmq-basic-arc.png">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021122552876">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019140724552">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019141837964">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019195642571">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019195656785">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019201635395">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021085345842">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021145704818">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021144845680">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021133510386">
<meta property="og:image" content="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021151527711">
<meta property="og:updated_time" content="2019-02-14T13:42:29.370Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入解析中间件之-RocketMQ">
<meta name="twitter:description" content="Apache RocketMQ: http://rocketmq.apache.org/">
<meta name="twitter:image" content="http://rocketmq.apache.org/assets/images/rmq-basic-arc.png">
  
    <link rel="alternative" href="/atom.xml" title="zqhxuyuan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars1.githubusercontent.com/u/1088525?v=3&amp;s=180" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任何忧伤,都抵不过世界的美丽</a></h1>
		</hgroup>

		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">归档</a></li>
				        
							<li><a href="/tags/">标签</a></li>
				        
							<li><a href="/about/">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/xuyuantree" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="http://github.com/zqhxuyuan" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/apex/" style="font-size: 10px;">apex</a> <a href="/tags/bigdata/" style="font-size: 10px;">bigdata</a> <a href="/tags/book/" style="font-size: 10px;">book</a> <a href="/tags/cassandra/" style="font-size: 18.89px;">cassandra</a> <a href="/tags/clojure/" style="font-size: 10px;">clojure</a> <a href="/tags/drill/" style="font-size: 16.67px;">drill</a> <a href="/tags/druid/" style="font-size: 13.33px;">druid</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/etl/" style="font-size: 10px;">etl</a> <a href="/tags/geode/" style="font-size: 10px;">geode</a> <a href="/tags/graph/" style="font-size: 12.22px;">graph</a> <a href="/tags/hadoop/" style="font-size: 11.11px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 15.56px;">hbase</a> <a href="/tags/ignite/" style="font-size: 10px;">ignite</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/kafka/" style="font-size: 20px;">kafka</a> <a href="/tags/midd/" style="font-size: 10px;">midd</a> <a href="/tags/ops/" style="font-size: 12.22px;">ops</a> <a href="/tags/redis/" style="font-size: 11.11px;">redis</a> <a href="/tags/rocketmq/" style="font-size: 10px;">rocketmq</a> <a href="/tags/scala/" style="font-size: 13.33px;">scala</a> <a href="/tags/spark/" style="font-size: 17.78px;">spark</a> <a href="/tags/storm/" style="font-size: 17.78px;">storm</a> <a href="/tags/tcc/" style="font-size: 10px;">tcc</a> <a href="/tags/timeseries/" style="font-size: 12.22px;">timeseries</a> <a href="/tags/work/" style="font-size: 14.44px;">work</a> <a href="/tags/流处理/" style="font-size: 11.11px;">流处理</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">BIG(DATA)</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">任何忧伤,都抵不过世界的美丽</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="https://avatars1.githubusercontent.com/u/1088525?v=3&amp;s=180" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">任何忧伤,都抵不过世界的美丽</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">归档</a></li>
		        
					<li><a href="/tags/">标签</a></li>
		        
					<li><a href="/about/">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/xuyuantree" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="http://github.com/zqhxuyuan" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Midd-RocketMQ" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/18/Midd-RocketMQ/" class="article-date">
  	<time datetime="2017-10-17T16:00:00.000Z" itemprop="datePublished">2017-10-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入解析中间件之-RocketMQ
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/mq/">mq</a>
	</div>


        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rocketmq/">rocketmq</a></li></ul>
	</div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>Apache RocketMQ: <a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">http://rocketmq.apache.org/</a><br><a id="more"></a></p>
<h1 id="QuickStart">QuickStart</h1><p>分别启动NameServer、Broker、生产者、消费者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqnamesrv &amp;</span><br><span class="line">&gt; nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"></span><br><span class="line">&gt; export NAMESRV_ADDR=localhost:9876</span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=AC112A0140641B6D35866042D36B0000, offsetMsgId=AC112A0100002A9F0000000000000000, messageQueue=MessageQueue [topic=TopicTest, brokerName=dp0652, queueId=3], queueOffset=0]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=AC112A0140641B6D35866042D3F50001, offsetMsgId=AC112A0100002A9F00000000000000B2, messageQueue=MessageQueue [topic=TopicTest, brokerName=dp0652, queueId=0], queueOffset=0]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=AC112A0140641B6D35866042D3FB0002, offsetMsgId=AC112A0100002A9F0000000000000164, messageQueue=MessageQueue [topic=TopicTest, brokerName=dp0652, queueId=1], queueOffset=0]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=AC112A0140641B6D35866042D4000003, offsetMsgId=AC112A0100002A9F0000000000000216, messageQueue=MessageQueue [topic=TopicTest, brokerName=dp0652, queueId=2], queueOffset=0]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=AC112A0140641B6D35866042D4040004, offsetMsgId=AC112A0100002A9F00000000000002C8, messageQueue=MessageQueue [topic=TopicTest, brokerName=dp0652, queueId=3], queueOffset=1]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=AC112A0140641B6D35866042D4080005, offsetMsgId=AC112A0100002A9F000000000000037A, messageQueue=MessageQueue [topic=TopicTest, brokerName=dp0652, queueId=0], queueOffset=1]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=AC112A0140641B6D35866042D40C0006, offsetMsgId=AC112A0100002A9F000000000000042C, messageQueue=MessageQueue [topic=TopicTest, brokerName=dp0652, queueId=1], queueOffset=1]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=AC112A0140641B6D35866042D4100007, offsetMsgId=AC112A0100002A9F00000000000004DE, messageQueue=MessageQueue [topic=TopicTest, brokerName=dp0652, queueId=2], queueOffset=1]</span><br><span class="line"></span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br><span class="line">Consumer Started.</span><br><span class="line">ConsumeMessageThread_6 Receive New Messages: [MessageExt [queueId=1, storeSize=178, queueOffset=1, sysFlag=0, bornTimestamp=1508402192396, bornHost=/172.17.42.1:55844, storeTimestamp=1508402192398, storeHost=/172.17.42.1:10911, msgId=AC112A0100002A9F000000000000042C, commitLogOffset=1068, bodyCRC=1307562618, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=250, CONSUME_START_TIME=1508402243398, UNIQ_KEY=AC112A0140641B6D35866042D40C0006, WAIT=true, TAGS=TagA&#125;, body=16]]]</span><br><span class="line">ConsumeMessageThread_11 Receive New Messages: [MessageExt [queueId=1, storeSize=179, queueOffset=2, sysFlag=0, bornTimestamp=1508402192410, bornHost=/172.17.42.1:55844, storeTimestamp=1508402192412, storeHost=/172.17.42.1:10911, msgId=AC112A0100002A9F00000000000006F4, commitLogOffset=1780, bodyCRC=193412630, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=250, CONSUME_START_TIME=1508402243399, UNIQ_KEY=AC112A0140641B6D35866042D41A000A, WAIT=true, TAGS=TagA&#125;, body=17]]]</span><br><span class="line">ConsumeMessageThread_2 Receive New Messages: [MessageExt [queueId=2, storeSize=178, queueOffset=0, sysFlag=0, bornTimestamp=1508402192384, bornHost=/172.17.42.1:55844, storeTimestamp=1508402192386, storeHost=/172.17.42.1:10911, msgId=AC112A0100002A9F0000000000000216, commitLogOffset=534, bodyCRC=1032136437, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=250, CONSUME_START_TIME=1508402243398, UNIQ_KEY=AC112A0140641B6D35866042D4000003, WAIT=true, TAGS=TagA&#125;, body=16]]]</span><br><span class="line">ConsumeMessageThread_1 Receive New Messages: [MessageExt [queueId=0, storeSize=178, queueOffset=0, sysFlag=0, bornTimestamp=1508402192373, bornHost=/172.17.42.1:55844, storeTimestamp=1508402192377, storeHost=/172.17.42.1:10911, msgId=AC112A0100002A9F00000000000000B2, commitLogOffset=178, bodyCRC=1401636825, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=250, CONSUME_START_TIME=1508402243398, UNIQ_KEY=AC112A0140641B6D35866042D3F50001, WAIT=true, TAGS=TagA&#125;, body=16]]]</span><br><span class="line">ConsumeMessageThread_4 Receive New Messages: [MessageExt [queueId=3, storeSize=178, queueOffset=0, sysFlag=0, bornTimestamp=1508402192236, bornHost=/172.17.42.1:55844, storeTimestamp=1508402192319, storeHost=/172.17.42.1:10911, msgId=AC112A0100002A9F0000000000000000, commitLogOffset=0, bodyCRC=613185359, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=250, CONSUME_START_TIME=1508402243397, UNIQ_KEY=AC112A0140641B6D35866042D36B0000, WAIT=true, TAGS=TagA&#125;, body=16]]]</span><br><span class="line">ConsumeMessageThread_7 Receive New Messages: [MessageExt [queueId=3, storeSize=178, queueOffset=1, sysFlag=0, bornTimestamp=1508402192388, bornHost=/172.17.42.1:55844, storeTimestamp=1508402192390, storeHost=/172.17.42.1:10911, msgId=AC112A0100002A9F00000000000002C8, commitLogOffset=712, bodyCRC=601994070, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=250, CONSUME_START_TIME=1508402243398, UNIQ_KEY=AC112A0140641B6D35866042D4040004, WAIT=true, TAGS=TagA&#125;, body=16]]]</span><br><span class="line">ConsumeMessageThread_8 Receive New Messages: [MessageExt [queueId=2, storeSize=178, queueOffset=1, sysFlag=0, bornTimestamp=1508402192400, bornHost=/172.17.42.1:55844, storeTimestamp=1508402192401, storeHost=/172.17.42.1:10911, msgId=AC112A0100002A9F00000000000004DE, commitLogOffset=1246, bodyCRC=988340972, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=250, CONSUME_START_TIME=1508402243398, UNIQ_KEY=AC112A0140641B6D35866042D4100007, WAIT=true, TAGS=TagA&#125;, body=16]]]</span><br><span class="line">ConsumeMessageThread_3 Receive New Messages: [MessageExt [queueId=1, storeSize=178, queueOffset=0, sysFlag=0, bornTimestamp=1508402192379, bornHost=/172.17.42.1:55844, storeTimestamp=1508402192382, storeHost=/172.17.42.1:10911, msgId=AC112A0100002A9F0000000000000164, commitLogOffset=356, bodyCRC=1250039395, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=250, CONSUME_START_TIME=1508402243398, UNIQ_KEY=AC112A0140641B6D35866042D3FB0002, WAIT=true, TAGS=TagA&#125;, body=16]]]</span><br><span class="line"></span><br><span class="line">17884 org.apache.rocketmq.namesrv.NamesrvStartup</span><br><span class="line">17965 org.apache.rocketmq.broker.BrokerStartup -n localhost:9876</span><br></pre></td></tr></table></figure>
<p>RocketMQ的数据目录在store下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 ~]$ tree store</span><br><span class="line">store</span><br><span class="line">├── abort</span><br><span class="line">├── checkpoint</span><br><span class="line">├── commitlog</span><br><span class="line">│   ├── 00000000000000000000</span><br><span class="line">│   └── 00000000001073741824</span><br><span class="line">├── config</span><br><span class="line">│   ├── consumerFilter.json</span><br><span class="line">│   ├── consumerOffset.json</span><br><span class="line">│   ├── delayOffset.json</span><br><span class="line">│   ├── subscriptionGroup.json</span><br><span class="line">│   ├── topics.json</span><br><span class="line">├── consumequeue</span><br><span class="line">│   └── TopicTest</span><br><span class="line">│       ├── 0</span><br><span class="line">│       │   └── 00000000000000000000</span><br><span class="line">│       ├── 1</span><br><span class="line">│       │   └── 00000000000000000000</span><br><span class="line">│       ├── 2</span><br><span class="line">│       │   └── 00000000000000000000</span><br><span class="line">│       └── 3</span><br><span class="line">│           └── 00000000000000000000</span><br><span class="line">└── index</span><br><span class="line">    └── 20171019163632344</span><br></pre></td></tr></table></figure>
<p>数据相关的文件夹有三个：</p>
<ul>
<li>commitlog：提交日志</li>
<li>consumequeue：消费队列</li>
<li>index：索引文件</li>
</ul>
<p>查看commitlog的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 ~]$ strings store/commitlog/00000000000000000000 | head -30</span><br><span class="line">Hello RocketMQ 0    TopicTest</span><br><span class="line">&gt;UNIQ_KEY</span><br><span class="line">AC112A0140641B6D35866042D36B0000</span><br><span class="line">WAIT</span><br><span class="line">true</span><br><span class="line">TAGS</span><br><span class="line">TagA</span><br><span class="line">Hello RocketMQ 1    TopicTest</span><br><span class="line">&gt;UNIQ_KEY</span><br><span class="line">AC112A0140641B6D35866042D3F50001</span><br><span class="line">WAIT</span><br><span class="line">true</span><br><span class="line">TAGS</span><br><span class="line">TagA</span><br><span class="line">Hello RocketMQ 2    TopicTest</span><br><span class="line">&gt;UNIQ_KEY</span><br><span class="line">AC112A0140641B6D35866042D3FB0002</span><br><span class="line">WAIT</span><br><span class="line">true</span><br><span class="line">TAGS</span><br><span class="line">TagA</span><br><span class="line">Hello RocketMQ 3    TopicTest</span><br></pre></td></tr></table></figure>
<p>消费者的相关配置：</p>
<ul>
<li>消费者对订阅主题的消费进度存储在<code>consumerOffset.json</code>配置文件中</li>
<li>消费者所属的消费组信息存储在<code>subscriptionGroup.json</code>配置文件中</li>
<li>消费者订阅的主题存储在<code>topics.json</code>配置文件中</li>
</ul>
<blockquote>
<p>Kafka中消费者订阅信息存储在ZooKeeper中</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 ~]$ cat store/config/consumerFilter.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"filterDataByTopic"</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">[qihuang.zheng@dp0652 ~]$ cat store/config/delayOffset.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"offsetTable"</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[qihuang.zheng@dp0652 ~]$ cat store/config/consumerOffset.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"offsetTable"</span>:&#123;</span><br><span class="line">        "TopicTest@please_rename_unique_group_name_4":&#123;0:250,1:250,2:250,3:250</span><br><span class="line">        &#125;,</span><br><span class="line">        "%RETRY%please_rename_unique_group_name_4@please_rename_unique_group_name_4":&#123;0:0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[qihuang.zheng@dp0652 ~]$ cat store/config/subscriptionGroup.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"dataVersion"</span>:&#123;</span><br><span class="line">        <span class="attr">"counter"</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">"timestamp"</span>:<span class="number">1508402243205</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"subscriptionGroupTable"</span>:&#123;</span><br><span class="line">        <span class="attr">"please_rename_unique_group_name_4"</span>:&#123;</span><br><span class="line">            <span class="attr">"brokerId"</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">"consumeBroadcastEnable"</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"consumeEnable"</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"consumeFromMinEnable"</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"groupName"</span>:<span class="string">"please_rename_unique_group_name_4"</span>,</span><br><span class="line">            <span class="attr">"notifyConsumerIdsChangedEnable"</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"retryMaxTimes"</span>:<span class="number">16</span>,</span><br><span class="line">            <span class="attr">"retryQueueNums"</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">"whichBrokerWhenConsumeSlowly"</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[qihuang.zheng@dp0652 ~]$ cat store/config/topics.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"dataVersion"</span>:&#123;</span><br><span class="line">        <span class="attr">"counter"</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="attr">"timestamp"</span>:<span class="number">1508402243219</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"topicConfigTable"</span>:&#123;</span><br><span class="line">        <span class="attr">"TopicTest"</span>:&#123;</span><br><span class="line">            <span class="attr">"order"</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"perm"</span>:<span class="number">6</span>,</span><br><span class="line">            <span class="attr">"readQueueNums"</span>:<span class="number">4</span>,</span><br><span class="line">            <span class="attr">"topicFilterType"</span>:<span class="string">"SINGLE_TAG"</span>,</span><br><span class="line">            <span class="attr">"topicName"</span>:<span class="string">"TopicTest"</span>,</span><br><span class="line">            <span class="attr">"topicSysFlag"</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">"writeQueueNums"</span>:<span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在本机测试时，没有遇到问题。但是IDE连接远程机器时，报错连接不上，这是因为服务端装了docker导致IP有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.client.exception.MQClientException: Send [3] times, still failed, cost [6915]ms, Topic: TopicTestA, BrokersSent: [dp0652, dp0652, dp0652]</span><br><span class="line">See http://rocketmq.apache.org/docs/faq/ for further details.</span><br><span class="line">    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:544)</span><br><span class="line">    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1065)</span><br><span class="line">    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1023)</span><br><span class="line">    at org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:212)</span><br><span class="line">    at org.apache.rocketmq.example.quickstart.Producer.main(Producer.java:69)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</span><br><span class="line">Caused by: org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;172.17.42.1:10909&gt; failed</span><br></pre></td></tr></table></figure>
<p>172.17.42.1这个IP地址是docker的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 rocketmq]$ ifconfig</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr CA:3E:ED:C2:67:20</span><br><span class="line">          inet addr:172.17.42.1  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line"></span><br><span class="line">em1       Link encap:Ethernet  HWaddr B0:83:FE:C7:02:B3</span><br><span class="line">          inet addr:192.168.6.52  Bcast:192.168.6.255  Mask:255.255.255.0</span><br></pre></td></tr></table></figure>
<p>用模板生成，可以看到brokerIP1就是docker的IP:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 rocketmq]$ sh bin/mqbroker -m &gt; broker.p</span><br><span class="line"></span><br><span class="line">[qihuang.zheng@dp0652 rocketmq]$ cat broker.p</span><br><span class="line">2017-10-19 17\:58\:00 INFO main - namesrvAddr=localhost:9876</span><br><span class="line">2017-10-19 17\:58\:00 INFO main - brokerIP1=172.17.42.1</span><br><span class="line">2017-10-19 17\:58\:00 INFO main - brokerName=dp0652</span><br><span class="line">2017-10-19 17\:58\:00 INFO main - brokerClusterName=DefaultCluster</span><br><span class="line">2017-10-19 17\:58\:00 INFO main - brokerId=0</span><br></pre></td></tr></table></figure>
<p>接下来重启broker:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[qihuang.zheng@dp0652 rocketmq]$ sh bin/mqshutdown broker</span><br><span class="line">The mqbroker(29723) is running...</span><br><span class="line">Send shutdown request to mqbroker(29723) OK</span><br><span class="line">[qihuang.zheng@dp0652 rocketmq]$ nohup sh bin/mqbroker -n localhost:9876 -c broker.properties &amp;</span><br></pre></td></tr></table></figure>
<p>重启后发送消息正常，这里把Topic改成TopicTestA：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendResult [sendStatus=SEND_OK, msgId=0A39F12CF5A6355DA25460935C280000, offsetMsgId=C0A8063400002A9F000000000002BEB2, messageQueue=MessageQueue [topic=TopicTestA, brokerName=dp0652, queueId=0], queueOffset=0]</span><br></pre></td></tr></table></figure>
<p>查看store，可以看到commitlog没有新增文件夹，而consumequeue则新增了TopicTestA文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">├── commitlog</span><br><span class="line">│   └── 00000000000000000000</span><br><span class="line">├── consumequeue</span><br><span class="line">│   ├── TopicTest</span><br><span class="line">│   │   ├── 0</span><br><span class="line">│   │   │   └── 00000000000000000000</span><br><span class="line">│   │   ├── 1</span><br><span class="line">│   │   │   └── 00000000000000000000</span><br><span class="line">│   │   ├── 2</span><br><span class="line">│   │   │   └── 00000000000000000000</span><br><span class="line">│   │   └── 3</span><br><span class="line">│   │       └── 00000000000000000000</span><br><span class="line">│   └── TopicTestA</span><br><span class="line">│       ├── 0</span><br><span class="line">│       │   └── 00000000000000000000</span><br><span class="line">│       ├── 1</span><br><span class="line">│       │   └── 00000000000000000000</span><br><span class="line">│       ├── 2</span><br><span class="line">│       │   └── 00000000000000000000</span><br><span class="line">│       └── 3</span><br><span class="line">│           └── 00000000000000000000</span><br></pre></td></tr></table></figure>
<h1 id="API示例">API示例</h1><h2 id="生产者">生产者</h2><p><strong>同步</strong>的生产者：<a href="http://rocketmq.apache.org/docs/simple-example/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/simple-example/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">"192.168.6.52:9876"</span>);</span><br><span class="line">producer.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTestA"</span>, <span class="string">"TagA"</span>, </span><br><span class="line">      (<span class="string">"RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class="line">    );</span><br><span class="line">    SendResult sendResult = producer.send(msg);</span><br><span class="line">    System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>
<p><strong>异步</strong>的生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index, sendResult.getMsgId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>一次性</strong>的生产者，主要用于日志收集：</p>
<p>一个 RPC 调用,通常是这样一个过程:</p>
<ol>
<li>客户端发送请求到服务器</li>
<li>服务器处理该请求</li>
<li>服务器向客户端返回应答</li>
</ol>
<p>所以一个 RPC 的耗时时间是上述三个步骤的总和,而某些场景要求耗时非常短,但是对可靠性要求并不高,<br>例如日志收集类应用,此类应用可以采用 oneway 形式调用,oneway 形式只发送请求不等待应答,<br>而发送请求在客户端实现层面仅仅是一个 os 系统调用的开销,即将数据写入客户端的 socket 缓冲区,此过程耗时通常在微秒级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendOneway(msg);</span><br></pre></td></tr></table></figure>
<p><strong>有序</strong>的生产者：<a href="http://rocketmq.apache.org/docs/order-example/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/order-example/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"example_group_name"</span>);</span><br><span class="line">producer.start();</span><br><span class="line">String[] tags = <span class="keyword">new</span> String[] &#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>, <span class="string">"TagE"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> orderId = i % <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//Create a message instance, specifying topic, tag , message key and body.</span></span><br><span class="line">    Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTestjjj"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i, (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">    SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">            Integer id = (Integer) arg;</span><br><span class="line">            <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">            <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, orderId); <span class="comment">// 最后一个参数orderId作为第二个参数的arg值</span></span><br><span class="line">    System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>
<p><strong>定时</strong>生产者：<a href="http://rocketmq.apache.org/docs/schedule-example/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/schedule-example/</a></p>
<p>定时消息是指消息发到 Broker 后,不能立刻被 Consumer 消费,要到特定的时间点或者等待特定的时间后才能被消费。<br>如果要支持任意的时间精度,在 Broker 局面,必须要做消息排序,如果再涉及到持久化,那么消息排序要不可避免的产生巨大性能开销。</p>
<p>RocketMQ 支持定时消息,但是不支持任意时间精度,仅支持特定的 level,例如定时 5s,10s,1m 等。<br>定时消息是在生产者端设置DelayTimeLevel，消费者端不做任何处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">int</span> totalMessagesToSend = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">"TestTopic"</span>, (<span class="string">"Hello scheduled message "</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// This message will be delivered to consumer 10 seconds later.</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>批量消息：<a href="http://rocketmq.apache.org/docs/batch-example/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/batch-example/</a></p>
<p>简单的批量消息只需要构造List<message>，调用producer.send()即可。不过在一个Batch中消息大小不能超过1Mib，需要程序手动进行切分。</message></p>
<h2 id="消费者">消费者</h2><p><strong>拉取</strong>消费者（PullConsumer）：</p>
<ul>
<li>首先根据Topic获取订阅的MessageQueue</li>
<li>对每个MessageQueue，都会调用pullBlockIfNotFound方法消费这个队列里的消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;MessageQueue, Long&gt; OFFSE_TABLE = <span class="keyword">new</span> HashMap&lt;MessageQueue, Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPullConsumer consumer = <span class="keyword">new</span> DefaultMQPullConsumer(<span class="string">"please_rename_unique_group_name_5"</span>);</span><br><span class="line">        consumer.start();</span><br><span class="line">        Set&lt;MessageQueue&gt; mqs = consumer.fetchSubscribeMessageQueues(<span class="string">"TopicTest1"</span>);</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqs) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"Consume from the queue: "</span> + mq + <span class="string">"%n"</span>);</span><br><span class="line">            SINGLE_MQ:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                PullResult pullResult = consumer.pullBlockIfNotFound(mq, <span class="keyword">null</span>, getMessageQueueOffset(mq), <span class="number">32</span>);</span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, pullResult);</span><br><span class="line">                putMessageQueueOffset(mq, pullResult.getNextBeginOffset());</span><br><span class="line">                <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> FOUND:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                        <span class="keyword">break</span> SINGLE_MQ;</span><br><span class="line">                    <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMessageQueueOffset</span><span class="params">(MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        Long offset = OFFSE_TABLE.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="keyword">null</span>) <span class="keyword">return</span> offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putMessageQueueOffset</span><span class="params">(MessageQueue mq, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        OFFSE_TABLE.put(mq, offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>推送</strong>消费者（PushConsumer）：</p>
<ul>
<li>订阅方法的第二个参数为<code>*</code>，表示所有的Tag，不进行过滤</li>
<li>Push推送方式采用注册消息监听器的方式，当收到Broker推送的消息，就会触发监听器的回调</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"CID_JODIE_1"</span>);</span><br><span class="line">consumer.subscribe(<span class="string">"Jodie_topic_1023"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面几个采用Push模式的消费者的监听器都一样</span></span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">        System.out.printf(Thread.currentThread().getName() + <span class="string">" Receive New Messages: "</span> + msgs + <span class="string">"%n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>广播</strong>模式的推送消费者，相比上一个示例增加了设置消息模型（<code>setMessageModel</code>），其他没有变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_1"</span>);</span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>过滤器</strong>的消费者。过滤器采用Push方式时，过滤逻辑在Broker实现，Broker把过滤过的数据发送给消费者。<br>如果过滤器采用Pull模式，所有的数据都会传送到消费者，然后在消费者端执行过滤逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"ConsumerGroupNamecc4"</span>);</span><br><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">File classFile = <span class="keyword">new</span> File(classLoader.getResource(<span class="string">"MessageFilterImpl.java"</span>).getFile());</span><br><span class="line">String filterCode = MixAll.file2String(classFile);</span><br><span class="line"><span class="comment">// 订阅方法的第二个参数是过滤器的实现类，而前面示例的第二个参数是Tag过滤</span></span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"org.apache.rocketmq.example.filter.MessageFilterImpl"</span>, filterCode);</span><br></pre></td></tr></table></figure>
<p><strong>SQL</strong>消费者（生产者发送消息时通过putUserProperty可以指定自定义的属性，除了Tag外，自定义属性也可以被过滤）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line"><span class="comment">// 订阅方法的第二个参数是消息选择器</span></span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, MessageSelector.bySql(</span><br><span class="line">    <span class="string">"(TAGS is not null and TAGS in ('TagA', 'TagB'))"</span> +</span><br><span class="line">    <span class="string">"and (a is not null and a between 0  3)"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>有序</strong>的消费者：前面几种消费者注册的监听器是：MessageListenerConcurrently，这里是MessageListenerOrderly。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"example_group_name"</span>);</span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">    AtomicLong consumeTimes = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">        context.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        System.out.printf(Thread.currentThread().getName() + <span class="string">" Receive New Messages: "</span> + msgs + <span class="string">"%n"</span>);</span><br><span class="line">        <span class="keyword">this</span>.consumeTimes.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ConsumeOrderlyStatus.ROLLBACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ConsumeOrderlyStatus.COMMIT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            context.setSuspendCurrentQueueTimeMillis(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure>
<p>消费者的监听器有两种形式：并发和有序。参考：<a href="http://rocketmq.apache.org/docs/best-practice-consumer/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/best-practice-consumer/</a></p>
<table>
<thead>
<tr>
<th>监听器</th>
<th>上下文</th>
<th>返回状态</th>
<th>返回码</th>
</tr>
</thead>
<tbody>
<tr>
<td>MessageListenerConcurrently</td>
<td>ConsumeConcurrentlyContext</td>
<td>ConsumeConcurrentlyStatus</td>
<td>CONSUME_SUCCESS</td>
</tr>
<tr>
<td>MessageListenerOrderly</td>
<td>ConsumeOrderlyContext</td>
<td>ConsumeOrderlyStatus</td>
<td>SUCCESS、ROLLBACK、COMMIT、SUSPEND_CURRENT_QUEUE_A_MOMENT</td>
</tr>
</tbody>
</table>
<p>消息消费的顺序问题：</p>
<ul>
<li>并发情况下，返回RECONSUME_LATER，表示过一会儿再消费，先去消费其他消息</li>
<li>有序情况下，返回SUSPEND_CURRENT_QUEUE_A_MOMENT，表示等一会儿再消费，无法消费其他消息</li>
</ul>
<h1 id="基本流程">基本流程</h1><h2 id="Remoting_RPC示例">Remoting RPC示例</h2><p>rocketmq-remoting模块采用Netty封装了RPC的调用，包括客户端和服务端之间的交互。</p>
<p>不同分布式系统在通信上都会实现RPC模块，比如Kafka、Hadoop等都有各自的RPC实现。</p>
<p>先来查看测试用例RemotingServerTest的使用方法：</p>
<ul>
<li>启动RemotingServer和RemotingClient</li>
<li>调用RemotingClient的invokeAsync()或者invokeSync()、invokeOneway()方法</li>
</ul>
<p>以异步调用为例，RemotingClient的invokeAsync()方法主要有三个参数：</p>
<ul>
<li>服务端地址，RPC调用需要指定服务端的地址，这样客户端才能发送请求，让服务端处理</li>
<li>远程指令（RemotingCommand），即客户端发送的请求</li>
<li>回调对象（InvokeCallback），即客户端收到服务端返回的响应结果后，如何处理</li>
</ul>
<p>RPC调用的具体步骤如下：</p>
<ul>
<li>启动客户端和服务端</li>
<li>客户端构造远程指令对象</li>
<li>客户端通过RemotingClient同步或者异步调用</li>
<li>服务端在启动时注册的处理器，会处理客户端发送的请求，即调用处理器的processRequest()方法</li>
<li>服务端处理完请求后，返回响应给客户端</li>
<li>客户端收到服务端返回的响应结果，会触发回调对象调用operationComplete()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static RemotingServer createRemotingServer() throws InterruptedException &#123;</span><br><span class="line">    NettyServerConfig config = new NettyServerConfig();</span><br><span class="line">    RemotingServer remotingServer = new NettyRemotingServer(config);</span><br><span class="line">    remotingServer.registerProcessor(0, new NettyRequestProcessor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) &#123;</span><br><span class="line">            request.setRemark(&quot;Hi &quot; + ctx.channel().remoteAddress());</span><br><span class="line">            return request;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Executors.newCachedThreadPool());</span><br><span class="line">    remotingServer.start();</span><br><span class="line">    return remotingServer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void testInvokeAsync() throws InterruptedException, RemotingConnectException,</span><br><span class="line">    RemotingTimeoutException, RemotingTooMuchRequestException, RemotingSendRequestException &#123;</span><br><span class="line"></span><br><span class="line">    final CountDownLatch latch = new CountDownLatch(1);</span><br><span class="line">    RemotingCommand request = RemotingCommand.createRequestCommand(0, null);</span><br><span class="line">    request.setRemark(&quot;messi&quot;);</span><br><span class="line">    remotingClient.invokeAsync(&quot;localhost:8888&quot;, request, 1000 * 3, new InvokeCallback() &#123;</span><br><span class="line">        public void operationComplete(ResponseFuture responseFuture) &#123;</span><br><span class="line">            latch.countDown();</span><br><span class="line">            assertThat(responseFuture.getResponseCommand().getExtFields()).hasSize(2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    latch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RemotingServer的registerProcessor()方法有三个参数：</p>
<ul>
<li>请求编码，比如SEND_MESSAGE表示（生产者）客户端发送消息的请求</li>
<li>请求处理器，比如服务端如何处理客户端发送消息的处理器，实现类为：SendMessageProcessor</li>
<li>处理线程，每种请求编码都对应一个处理线程池。如果没有指定，则使用默认的线程池</li>
</ul>
<p>客户端调用服务端有三种方式：同步（Sync）、异步（Async）、一次性（OneWay）。前两种有响应结果，最后一种不产生响应结果。</p>
<h2 id="Netty_RPC">Netty RPC</h2><p><code>NettyRemotingServer</code>在启动时，会绑定NettyServerHandler。Netty RPC的特点如下：</p>
<ul>
<li>请求和响应都是用RemotingCommand对象来表示</li>
<li>服务端（NettyRemotingServer）和客户端（NettyRemotingClient）实现了抽象的NettyRemotingAbstract</li>
<li>抽象类根据不同的指令类型调用不同的处理方法，比如处理请求调用processRequestCommand，处理响应调用processResponseCommand</li>
</ul>
<p>下面举例客户端和服务端执行一次RPC调用链路的过程：</p>
<ul>
<li>客户端发送请求给服务端，通过Netty的Channel发送请求给服务端</li>
<li>服务端处理客户端发送的请求，NettyServerHandler接收的消息类型为REQUEST_COMMAND，调用processRequestCommand方法</li>
<li>服务端处理完成后，通过Netty的Channel发送响应结果给客户端</li>
<li>客户端处理服务端发送的响应，NettyClientHandler接收的消息类型为RESPONSE_COMMAND，调用processResponseCommand方法</li>
</ul>
<p>NettyRemotingAbstract用<code>processorTable</code>变量记录了请求编码、处理器、线程池之间的关系。</p>
<ul>
<li>每个请求编码都对应了一种唯一的处理器，相同请求编码的处理器是相同的</li>
<li>由于处理器与线程池组成一对，所以相同请求编码的请求在相同的线程池中执行</li>
</ul>
<p>不同的请求编码在不同的线程池中运行，以发送消息和消费消息为例：</p>
<table>
<thead>
<tr>
<th>请求编码（request code）</th>
<th>处理器</th>
<th>线程池</th>
</tr>
</thead>
<tbody>
<tr>
<td>SEND_MESSAGE</td>
<td>SendMessageProcessor</td>
<td>ExecutorService#1</td>
</tr>
<tr>
<td>GET_MESSAGE</td>
<td>PullMessageProcessor</td>
<td>ExecutorService#2</td>
</tr>
</tbody>
</table>
<p>以经典的RPC通信模型来看，客户端向服务端发起RPC调用请求。那么<code>processorTable</code>主要针对服务端，<code>responseTable</code>则主要针对客户端。</p>
<ul>
<li>客户端发起RPC调动时，会创建异步的响应对象，并放入将opaque和ResponseFuture的映射关系放入responseTable</li>
<li>当客户端收到服务端发送的响应结果后，会将opaque以及ResponseFuture从responseTable中移除</li>
</ul>
<p>那么opaque是如何在请求和响应之间进行关联的呢？下面代码中的注释说明了opaque在请求和响应之间的设置和获取流程。</p>
<blockquote>
<p>opaque表示：请求发起方在同一连接上不同的请求标识代码,多线程连接复用使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">protected final HashMap&lt;Integer/* request code */, Pair&lt;NettyRequestProcessor, ExecutorService&gt;&gt; processorTable =</span><br><span class="line">    new HashMap&lt;Integer, Pair&lt;NettyRequestProcessor, ExecutorService&gt;&gt;(64);</span><br><span class="line"> protected final ConcurrentMap&lt;Integer /* opaque */, ResponseFuture&gt; responseTable =</span><br><span class="line">    new ConcurrentHashMap&lt;Integer, ResponseFuture&gt;(256);</span><br><span class="line"></span><br><span class="line">public void processMessageReceived(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception &#123;</span><br><span class="line">    final RemotingCommand cmd = msg;</span><br><span class="line">    if (cmd != null) &#123;</span><br><span class="line">        switch (cmd.getType()) &#123;</span><br><span class="line">            case REQUEST_COMMAND:</span><br><span class="line">                processRequestCommand(ctx, cmd);</span><br><span class="line">                break;</span><br><span class="line">            case RESPONSE_COMMAND:</span><br><span class="line">                processResponseCommand(ctx, cmd);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理请求，比如服务端处理客户端发送的请求，NettyServerHandler会调用到这里</span><br><span class="line">public void processRequestCommand(final ChannelHandlerContext ctx, final RemotingCommand cmd) &#123;</span><br><span class="line">    final Pair&lt;NettyRequestProcessor, ExecutorService&gt; matched = this.processorTable.get(cmd.getCode());</span><br><span class="line">    // 4. 从请求对象中获取opaque，那么什么时候opaque设置到请求中？</span><br><span class="line">    // 这里的cmd实际上是步骤3的request，因为步骤1已经有opaque，所以这里也能取到opaque</span><br><span class="line">    final int opaque = cmd.getOpaque();</span><br><span class="line">    final RemotingCommand response = pair.getObject1().processRequest(ctx, cmd);</span><br><span class="line">    // 5. 将opaque设置到响应对象中</span><br><span class="line">    response.setOpaque(opaque);</span><br><span class="line">    // 6. 发送响应对象给客户端</span><br><span class="line">    ctx.writeAndFlush(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理响应，比如客户端处理服务端发送的响应，NettyClientHandler会调用到这里</span><br><span class="line">public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) &#123;</span><br><span class="line">    // 7. 从响应对象中获取opaque，那么什么时候opaque设置到响应里？答案在步骤5中</span><br><span class="line">    // 这里的cmd是步骤5的response，而response的opaque来自于request</span><br><span class="line">    final int opaque = cmd.getOpaque();</span><br><span class="line">    // 8. 根据opaque从responseTable中获取出对应的ResponseFuture</span><br><span class="line">    final ResponseFuture responseFuture = responseTable.get(opaque);</span><br><span class="line">    if (responseFuture != null) &#123;</span><br><span class="line">        responseFuture.setResponseCommand(cmd);</span><br><span class="line">        responseFuture.release();</span><br><span class="line">        // 9. 将opaque与ResponseFuture的映射关系从responseTable中移除，与步骤2互相对应</span><br><span class="line">        responseTable.remove(opaque);</span><br><span class="line">        // 执行客户端在发送RPC调用时定义的回调函数</span><br><span class="line">        if (responseFuture.getInvokeCallback() != null) &#123;</span><br><span class="line">            executeInvokeCallback(responseFuture);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            responseFuture.putResponse(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端发起RPC调用</span><br><span class="line">public RemotingCommand invokeSyncImpl(final Channel channel, final RemotingCommand request) &#123;</span><br><span class="line">    // 1. 从请求中获取opaque</span><br><span class="line">    final int opaque = request.getOpaque();</span><br><span class="line">    final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, null, null);</span><br><span class="line">    // 2. 创建ResponseFuture，并记录到responseTable</span><br><span class="line">    this.responseTable.put(opaque, responseFuture);</span><br><span class="line">    final SocketAddress addr = channel.remoteAddress();</span><br><span class="line">    // 3. 发起RPC调用</span><br><span class="line">    channel.writeAndFlush(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生产者发送消息">生产者发送消息</h2><p>以example/quickstart下的Producer发送消息为例，入口方法走到DefaultMQProducerImpl的sendDefaultImpl()方法。</p>
<p>发送消息过程涉及下面几个步骤：</p>
<ul>
<li>tryToFindTopicPublishInfo()：根据消息的Topic获取TopicPublishInfo</li>
<li>selectOneMessageQueue()：选择一个MessageQueue</li>
<li>sendKernelImpl()：调用内核的发送方法</li>
<li>如果是同步调用，返回SendResult，否则返回空</li>
</ul>
<p>接下来进入DefaultMQProducerImpl的内核发送方法，主要的参数有：Message、MessageQueue、TopicPublishInfo</p>
<ul>
<li>如果有Hook，构造SendMessageContext，将Message、MessageQueue等都设置为上下文对象的成员变量</li>
<li>构造SendMessageRequestHeader</li>
<li>从MQClientFactory获取getMQClientAPIImpl()实现类MQClientAPIImpl，调用sendMessage()方法</li>
</ul>
<p>接下来进入MQClientAPIImpl的sendMessage()方法</p>
<ul>
<li>根据RequestCode.SEND_MESSAGE（请求编码）和SendMessageRequestHeader（请求头）创建RemotingCommand对象</li>
<li>设置请求的body为消息内容：request.setBody(msg.getBody())</li>
<li>调用remotingClient.invokeAsync()或者invokeSync()方法</li>
<li>对于同步调用，因为要等待结果返回，所以会立即调用processSendResponse()</li>
<li>processSendResponse()方法返回一个SendResult对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private SendResult sendMessageSync(</span><br><span class="line">    final String addr, // Broker的地址</span><br><span class="line">    final String brokerName, // Broker的名字</span><br><span class="line">    final Message msg, // 消息内容</span><br><span class="line">    final long timeoutMillis,</span><br><span class="line">    final RemotingCommand request // 请求对象</span><br><span class="line">) &#123;</span><br><span class="line">    // RPC调用示例，这里的客户端是生产者，通过MQClientAPIImpl调用</span><br><span class="line">    RemotingCommand response = this.remotingClient.invokeSync(addr, request, timeoutMillis);</span><br><span class="line">    assert response != null;</span><br><span class="line">    return this.processSendResponse(brokerName, msg, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者通过MQClientAPIImpl发起RPC调用，request请求对象的编码是SEND_MESSAGE。这里的地址指的是Broker的地址，而不是NameServer。<br>虽然生产者连接的是NameServer，但这中间会有选择MessageQueue，再选择Broker的过程，由于这里先关注整体的流程，暂时不去分析具体的细节。</p>
<p>客户端通过<code>RemotingClient</code>调用了服务端Broker，接下来看服务端<code>BrokerController</code>的处理。</p>
<p>BrokerController启动时会为各种请求类型注册不同的请求处理器，比如SEND_MESSAGE注册了SendMessageProcessor处理器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void registerProcessor() &#123;</span><br><span class="line">    SendMessageProcessor sendProcessor = new SendMessageProcessor(this);</span><br><span class="line">    // SendMessageProcessor有两个Hook：发送消息和消费消息的Hook。</span><br><span class="line">    sendProcessor.registerSendMessageHook(sendMessageHookList);</span><br><span class="line">    sendProcessor.registerConsumeMessageHook(consumeMessageHookList);</span><br><span class="line">    this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, this.sendMessageExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SendMessageProcessor的processRequest()方法会处理生产者客户端发送的SEND_MESSAGE请求。</p>
<p>客户端在发送请求之前构建了<code>SendMessageContext</code>和<code>SendMessageRequestHeader</code>，这里对应的会首先从RemotingCommand反解析出着两个对象</p>
<ul>
<li>解析请求的body，创建MessageExtBrokerInner对象</li>
<li>获取MessageStore，并调用putMessage方法，传入MessageExtBrokerInner对象</li>
<li>返回PutMessageResult，并调用handlePutMessageResult方法</li>
<li>最后返回的是一个RemotingCommand响应对象，会返回给客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public RemotingCommand processRequest(ChannelHandlerContext ctx,</span><br><span class="line">    RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line">    SendMessageContext mqtraceContext;</span><br><span class="line">    switch (request.getCode()) &#123;</span><br><span class="line">        case RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            return this.consumerSendMsgBack(ctx, request);</span><br><span class="line">        default: // SEND_MESSAGE的处理逻辑...</span><br><span class="line">            SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            this.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line">            RemotingCommand response;</span><br><span class="line">            if (requestHeader.isBatch()) &#123;</span><br><span class="line">                response = this.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                response = this.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line">            this.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line">            return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来进入DefaultMessageStore的putMessage()方法，这个方法会调用CommitLog的putMessage()方法</p>
<ul>
<li>BrokerController和SendMessageProcessor都在broker模块</li>
<li>MessageStore和CommitLog则在store模块</li>
</ul>
<p>CommitLog首先获取最近的MappedFile，然后追加消息到映射文件中。</p>
<ul>
<li>追加消息的回调类DefaultAppendMessageCallback是执行数据写入文件的真正方法。</li>
<li>追加完成后，有多种的磁盘刷写方式，比如同步和异步</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public PutMessageResult putMessage(final MessageExtBrokerInner msg) &#123;</span><br><span class="line">    MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();</span><br><span class="line">    AppendMessageResult result = mappedFile.appendMessage(msg, this.appendMessageCallback);</span><br><span class="line">    PutMessageResult putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line">    return putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，我们省略了具体写入到CommitLog中的细节，以及如何处理磁盘的刷写、HA等细枝末节。实际上，到这里为止，<br>生产者客户端发起RPC调用，到服务端处理请求，服务端返回响应，客户端接收响应结果，这个过程已经分析完毕了。</p>
<h2 id="Pull_Consumer">Pull Consumer</h2><p>PULL_MESSAGE对应的处理器是PullMessageProcessor。与生产消息调用MessageStore的putMessage()类似，<br>消费消息调用MessageStore的getMessage()方法，并返回GetMessageResult。</p>
<table>
<thead>
<tr>
<th>请求编码</th>
<th>消息处理器</th>
<th>消息存储</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>SEND_MESSAGE</td>
<td>SendMessageProcessor</td>
<td>putMessage()</td>
<td>PutMessageResult</td>
</tr>
<tr>
<td>PULL_MESSAGE</td>
<td>PullMessageProcessor</td>
<td>getMessage()</td>
<td>GetMessageResult</td>
</tr>
</tbody>
</table>
<p>消费者还需要提交偏移量，对应ConsumerOffsetManager的commitOffset()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend) &#123;</span><br><span class="line">    final GetMessageResult getMessageResult = this.brokerController.getMessageStore().getMessage(</span><br><span class="line">            requestHeader.getConsumerGroup(),   // 消费组</span><br><span class="line">            requestHeader.getTopic(),           // 主题</span><br><span class="line">            requestHeader.getQueueId(),         // 队列编号</span><br><span class="line">            requestHeader.getQueueOffset(),     // 队列的偏移量</span><br><span class="line">            requestHeader.getMaxMsgNums(),      // 最大的消息数量</span><br><span class="line">            messageFilter);                     // 过滤器</span><br><span class="line">    // .......................................................</span><br><span class="line">    if (storeOffsetEnable) &#123;</span><br><span class="line">        this.brokerController.getConsumerOffsetManager().commitOffset(</span><br><span class="line">            RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">            requestHeader.getConsumerGroup(), </span><br><span class="line">            requestHeader.getTopic(), </span><br><span class="line">            requestHeader.getQueueId(), </span><br><span class="line">            requestHeader.getCommitOffset());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储层设计到文件操作时，生产消息会写到CommitLog，消费消息则会调用getMessage方法，给定偏移量和大小。</p>
<h1 id="设计">设计</h1><h2 id="架构">架构</h2><p><img src="http://rocketmq.apache.org/assets/images/rmq-basic-arc.png" alt="arch"></p>
<ul>
<li><strong>NameServer Cluster</strong>：<br>Name Servers provide lightweight <em>service discovery and routing</em>.<br>Each Name Server records full routing information（路由信息表）,<br>provides corresponding reading and writing service,<br>and supports fast storage expansion.</li>
<li><strong>Broker Cluster</strong>：<br>Brokers take care of message storage by providing lightweight TOPIC and QUEUE mechanisms.<br>They support the Push and Pull model, contains fault tolerance mechanism (2 copies or 3 copies),<br>and provides strong padding of peaks and capacity of accumulating hundreds of billion messages in their original time order.<br>In addition, Brokers provide disaster recovery, rich metrics statistics, and alert mechanisms, all of which are lacking in traditional messaging systems.</li>
<li><strong>Producer Cluster</strong>：<br>Producers support distributed deployment.<br>Distributed Producers send messages to the Broker cluster through multiple load balancing modes.<br>The sending processes support fast failure and have low latency.</li>
<li><strong>Consumer Cluster</strong>：<br>Consumers support distributed deployment in the Push and Pull model as well.<br>It also supports cluster consumption（集群消费） and message broadcasting（消息广播）.<br>It provides real-time message subscription mechanism and can meet most consumer requirements. R</li>
</ul>
<p>NameServer is a fully functional server, which mainly includes two features:</p>
<ul>
<li>Broker Management, NameServer accepts the <em>register</em> from Broker cluster and provides <em>heartbeat</em> mechanism to check whether a broker is alive.</li>
<li>Routing Management, each NameServer will hold whole <em>routing info</em> about the broker cluster and the <em>queue info</em> for clients query.</li>
</ul>
<p>Broker server is responsible for message store and delivery, message query, HA guarantee, and so on.</p>
<ul>
<li>Remoting Module, the entry of broker, handles the requests from clients（处理客户端请求）.</li>
<li>Client Manager, manages the clients (Producer/Consumer) and maintains topic subscription of consumer（维护消费者的主题订阅）.</li>
<li>Store Service, provides simple APIs to store or query message in physical disk（磁盘文件存储和查询消息）.</li>
<li>HA Service, provides data sync feature between master broker and slave broker（主从节点的数据同步）.</li>
<li>Index Service, builds index for messages by specified key and provides quick message query（构建消息索引）.</li>
</ul>
<p>Name server follows the share-nothing design paradigm. Brokers send heartbeat data to all name servers.<br>Producers and consumers can query meta data from any of name servers available while sending / consuming messages.</p>
<p>Brokers can be divided into two categories according to their roles: master and slave.<br>Master brokers provide <em>RW</em> access while slave brokers only accept <em>read</em> access.</p>
<p>To deploy a high-availability RocketMQ cluster with no single point of failure, a series of broker sets should be deployed.<br>A broker set contains one master with brokerId set to 0 and several slaves with non-zero brokerIDs.<br>All of the brokers in one set have the same brokerName. In serious scenarios,<br>we should have at least two brokers in one broker set. Each topic resides in two or more brokers.</p>
<p>Broker is a major component of the RocketMQ system.<br>It receives messages sent from producers, store them and prepare to handle pull requests from consumers.<br>It also stores message related meta data, including consumer groups, consuming progress offsets and topic / queue info.</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021122552876" alt="mqs"></p>
<h2 id="物理部署结构（服务端）">物理部署结构（服务端）</h2><p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019140724552" alt="brokers"></p>
<p>Name Server 是一个几乎无状态节点,可集群部署,节点之间无任何信息同步。</p>
<p>Broker 部署相对复杂,Broker 分为 Master 与 Slave,<br>一个 Master 可以对应多个 Slave, 但是一个 Slave 只能对应一个 Master,<br>Master 与 Slave 的对应关系通过指定相同的 BrokerName,不同的 BrokerId 来定义,<br>BrokerId为 0 表示 Master,非 0 表示 Slave。Master 也可以部署多个。<br><strong>每个 Broker 与 Name Server 集群中的所有节点建立长连接,定时注册 Topic 信息到所有 Name Server。</strong></p>
<p>Producer 与 Name Server 集群中的其中一个节点(随机选择)建立长连接,<br>定期从 Name Server 取 Topic 路由信息,<br>并<strong>向提供 Topic 服务的 Master 建立长连接</strong>,<br>且定时向 Master 发送心跳。<br>Producer 完全无状态,可集群部署。  </p>
<p>Consumer 与 Name Server 集群中的其中一个节点(随机选择)建立长连接,<br>定期从 Name Server 取 Topic 路由信息,<br>并<strong>向提供 Topic 服务的 Master、Slave 建立长连接</strong>,<br>且定时向 Master、Slave 发送心跳。<br>Consumer 既可以从 Master 订阅消息,也可以从 Slave 订阅消息,订阅规则由 Broker 配置决定。</p>
<h2 id="逻辑部署结构（客户端）">逻辑部署结构（客户端）</h2><p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019141837964" alt="logical"></p>
<p><strong>Producer Group</strong> 用来表示一个发送消息应用,一个 Producer Group 下包含多个 Producer 实例,<br>可以是多台机器,也可以是一台机器的多个进程,或者一个进程的多个 Producer 对象。<br>一个 Producer Group 可以发送多个 Topic 消息,Producer Group 作用如下:  </p>
<ol>
<li>标识一类 Producer</li>
<li>可以通过运维工具查询这个发送消息应用下有多个 Producer 实例</li>
<li>发送分布式事务消息时,如果 Producer 中途意外宕机,Broker 会主动回调 Producer Group 内的任意一台机器来确认事务状态</li>
</ol>
<p><strong>Consumer Group</strong> 用来表示一个消费消息应用,一个 Consumer Group 下包含多个 Consumer 实例,<br>可以是多台机器,也可以是多个进程,或者是一个进程的多个 Consumer 对象。<br>一个 Consumer Group 下的多个 Consumer 以均摊/集群（CLUSTER）方式消费消息,<br>如果设置为广播方式(BROADCAST),那么这个 Consumer Group 下的每个实例都消费全量数据。  </p>
<h2 id="存储结构">存储结构</h2><p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019195642571" alt="store"></p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019195656785" alt="store"></p>
<ol>
<li>所有数据单独存储到一个 Commit Log,完全顺序写,随机读。<br>RocketMQ 的所有消息都是持久化,先写入系统 PAGECACHE,然后刷盘,可以保证内存不磁盘都有一份数据, 访问时,直接从内存读叏。</li>
<li>对最终用户展现的队列(ConsumeQueue)实际只存储消息在CommitLog的位置信息,并且串行方式刷盘。</li>
<li>消费者的读取流程是：先读ConsumeQueue,再读CommitLog</li>
<li>由于ConsumeQueue存储数据量极少,并且是顺序读,在PAGECACHE预读作用下,<br>ConsumeQueue的读性能几乎与内存一致,即使堆积情况下。所以可认为 Consume Queue 完全不会阻碍读性能。</li>
<li>要保证CommitLog与ConsumeQueue完全的一致,增加了编程的复杂度。<br>Commit Log 中存储了所有的元信息,包含消息体,类似于 Mysql、Oracle 的 redolog,<br>所以只要有 Commit Log 在,Consume Queue 即使数据丢失,仍然可以恢复出来。  </li>
</ol>
<p>总结一句话：生产消息时先写入PageCache，然后刷写到磁盘。  </p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171019201635395" alt="pagecache"></p>
<p>同步刷盘与异步刷盘的唯一区别是异步刷盘写完 PAGECACHE 直接返回,而同步刷盘需要等待刷盘完成才返回, 同步刷盘流程如下:  </p>
<ol>
<li>写入 PAGECACHE 后,线程等待,通知刷盘线程刷盘。</li>
<li>刷盘线程刷盘后,唤醒前端等待线程,可能是一批线程。</li>
<li>前端等待线程向用户返回成功。</li>
</ol>
<p>读取消息的ConsumeQueue文件也会加载到PageCache，读PageCache和内存速度差不多。</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021085345842" alt="pc"></p>
<ol>
<li>Producer 发送消息,消息从 socket 进入 java 堆。</li>
<li>Producer 发送消息,消息从 java 堆转入 PAGACACHE,物理内存。</li>
<li>Producer 发送消息,由异步线程刷盘,消息从 PAGECACHE 刷入磁盘。</li>
<li>Consumer 拉消息(正常消费),消息直接从PAGECACHE(数据在物理内存)转入socket,到达consumer,不经过 java 堆。<br>这种消费场景最多,线上 96G 物理内存,按照 1K 消息算,可以在物理内存缓存 1 亿条消息。</li>
<li>Consumer 拉消息(异常消费),消息直接从 PAGECACHE(数据在虚拟内存)转入 socket。</li>
<li>Consumer 拉消息(异常消费),由于 socket 访问了虚拟内存,产生缺页中断,此时会产生磁盘 IO,<br>从磁盘 Load 消息到 PAGECACHE,然后直接从 socket 发出去。</li>
<li>同5</li>
<li>同6</li>
</ol>
<h2 id="负载均衡（7-8/7-9）">负载均衡（7.8/7.9）</h2><p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021145704818" alt="loadbalance"></p>
<h2 id="消息查询(TODO_7-3)">消息查询(TODO 7.3)</h2><h3 id="按照MessageId查询">按照MessageId查询</h3><h3 id="按照MessageKey查询">按照MessageKey查询</h3><h2 id="消息过滤(TODO_7-4)">消息过滤(TODO 7.4)</h2><p>有两种类型的消息过滤：</p>
<ul>
<li>Broker 端消息过滤：在 Broker 中,按照 Consumer 的要求做过滤,优点是减少了对于 Consumer 无用消息的网络传输。缺点是增加了 Broker 的负担,实现相对复杂。</li>
<li>Consumer 端消息过滤：这种过滤方式可由应用完全自定义实现,但是缺点是很多无用的消息要传输到 Consumer 端。</li>
</ul>
<h2 id="长轮询Pull(TODO_7-5)">长轮询Pull(TODO 7.5)</h2><p>RocketMQ 的 Consumer 都是从 Broker 拉消息来消费,但是为了能做到实时收消息,<br>RocketMQ 使用长轮询方式,可以保证消息实时性同 Push 方式一致。简单说就是<strong>长轮询Pull = Push</strong>。</p>
<h2 id="顺序消息(TODO_7-6)">顺序消息(TODO 7.6)</h2><p>消息有序指的是一类消息消费时,能按照发送的顺序来消费。<br>例如:一个订单产生了 3 条消息,分别是订单创建,订单付款,订单完成。<br>消费时,要按照这个顺序消费才能有意义。但是同时订单之间是可以并行消费的。</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021144845680" alt="order"></p>
<p>缺点：</p>
<ul>
<li>发送顺序消息无法利用集群 FailOver 特性<br>􏰀- 消费顺序消息的并行度依赖于队列数量（MessageQueue的数量）<br>􏰀- 队列热点问题,个别队列由于哈希不均导致消息过多,消费速度跟不上,产生消息堆积问题 􏰀 </li>
<li>遇到消息失败的消息,无法跳过,当前队列消费暂停（等一段时间再消费）</li>
</ul>
<h2 id="消费线程(单队列并行消费,_7-10)">消费线程(单队列并行消费, 7.10)</h2><p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021133510386" alt="singlequeue"></p>
<p>单队列并行消费采用滑动窗口方式并行消费,如图所示,3~7的消息在一个滑动窗口区间,可以有多个线程并行消费,但是每次提交的 Offset 都是最小 Offset,例如 3。</p>
<p>修改消费并行度的两种方法：</p>
<ol>
<li>同一个 ConsumerGroup 下,通过增加 Consumer 实例数量来提高并行度（超过订阅队列数的 Consumer 实例无效）。<br>可以通过加机器,或者在已有机器启动多个进程的方式。</li>
<li>提高单个 Consumer 的消费并行线程,通过修改两个参数：consumeThreadMin/consumeThreadMax。</li>
</ol>
<p>批量方式消费：</p>
<p>某些业务流程如果支持批量方式消费,则可以很大程度上提高消费吞吏量,例如订单扣款类应用,<br>一次处理一个订单耗时 1 秒钟,一次处理 10 个订单可能也只耗时 2 秒钟,这样即可大幅度提高消费的吞吏量。<br>通过设置 consumer 的 consumeMessageBatchMaxSize 返个参数,<br>默认是 1,即一次只消费一条消息,例如设置为 N,那么每次消费的 消息数小于等于 N。</p>
<h2 id="消息堆积、消息重试">消息堆积、消息重试</h2><ul>
<li>消息堆积（4.12）和消息重试（4.15）</li>
<li>解决办法（7.15）</li>
<li>跳过非重要消息（14.3）</li>
</ul>
<h2 id="事务(TODO)">事务(TODO)</h2><p>分布式事务涉及到两阶段提交问题,在数据存储方面的方面必然需要 KV 存储的支持,<br>因为第二阶段的提交回滚需要修改消息状态,一定涉及到根据 Key 去查找 Message 的动作。<br>RocketMQ 在第二阶段绕过了根据 Key 去查找 Message 的问题,<br>采用第一阶段发送 Prepared 消息时,拿到了消息的 Offset,<br>第二阶段通过 Offset 去访问消息, 并修改状态,Offset 就是数据的地址。</p>
<p>RocketMQ 这种实现事务方式,没有通过 KV 存储做,而是通过 Offset 方式,<br>存在一个显著缺陷,即通过 Offset 更改数据,会令系统的脏页过多,需要特别关注。</p>
<p><img src="https://images.weserv.nl/?url=http://img.blog.csdn.net/20171021151527711" alt="trans"></p>
<h3 id="Producer_Group">Producer Group</h3><p>Producers of the same role are grouped together.<br>A different producer instance of the same producer group<br>may be contacted by a broker to commit or roll back a transaction<br>in case the original producer crashed after the transaction.</p>
<p>Warning: Considering the provided producer is sufficiently powerful at sending messages,<br>only one instance is allowed per producer group to avoid unnecessary initialization of producer instances.</p>
<h2 id="扩容">扩容</h2><p>扩容是整个系统中的很重要的一个环节。在保证顺序的情况下进行扩容的难度会更大。<br>基本的策略是让向一个队列写入数据的消息发送者能够知道应该把消息写入迁移到新的队列中，<br>并且需要让消息的订阅者知道，当前的队列消费完数据后需要迁移到新队列去消费消息。关键点如下:</p>
<ul>
<li>原队列在开始扩容后需要有一个标志，即便有新消息过来，也不再接收。</li>
<li>通知消息发送端新的队列的位置。</li>
<li>对于消息接受端，对原来队列的定位会收到新旧两个位置，当旧队列的数据接受完毕后，则会只关心新队列的位置，完成切换。</li>
</ul>
<p>那么对于Metaq顺序消息，如何做到不停写扩容呢？我说说自己的看法：<br>在队列扩容的时候考虑到需要处理最新的消息服务，为了不丢失这部分消息，<br>可以采取让Producer暂存消息在本地磁盘设备中，<br>等扩容完成后再与Broker交互。这是我目前能想到的不停写扩容方式。</p>
<h1 id="参考文档">参考文档</h1><ul>
<li>RocketMQ原理简介</li>
<li>RocketMQ开发指南</li>
<li>&lt;pull类型消息中间件-消息服务端(三)&gt;(<a href="http://www.cnblogs.com/zhulongchao/p/5792770.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhulongchao/p/5792770.html</a>)</li>
</ul>

      
    </div>
    
  </div>
  
    
<div class="copyright">
  <p><span>本文标题:</span><a href="/2017/10/18/Midd-RocketMQ/">深入解析中间件之-RocketMQ</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 任何忧伤,都抵不过世界的美丽 的个人博客">任何忧伤,都抵不过世界的美丽</a></p>
  <p><span>发布时间:</span>2017年10月18日 - 00时00分</p>
  <p><span>最后更新:</span>2019年02月14日 - 21时42分</p>
  <p>
    <span>原始链接:</span><a href="/2017/10/18/Midd-RocketMQ/" title="深入解析中间件之-RocketMQ">http://github.com/zqhxuyuan/2017/10/18/Midd-RocketMQ/</a>
    <span class="btn" data-clipboard-text="原文: http://github.com/zqhxuyuan/2017/10/18/Midd-RocketMQ/　　作者: 任何忧伤,都抵不过世界的美丽" title="点击复制文章链接">
        <i class="fa fa-clipboard"></i>
    </span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。</p>
  <script src="/js/clipboard.min.js"></script>
  <script> var clipboard = new Clipboard('.btn'); </script>
</div>
<style type="text/css">
  .copyright p .btn {
    margin-left: 1em;
  }
  .copyright:hover p .btn::after {
    content: "复制"
  }
  .copyright p .btn:hover {
      color: gray;
      cursor: pointer;
    };
</style>



<nav id="article-nav">
  
    <div id="article-nav-newer" class="article-nav-title">
      <a href="/2017/10/22/BookNote-DDIA/">
        读书笔记-Design Data Intensive Applications
      </a>
    </div>
  
  
    <div id="article-nav-older" class="article-nav-title">
      <a href="/2017/10/18/Midd-TCC-Transactions/">
        深入解析中间件之-TCC事务
      </a>
    </div>
  
</nav>

  
  
    <div class="post-donate">
	<br>
	<p>
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
		   招人广告：对蚂蚁金服中间件感兴趣的可以发邮件到：qihuang.zqh at antfin.com
        </span>
        <br>
    </div>  
	<div id="donate_guide" class="donate_bar center hidden">
		<img src="/img/zhifubao.png" alt="支付宝打赏"> 
		<img src="/img/weixin.png" alt="微信打赏">  
    </div>
	<script type="text/javascript">
		document.getElementById('btn_donate').onclick = function(){
			$('#donate_board').addClass('hidden');
			$('#donate_guide').removeClass('hidden');
		}
	</script>
</p></div>
  
</article>

<!-- 默认显示文章目录，在文章---前输入toc: false关闭目录 -->
<!-- Show TOC and tocButton in default, Hide TOC via putting "toc: false" before "---" at [post].md -->
<div id="toc" class="toc-article">
<strong class="toc-title">文章目录</strong>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#QuickStart"><span class="toc-number">1.</span> <span class="toc-text">QuickStart</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API示例"><span class="toc-number">2.</span> <span class="toc-text">API示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#生产者"><span class="toc-number">2.1.</span> <span class="toc-text">生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消费者"><span class="toc-number">2.2.</span> <span class="toc-text">消费者</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本流程"><span class="toc-number">3.</span> <span class="toc-text">基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Remoting_RPC示例"><span class="toc-number">3.1.</span> <span class="toc-text">Remoting RPC示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty_RPC"><span class="toc-number">3.2.</span> <span class="toc-text">Netty RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生产者发送消息"><span class="toc-number">3.3.</span> <span class="toc-text">生产者发送消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pull_Consumer"><span class="toc-number">3.4.</span> <span class="toc-text">Pull Consumer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#设计"><span class="toc-number">4.</span> <span class="toc-text">设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#架构"><span class="toc-number">4.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理部署结构（服务端）"><span class="toc-number">4.2.</span> <span class="toc-text">物理部署结构（服务端）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑部署结构（客户端）"><span class="toc-number">4.3.</span> <span class="toc-text">逻辑部署结构（客户端）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储结构"><span class="toc-number">4.4.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#负载均衡（7-8/7-9）"><span class="toc-number">4.5.</span> <span class="toc-text">负载均衡（7.8/7.9）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息查询(TODO_7-3)"><span class="toc-number">4.6.</span> <span class="toc-text">消息查询(TODO 7.3)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#按照MessageId查询"><span class="toc-number">4.6.1.</span> <span class="toc-text">按照MessageId查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按照MessageKey查询"><span class="toc-number">4.6.2.</span> <span class="toc-text">按照MessageKey查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息过滤(TODO_7-4)"><span class="toc-number">4.7.</span> <span class="toc-text">消息过滤(TODO 7.4)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#长轮询Pull(TODO_7-5)"><span class="toc-number">4.8.</span> <span class="toc-text">长轮询Pull(TODO 7.5)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顺序消息(TODO_7-6)"><span class="toc-number">4.9.</span> <span class="toc-text">顺序消息(TODO 7.6)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消费线程(单队列并行消费,_7-10)"><span class="toc-number">4.10.</span> <span class="toc-text">消费线程(单队列并行消费, 7.10)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息堆积、消息重试"><span class="toc-number">4.11.</span> <span class="toc-text">消息堆积、消息重试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务(TODO)"><span class="toc-number">4.12.</span> <span class="toc-text">事务(TODO)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Producer_Group"><span class="toc-number">4.12.1.</span> <span class="toc-text">Producer Group</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩容"><span class="toc-number">4.13.</span> <span class="toc-text">扩容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文档"><span class="toc-number">5.</span> <span class="toc-text">参考文档</span></a></li></ol>
</div>
<style type="text/css">
  .left-col .switch-btn {
    display: none;
  }
  .left-col .switch-area {
    display: none;
  }
</style>

<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">
<script type="text/javascript">
  var toc_button= document.getElementById("tocButton");
  var toc_div= document.getElementById("toc");
  /* Show or hide toc when click on tocButton.
  通过点击设置的按钮显示或者隐藏文章目录.*/
  toc_button.onclick=function(){
  if(toc_div.style.display=="none"){
  toc_div.style.display="block";
  toc_button.value="隐藏目录";
  document.getElementById("switch-btn").style.display="none";
  document.getElementById("switch-area").style.display="none";
  }
  else{
  toc_div.style.display="none";
  toc_button.value="显示目录";
  document.getElementById("switch-btn").style.display="block";
  document.getElementById("switch-area").style.display="block";
  }
  }
    if ($(".toc").length < 1) {
        $("#toc").css("display","none");
        $("#tocButton").css("display","none");
        $(".switch-btn").css("display","block");
        $(".switch-area").css("display","block");
    }
</script>


    <style>
        .toc {
            white-space: nowrap;
            overflow-x: hidden;
        }
    </style>

    <script>
        $(document).ready(function() {
            $(".toc li a").mouseover(function() {
                var title = $(this).attr('href');
                $(this).attr("title", title);
            });
        })
    </script>




<div class="share">
	<div class="bdsharebuttonbox">
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
	<a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
	<a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
	</div>
	<script>
	window._bd_share_config={
		"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	</script>
</div>



<div class="duoshuo" id="comments">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2017/10/18/Midd-RocketMQ/" data-title="深入解析中间件之-RocketMQ" data-url="http://github.com/zqhxuyuan/2017/10/18/Midd-RocketMQ/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"zqhxuyuan"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>






    <style type="text/css">
    #scroll {
      display: none;
    }
    </style>
    <div class="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
    </div>


  
  
    
    <div class="post-nav-button">
    <a href="/2017/10/22/BookNote-DDIA/" title="上一篇: 读书笔记-Design Data Intensive Applications">
    <i class="fa fa-angle-left"></i>
    </a>
    <a href="/2017/10/18/Midd-TCC-Transactions/" title="下一篇: 深入解析中间件之-TCC事务">
    <i class="fa fa-angle-right"></i>
    </a>
    </div>
  



    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
        
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2019 任何忧伤,都抵不过世界的美丽
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style="display:none">
        <span id="site-visit">本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style="display:none">
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

<script>
  var backgroundnum = 5;
  var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));

  $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
</script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-80646710-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>